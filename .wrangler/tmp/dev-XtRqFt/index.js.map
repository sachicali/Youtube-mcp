{
  "version": 3,
  "sources": ["../bundle-9NTBqh/checked-fetch.js", "../bundle-9NTBqh/strip-cf-connecting-ip-header.js", "../../../src/types/environment.types.ts", "../../../src/services/configuration.service.ts", "../../../src/services/youtube.service.ts", "../../../src/utils/logger.util.ts", "../bundle-9NTBqh/middleware-loader.entry.ts", "../bundle-9NTBqh/middleware-insertion-facade.js", "../../../src/index.ts", "../../../src/remote-mcp-server.ts", "../../../src/services/authentication.service.ts", "../../../src/services/connection-management.service.ts", "../../../src/services/websocket-transport.service.ts", "../../../src/utils/error-handler.util.ts", "../../../src/types/mcp.types.ts", "../../../src/utils/tool-registry.util.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../../../node_modules/wrangler/templates/middleware/common.ts"],
  "sourceRoot": "/Users/chicali/Code/YT-MCP/.wrangler/tmp/dev-XtRqFt",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/**\n * Unified Environment Types\n * Comprehensive type definitions for environment configuration across all services\n */\n\n/**\n * Core environment configuration interface\n * This is the master interface that all services expect\n */\nexport interface CloudflareEnvironment {\n  // Required core variables\n  YOUTUBE_API_KEY: string;\n  ENVIRONMENT: 'development' | 'staging' | 'production';\n\n  // Debug configuration\n  DEBUG?: string;\n  DEBUG_MODE?: boolean;\n\n  // Cloudflare KV namespaces (required)\n  YOUTUBE_MCP_KV: KVNamespace;\n  CACHE_KV?: KVNamespace;\n\n  // OAuth configuration (optional)\n  OAUTH_CLIENT_ID?: string;\n  OAUTH_CLIENT_SECRET?: string;\n\n  // External services\n  YTDLP_SERVICE_URL?: string;\n\n  // Rate limiting configuration\n  RATE_LIMITS?: {\n    requests: number;\n    window: number;\n  };\n  RATE_LIMIT_REQUESTS?: string;\n  RATE_LIMIT_WINDOW?: string;\n\n  // WebSocket configuration\n  WS_MAX_CONNECTIONS?: string;\n  WS_HEARTBEAT_INTERVAL?: string;\n  WS_CONNECTION_TIMEOUT?: string;\n\n  // Authentication configuration\n  AUTH_API_KEY_MIN_LENGTH?: string;\n  AUTH_SESSION_TIMEOUT?: string;\n  AUTH_DEFAULT_QUOTA?: string;\n  AUTH_QUOTA_WARNING_THRESHOLD?: string;\n\n  // Performance configuration\n  PERFORMANCE_TARGET_CACHED?: string;\n  PERFORMANCE_TARGET_KV?: string;\n  PERFORMANCE_TARGET_API?: string;\n\n  // Cache configuration\n  CACHE_DEFAULT_TTL?: string;\n  CACHE_VIDEO_TTL?: string;\n  CACHE_CHANNEL_TTL?: string;\n\n  // Batch configuration\n  BATCH_MAX_VIDEOS?: string;\n  BATCH_MAX_CHANNELS?: string;\n\n  // Retry configuration\n  RETRY_MAX_ATTEMPTS?: string;\n  RETRY_INITIAL_DELAY?: string;\n  RETRY_MAX_DELAY?: string;\n\n  // Monitoring configuration\n  HEALTH_CHECK_INTERVAL?: string;\n  METRICS_RETENTION?: string;\n  ERROR_TRACKING_ENABLED?: string;\n  ERROR_RATE_THRESHOLD?: string;\n\n  // Development configuration\n  DEV_PORT?: string;\n  DEV_CORS_ENABLED?: string;\n  DEV_CORS_ORIGINS?: string;\n  DEV_MOCK_YOUTUBE_API?: string;\n}\n\n/**\n * Cloudflare KV namespace interface\n */\nexport interface KVNamespace {\n  get(key: string, options?: KVNamespaceGetOptions): Promise<string | null>;\n  get(key: string, type: 'text'): Promise<string | null>;\n  get(key: string, type: 'json'): Promise<any>;\n  get(key: string, type: 'arrayBuffer'): Promise<ArrayBuffer | null>;\n  get(key: string, type: 'stream'): Promise<ReadableStream | null>;\n  \n  put(key: string, value: string | ArrayBuffer | ReadableStream, options?: KVNamespacePutOptions): Promise<void>;\n  \n  delete(key: string): Promise<void>;\n  \n  list(options?: KVNamespaceListOptions): Promise<KVNamespaceListResult>;\n}\n\nexport interface KVNamespaceGetOptions {\n  type?: 'text' | 'json' | 'arrayBuffer' | 'stream';\n  cacheTtl?: number;\n}\n\nexport interface KVNamespacePutOptions {\n  expirationTtl?: number;\n  expiration?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface KVNamespaceListOptions {\n  prefix?: string;\n  limit?: number;\n  cursor?: string;\n}\n\nexport interface KVNamespaceListResult {\n  keys: Array<{\n    name: string;\n    expiration?: number;\n    metadata?: Record<string, any>;\n  }>;\n  list_complete: boolean;\n  cursor?: string;\n}\n\n/**\n * Cloudflare Workers ExecutionContext\n */\nexport interface ExecutionContext {\n  waitUntil(promise: Promise<any>): void;\n  passThroughOnException(): void;\n}\n\n/**\n * Cloudflare Workers request context\n */\nexport interface CloudflareRequestContext {\n  request: Request;\n  env: CloudflareEnvironment;\n  ctx: ExecutionContext;\n}\n\n/**\n * Validation result interface\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors: Array<{\n    field: string;\n    message: string;\n    value?: any;\n  }>;\n}\n\n/**\n * Configuration error types\n */\nexport interface ConfigurationError {\n  code: string;\n  message: string;\n  field?: string;\n  value?: any;\n}\n\nexport interface ConfigurationWarning {\n  code: string;\n  message: string;\n  field?: string;\n  recommendation?: string;\n}\n\n/**\n * YouTube API configuration\n */\nexport interface YouTubeApiConfig {\n  apiKey: string;\n  quotaLimit: number;\n  baseUrl: string;\n  requestsPerSecond?: number;\n}\n\n/**\n * OAuth configuration\n */\nexport interface OAuthConfig {\n  clientId: string;\n  clientSecret: string;\n  redirectUri?: string;\n}\n\n/**\n * External services configuration\n */\nexport interface ExternalServicesConfig {\n  transcript?: {\n    serviceUrl: string;\n    timeout?: number;\n  };\n}\n\n/**\n * Cache configuration\n */\nexport interface CacheConfig {\n  enabled: boolean;\n  defaultTtl: number;\n  videoTtl: number;\n  channelTtl: number;\n  ttl: {\n    transcripts: number;\n    videoMetrics: number;\n    channelMetrics: number;\n    comments: number;\n    search: number;\n    trending: number;\n  };\n}\n\n/**\n * Rate limit configuration\n */\nexport interface RateLimitConfig {\n  requests: number;\n  window: number;\n  requestsPerMinute: number;\n}\n\n/**\n * CORS configuration\n */\nexport interface CorsConfig {\n  enabled: boolean;\n  origins: string[];\n  methods: string[];\n  headers: string[];\n}\n\n/**\n * Monitoring configuration\n */\nexport interface MonitoringConfig {\n  enabled: boolean;\n  logLevel: 'debug' | 'info' | 'warn' | 'error';\n  metricsRetention: number;\n  errorTracking: boolean;\n  performanceTracking: boolean;\n}\n\n/**\n * Server configuration interface (derived from environment)\n */\nexport interface ServerConfiguration {\n  environment: 'development' | 'production';\n  debug: boolean;\n  apis: {\n    youtube: YouTubeApiConfig;\n    oauth?: OAuthConfig;\n  };\n  externalServices: ExternalServicesConfig;\n  cache: CacheConfig;\n  rateLimit: RateLimitConfig;\n  rateLimits: RateLimitConfig; // Alias for consistency\n  performance: {\n    targetCached: number;\n    targetKv: number;\n    targetApi: number;\n  };\n  websocket: {\n    maxConnections: number;\n    heartbeatInterval: number;\n    connectionTimeout: number;\n  };\n  authentication: {\n    apiKeyMinLength: number;\n    sessionTimeout: number;\n    defaultQuota: number;\n    quotaWarningThreshold: number;\n  };\n  cors: CorsConfig;\n  monitoring: MonitoringConfig;\n}\n\n/**\n * Configuration defaults\n */\nexport const DEFAULT_CONFIG = {\n  RATE_LIMIT_REQUESTS: 100,\n  RATE_LIMIT_WINDOW: 60000,\n  WS_MAX_CONNECTIONS: 1000,\n  WS_HEARTBEAT_INTERVAL: 30000,\n  WS_CONNECTION_TIMEOUT: 300000,\n  AUTH_API_KEY_MIN_LENGTH: 32,\n  AUTH_SESSION_TIMEOUT: 86400000,\n  AUTH_DEFAULT_QUOTA: 10000,\n  AUTH_QUOTA_WARNING_THRESHOLD: 80,\n  PERFORMANCE_TARGET_CACHED: 50,\n  PERFORMANCE_TARGET_KV: 200,\n  PERFORMANCE_TARGET_API: 500,\n  CACHE_DEFAULT_TTL: 3600,\n  CACHE_VIDEO_TTL: 86400,\n  CACHE_CHANNEL_TTL: 21600,\n  BATCH_MAX_VIDEOS: 50,\n  BATCH_MAX_CHANNELS: 20,\n  RETRY_MAX_ATTEMPTS: 3,\n  RETRY_INITIAL_DELAY: 1000,\n  RETRY_MAX_DELAY: 10000,\n  HEALTH_CHECK_INTERVAL: 300000,\n  METRICS_RETENTION: 86400000,\n  ERROR_RATE_THRESHOLD: 5,\n  DEV_PORT: 8787,\n  YOUTUBE_BASE_URL: 'https://www.googleapis.com/youtube/v3',\n  CACHE_TTL_TRANSCRIPTS: 86400,\n  CACHE_TTL_VIDEO_METRICS: 3600,\n  CACHE_TTL_CHANNEL_METRICS: 7200,\n  CACHE_TTL_COMMENTS: 1800,\n  CACHE_TTL_SEARCH: 900,\n  CACHE_TTL_TRENDING: 600\n} as const;\n\n/**\n * Environment validation utilities\n */\nexport class EnvironmentValidator {\n  static validate(env: CloudflareEnvironment): ValidationResult {\n    const errors: Array<{ field: string; message: string; value?: any }> = [];\n\n    // Required fields\n    if (!env.YOUTUBE_API_KEY) {\n      errors.push({ field: 'YOUTUBE_API_KEY', message: 'is required' });\n    }\n\n    if (!env.ENVIRONMENT) {\n      errors.push({ field: 'ENVIRONMENT', message: 'is required' });\n    }\n\n    if (!env.YOUTUBE_MCP_KV) {\n      errors.push({ field: 'YOUTUBE_MCP_KV', message: 'namespace is required' });\n    }\n\n    // Environment-specific validation\n    if (env.ENVIRONMENT === 'production') {\n      if (env.DEBUG === 'true') {\n        errors.push({ field: 'DEBUG', message: 'should not be enabled in production' });\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n\n  static getNumeric(value: string | undefined, defaultValue: number): number {\n    if (!value) return defaultValue;\n    const parsed = parseInt(value, 10);\n    return isNaN(parsed) ? defaultValue : parsed;\n  }\n\n  static getBoolean(value: string | boolean | undefined, defaultValue: boolean): boolean {\n    if (value === undefined) return defaultValue;\n    if (typeof value === 'boolean') return value;\n    return value.toLowerCase() === 'true';\n  }\n}\n\n/**\n * Configuration factory\n */\nexport class ConfigurationFactory {\n  static createServerConfiguration(env: CloudflareEnvironment): ServerConfiguration {\n    const isDebugMode = EnvironmentValidator.getBoolean(env.DEBUG_MODE, false) || \n                       EnvironmentValidator.getBoolean(env.DEBUG, false) ||\n                       env.ENVIRONMENT === 'development';\n\n    const rateLimitConfig: RateLimitConfig = {\n      requests: EnvironmentValidator.getNumeric(env.RATE_LIMIT_REQUESTS, DEFAULT_CONFIG.RATE_LIMIT_REQUESTS),\n      window: EnvironmentValidator.getNumeric(env.RATE_LIMIT_WINDOW, DEFAULT_CONFIG.RATE_LIMIT_WINDOW),\n      requestsPerMinute: EnvironmentValidator.getNumeric(env.RATE_LIMIT_REQUESTS, DEFAULT_CONFIG.RATE_LIMIT_REQUESTS)\n    };\n\n    const cacheConfig: CacheConfig = {\n      enabled: true,\n      defaultTtl: EnvironmentValidator.getNumeric(env.CACHE_DEFAULT_TTL, DEFAULT_CONFIG.CACHE_DEFAULT_TTL),\n      videoTtl: EnvironmentValidator.getNumeric(env.CACHE_VIDEO_TTL, DEFAULT_CONFIG.CACHE_VIDEO_TTL),\n      channelTtl: EnvironmentValidator.getNumeric(env.CACHE_CHANNEL_TTL, DEFAULT_CONFIG.CACHE_CHANNEL_TTL),\n      ttl: {\n        transcripts: DEFAULT_CONFIG.CACHE_TTL_TRANSCRIPTS,\n        videoMetrics: DEFAULT_CONFIG.CACHE_TTL_VIDEO_METRICS,\n        channelMetrics: DEFAULT_CONFIG.CACHE_TTL_CHANNEL_METRICS,\n        comments: DEFAULT_CONFIG.CACHE_TTL_COMMENTS,\n        search: DEFAULT_CONFIG.CACHE_TTL_SEARCH,\n        trending: DEFAULT_CONFIG.CACHE_TTL_TRENDING\n      }\n    };\n\n    return {\n      environment: env.ENVIRONMENT === 'staging' ? 'development' : env.ENVIRONMENT,\n      debug: isDebugMode,\n      apis: {\n        youtube: {\n          apiKey: env.YOUTUBE_API_KEY,\n          quotaLimit: EnvironmentValidator.getNumeric(env.AUTH_DEFAULT_QUOTA, DEFAULT_CONFIG.AUTH_DEFAULT_QUOTA),\n          baseUrl: DEFAULT_CONFIG.YOUTUBE_BASE_URL,\n          requestsPerSecond: 10\n        },\n        ...(env.OAUTH_CLIENT_ID && env.OAUTH_CLIENT_SECRET ? {\n          oauth: {\n            clientId: env.OAUTH_CLIENT_ID,\n            clientSecret: env.OAUTH_CLIENT_SECRET\n          }\n        } : {})\n      },\n      externalServices: {\n        ...(env.YTDLP_SERVICE_URL ? {\n          transcript: {\n            serviceUrl: env.YTDLP_SERVICE_URL,\n            timeout: 30000\n          }\n        } : {})\n      },\n      cache: cacheConfig,\n      rateLimit: rateLimitConfig,\n      rateLimits: rateLimitConfig, // Alias\n      performance: {\n        targetCached: EnvironmentValidator.getNumeric(env.PERFORMANCE_TARGET_CACHED, DEFAULT_CONFIG.PERFORMANCE_TARGET_CACHED),\n        targetKv: EnvironmentValidator.getNumeric(env.PERFORMANCE_TARGET_KV, DEFAULT_CONFIG.PERFORMANCE_TARGET_KV),\n        targetApi: EnvironmentValidator.getNumeric(env.PERFORMANCE_TARGET_API, DEFAULT_CONFIG.PERFORMANCE_TARGET_API)\n      },\n      websocket: {\n        maxConnections: EnvironmentValidator.getNumeric(env.WS_MAX_CONNECTIONS, DEFAULT_CONFIG.WS_MAX_CONNECTIONS),\n        heartbeatInterval: EnvironmentValidator.getNumeric(env.WS_HEARTBEAT_INTERVAL, DEFAULT_CONFIG.WS_HEARTBEAT_INTERVAL),\n        connectionTimeout: EnvironmentValidator.getNumeric(env.WS_CONNECTION_TIMEOUT, DEFAULT_CONFIG.WS_CONNECTION_TIMEOUT)\n      },\n      authentication: {\n        apiKeyMinLength: EnvironmentValidator.getNumeric(env.AUTH_API_KEY_MIN_LENGTH, DEFAULT_CONFIG.AUTH_API_KEY_MIN_LENGTH),\n        sessionTimeout: EnvironmentValidator.getNumeric(env.AUTH_SESSION_TIMEOUT, DEFAULT_CONFIG.AUTH_SESSION_TIMEOUT),\n        defaultQuota: EnvironmentValidator.getNumeric(env.AUTH_DEFAULT_QUOTA, DEFAULT_CONFIG.AUTH_DEFAULT_QUOTA),\n        quotaWarningThreshold: EnvironmentValidator.getNumeric(env.AUTH_QUOTA_WARNING_THRESHOLD, DEFAULT_CONFIG.AUTH_QUOTA_WARNING_THRESHOLD)\n      },\n      cors: {\n        enabled: EnvironmentValidator.getBoolean(env.DEV_CORS_ENABLED, env.ENVIRONMENT === 'development'),\n        origins: env.DEV_CORS_ORIGINS ? env.DEV_CORS_ORIGINS.split(',') : ['*'],\n        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n        headers: ['Content-Type', 'Authorization', 'X-Requested-With']\n      },\n      monitoring: {\n        enabled: true,\n        logLevel: isDebugMode ? 'debug' : 'info',\n        metricsRetention: EnvironmentValidator.getNumeric(env.METRICS_RETENTION, DEFAULT_CONFIG.METRICS_RETENTION),\n        errorTracking: EnvironmentValidator.getBoolean(env.ERROR_TRACKING_ENABLED, true),\n        performanceTracking: true\n      }\n    };\n  }\n}\n\n/**\n * Type guards\n */\nexport function isCloudflareEnvironment(env: any): env is CloudflareEnvironment {\n  return env && \n         typeof env.YOUTUBE_API_KEY === 'string' &&\n         typeof env.ENVIRONMENT === 'string' &&\n         env.YOUTUBE_MCP_KV &&\n         typeof env.YOUTUBE_MCP_KV.get === 'function';\n}\n\nexport function isValidEnvironmentType(env: string): env is CloudflareEnvironment['ENVIRONMENT'] {\n  return ['development', 'staging', 'production'].includes(env);\n}\n\n/**\n * Cache service interface (simplified)\n */\nexport interface CacheService {\n  get(key: string): Promise<string | null>;\n  set(key: string, value: string, ttl?: number): Promise<void>;\n  delete(key: string): Promise<void>;\n  cleanup(): Promise<void>;\n}\n\n/**\n * Environment utilities\n */\nexport class EnvironmentUtils {\n  static isDevelopment(env: CloudflareEnvironment): boolean {\n    return env.ENVIRONMENT === 'development';\n  }\n\n  static isProduction(env: CloudflareEnvironment): boolean {\n    return env.ENVIRONMENT === 'production';\n  }\n\n  static isDebugEnabled(env: CloudflareEnvironment): boolean {\n    return EnvironmentValidator.getBoolean(env.DEBUG_MODE, false) || \n           EnvironmentValidator.getBoolean(env.DEBUG, false) || \n           this.isDevelopment(env);\n  }\n\n  static getQuotaLimit(env: CloudflareEnvironment): number {\n    return EnvironmentValidator.getNumeric(env.AUTH_DEFAULT_QUOTA, DEFAULT_CONFIG.AUTH_DEFAULT_QUOTA);\n  }\n\n  static getRateLimits(env: CloudflareEnvironment): { requests: number; window: number } {\n    return {\n      requests: EnvironmentValidator.getNumeric(env.RATE_LIMIT_REQUESTS, DEFAULT_CONFIG.RATE_LIMIT_REQUESTS),\n      window: EnvironmentValidator.getNumeric(env.RATE_LIMIT_WINDOW, DEFAULT_CONFIG.RATE_LIMIT_WINDOW)\n    };\n  }\n}", "/**\n * Configuration Service\n * Manages environment configuration and provides typed configuration objects\n */\n\nimport type { \n  CloudflareEnvironment,\n  ServerConfiguration,\n  ValidationResult,\n  ConfigurationError,\n  ConfigurationWarning,\n  ConfigurationFactory,\n  EnvironmentValidator\n} from '@/types/environment.types';\n\nimport { \n  ConfigurationFactory as Factory,\n  EnvironmentValidator as Validator\n} from '@/types/environment.types';\n\n/**\n * Enhanced validation result with warnings\n */\ninterface ExtendedValidationResult extends ValidationResult {\n  warnings: ConfigurationWarning[];\n}\n\n/**\n * Configuration service for managing environment settings\n */\nexport class ConfigurationService {\n  private env: CloudflareEnvironment;\n  private config: ServerConfiguration;\n  private initialized: boolean = false;\n\n  constructor(env: CloudflareEnvironment) {\n    this.env = env;\n    this.config = Factory.createServerConfiguration(env);\n  }\n\n  /**\n   * Initialize the configuration service (async initialization if needed)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    const validation = this.validateEnvironment(this.env);\n    if (!validation.valid) {\n      const errorMessages = validation.errors.map(e => `${e.field}: ${e.message}`).join(', ');\n      throw new Error(`Invalid environment configuration: ${errorMessages}`);\n    }\n\n    this.initialized = true;\n  }\n\n  /**\n   * Get the complete server configuration\n   */\n  getConfig(): ServerConfiguration {\n    return this.config;\n  }\n\n  /**\n   * Get the complete server configuration (alias for compatibility)\n   */\n  getConfiguration(): ServerConfiguration {\n    return this.config;\n  }\n\n  /**\n   * Get environment type\n   */\n  getEnvironment(): 'development' | 'production' {\n    const env = this.env.ENVIRONMENT;\n    return env === 'staging' ? 'development' : env;\n  }\n\n  /**\n   * Check if debug mode is enabled\n   */\n  isDebugMode(): boolean {\n    return this.config.debug;\n  }\n\n  /**\n   * Get YouTube API configuration\n   */\n  getYouTubeConfig() {\n    return this.config.apis.youtube;\n  }\n\n  /**\n   * Get cache configuration\n   */\n  getCacheConfig() {\n    return this.config.cache;\n  }\n\n  /**\n   * Get rate limiting configuration\n   */\n  getRateLimitConfig() {\n    return this.config.rateLimits;\n  }\n\n  /**\n   * Get WebSocket configuration\n   */\n  getWebSocketConfig() {\n    return this.config.websocket;\n  }\n\n  /**\n   * Get authentication configuration\n   */\n  getAuthConfig() {\n    return this.config.authentication;\n  }\n\n  /**\n   * Get CORS configuration\n   */\n  getCorsConfig() {\n    return this.config.cors;\n  }\n\n  /**\n   * Get monitoring configuration\n   */\n  getMonitoringConfig() {\n    return this.config.monitoring;\n  }\n\n  /**\n   * Get external services configuration\n   */\n  getExternalServicesConfig() {\n    return this.config.externalServices;\n  }\n\n  /**\n   * Get performance configuration\n   */\n  getPerformanceConfig() {\n    return this.config.performance;\n  }\n\n  /**\n   * Check if service is initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  /**\n   * Validate environment configuration\n   */\n  private validateEnvironment(env: CloudflareEnvironment): ExtendedValidationResult {\n    const basicValidation = Validator.validate(env);\n    const warnings: ConfigurationWarning[] = [];\n    const errors: Array<{ field: string; message: string; value?: any }> = [...basicValidation.errors];\n\n    // Additional validation logic\n    if (env.ENVIRONMENT === 'production') {\n      if (env.DEBUG === 'true') {\n        warnings.push({\n          code: 'PROD_DEBUG_ENABLED',\n          message: 'Debug mode should not be enabled in production',\n          field: 'DEBUG',\n          recommendation: 'Set DEBUG=false or remove DEBUG environment variable'\n        });\n      }\n\n      if (!env.OAUTH_CLIENT_ID || !env.OAUTH_CLIENT_SECRET) {\n        warnings.push({\n          code: 'MISSING_OAUTH',\n          message: 'OAuth credentials not configured for production',\n          field: 'OAUTH_CLIENT_ID',\n          recommendation: 'Configure OAuth credentials for enhanced functionality'\n        });\n      }\n    }\n\n    // Performance warnings\n    const rateLimitRequests = Validator.getNumeric(env.RATE_LIMIT_REQUESTS, 100);\n    if (rateLimitRequests > 1000) {\n      warnings.push({\n        code: 'HIGH_RATE_LIMIT',\n        message: 'Rate limit is set very high',\n        field: 'RATE_LIMIT_REQUESTS',\n        recommendation: 'Consider lowering rate limit for better resource management'\n      });\n    }\n\n    // CORS warnings\n    if (env.DEV_CORS_ENABLED === 'true' && env.ENVIRONMENT === 'production') {\n      warnings.push({\n        code: 'CORS_ENABLED_PROD',\n        message: 'CORS is enabled in production',\n        field: 'DEV_CORS_ENABLED',\n        recommendation: 'Review CORS configuration for production security'\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Get configuration warnings\n   */\n  getConfigurationWarnings(): ConfigurationWarning[] {\n    const validation = this.validateEnvironment(this.env) as ExtendedValidationResult;\n    return validation.warnings;\n  }\n\n  /**\n   * Get raw environment variables\n   */\n  getRawEnvironment(): CloudflareEnvironment {\n    return this.env;\n  }\n\n  /**\n   * Update environment configuration (for testing purposes)\n   */\n  updateEnvironment(env: CloudflareEnvironment): void {\n    this.env = env;\n    this.config = Factory.createServerConfiguration(env);\n    this.initialized = false;\n  }\n\n  /**\n   * Validate current configuration\n   */\n  validateConfiguration(): ExtendedValidationResult {\n    return this.validateEnvironment(this.env);\n  }\n}\n", "/**\n * YouTube Service\n * \n * Handles YouTube API integration, transcript extraction, and video analytics.\n * Implements caching, rate limiting, and error handling for production use.\n */\n\nimport type { \n  YouTubeVideoResponse,\n  VideoTranscript,\n  TranscriptSegment,\n  VideoMetrics,\n  VideoInfo,\n  YouTubeAPIError,\n  TranscriptError\n} from '@/types/youtube.types';\nimport type { CloudflareEnvironment } from '@/types/environment.types';\nimport type { LoggerUtil } from '@/utils/logger.util';\nimport type { ConfigurationService } from '@/services/configuration.service';\n\nexport interface YouTubeServiceInterface {\n  getVideoTranscript(videoUrl: string, language?: string): Promise<VideoTranscript>;\n  getVideoMetrics(videoId: string): Promise<VideoMetrics>;\n  getVideoInfo(videoId: string): Promise<VideoInfo>;\n  makeAPIRequest(endpoint: string, params: Record<string, string>): Promise<any>;\n}\n\nexport class YouTubeService implements YouTubeServiceInterface {\n  private config: ConfigurationService;\n  private logger: LoggerUtil;\n  private env: CloudflareEnvironment;\n  private apiKey: string;\n  private baseUrl: string;\n\n  constructor(\n    config: ConfigurationService,\n    logger: LoggerUtil,\n    env: CloudflareEnvironment\n  ) {\n    this.config = config;\n    this.logger = logger;\n    this.env = env;\n    \n    const youtubeConfig = this.config.getYouTubeConfig();\n    this.apiKey = youtubeConfig.apiKey;\n    this.baseUrl = youtubeConfig.baseUrl;\n  }\n\n  /**\n   * Extract transcript from YouTube video URL or video ID\n   * Uses YouTube Data API with alternative approaches for transcript extraction\n   */\n  async getVideoTranscript(videoUrl: string, language: string = 'en'): Promise<VideoTranscript> {\n    this.logger.info('Getting video transcript', { videoUrl, language });\n\n    try {\n      // Extract video ID from URL\n      const videoId = YouTubeService.extractVideoId(videoUrl);\n      if (!videoId) {\n        throw new Error(`Invalid YouTube URL or video ID: ${videoUrl}`);\n      }\n\n      // Validate video ID format\n      if (!YouTubeService.isValidVideoId(videoId)) {\n        throw new Error(`Invalid video ID format: ${videoId}`);\n      }\n\n      // Check cache first\n      const cacheKey = `transcript:${videoId}:${language}`;\n      const cached = await this.getCachedData<VideoTranscript>(cacheKey);\n      if (cached) {\n        this.logger.info('Transcript cache hit', { videoId, language });\n        return cached;\n      }\n\n      // Get video info first to validate video exists and get metadata\n      const videoInfo = await this.getVideoInfo(videoId);\n      \n      // Check if captions are available\n      if (!videoInfo.contentDetails.caption) {\n        throw new TranscriptNotAvailableError(\n          videoId,\n          'not_available',\n          'No captions available for this video',\n          []\n        );\n      }\n\n      // Attempt to get captions list (this will work for public caption tracks)\n      let captionsResponse;\n      try {\n        captionsResponse = await this.makeYouTubeAPIRequest(\n          'captions',\n          { part: 'snippet', videoId }\n        );\n      } catch (error) {\n        // If captions API fails (likely due to auth requirements), provide a structured response\n        // indicating that transcripts are available but require additional authentication\n        this.logger.warn('Captions API requires authentication, providing structured fallback', {\n          videoId,\n          error: error instanceof Error ? error.message : String(error)\n        });\n\n        return this.createFallbackTranscriptResponse(videoId, videoInfo, language);\n      }\n\n      if (!captionsResponse.items || captionsResponse.items.length === 0) {\n        // For videos with captions but no accessible caption tracks via API\n        return this.createFallbackTranscriptResponse(videoId, videoInfo, language);\n      }\n\n      // Find the best caption track\n      const captionTrack = this.findBestCaptionTrack(captionsResponse.items, language);\n      if (!captionTrack) {\n        const availableLanguages = captionsResponse.items.map((item: any) => item.snippet.language);\n        throw new TranscriptNotAvailableError(\n          videoId,\n          'language_not_supported',\n          `Language '${language}' not available`,\n          availableLanguages\n        );\n      }\n\n      // Since direct caption download requires OAuth, provide structured metadata\n      // about the available transcript with guidance on how to access it\n      const transcript: VideoTranscript = {\n        videoId,\n        language: captionTrack.snippet.language,\n        isAutoGenerated: captionTrack.snippet.trackKind === 'asr',\n        segments: this.createPlaceholderSegments(videoInfo),\n        fullText: this.createTranscriptPlaceholder(videoInfo, captionTrack),\n        wordCount: 0, // Will be updated when actual transcript is available\n        estimatedReadingTime: 0,\n      };\n\n      // Cache the result\n      await this.setCachedData(cacheKey, transcript, this.config.getCacheConfig().ttl.transcripts);\n\n      this.logger.info('Transcript metadata extracted successfully', {\n        videoId,\n        language,\n        isAutoGenerated: transcript.isAutoGenerated,\n        captionTrackId: captionTrack.id,\n      });\n\n      return transcript;\n\n    } catch (error) {\n      this.logger.error('Failed to get video transcript', {\n        videoUrl,\n        language,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      if (error instanceof TranscriptNotAvailableError) {\n        throw error;\n      }\n\n      throw new Error(`Failed to extract transcript: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Get video metrics and analytics\n   */\n  async getVideoMetrics(videoId: string): Promise<VideoMetrics> {\n    this.logger.info('Getting video metrics', { videoId });\n\n    try {\n      // Check cache first\n      const cacheKey = `metrics:${videoId}`;\n      const cached = await this.getCachedData<VideoMetrics>(cacheKey);\n      if (cached) {\n        this.logger.info('Metrics cache hit', { videoId });\n        return cached;\n      }\n\n      const response = await this.makeYouTubeAPIRequest('videos', {\n        part: 'statistics,contentDetails,snippet',\n        id: videoId,\n      });\n\n      if (!response.items || response.items.length === 0) {\n        throw new Error(`Video not found: ${videoId}`);\n      }\n\n      const video = response.items[0] as YouTubeVideoResponse;\n      const stats = video.statistics;\n      const contentDetails = video.contentDetails;\n\n      if (!stats) {\n        throw new Error('Video statistics not available');\n      }\n\n      // Calculate engagement metrics\n      const viewCount = parseInt(stats.viewCount || '0');\n      const likeCount = parseInt(stats.likeCount || '0');\n      const commentCount = parseInt(stats.commentCount || '0');\n      const favoriteCount = parseInt(stats.favoriteCount || '0');\n\n      const likeRatio = viewCount > 0 ? (likeCount / viewCount) * 100 : 0;\n      const commentRatio = viewCount > 0 ? (commentCount / viewCount) * 100 : 0;\n      const engagementScore = (likeCount + commentCount) / Math.max(viewCount, 1) * 100;\n\n      const metrics: VideoMetrics = {\n        viewCount,\n        likeCount,\n        commentCount,\n        favoriteCount,\n        dislikeCount: stats.dislikeCount ? parseInt(stats.dislikeCount) : undefined,\n        publishedAt: video.snippet.publishedAt,\n        duration: contentDetails?.duration || 'PT0S',\n        engagement: {\n          likeRatio: Math.round(likeRatio * 100) / 100,\n          commentRatio: Math.round(commentRatio * 100) / 100,\n          engagementScore: Math.round(engagementScore * 100) / 100,\n        },\n      };\n\n      // Cache the result\n      await this.setCachedData(cacheKey, metrics, this.config.getCacheConfig().ttl.videoMetrics);\n\n      this.logger.info('Video metrics retrieved successfully', {\n        videoId,\n        viewCount,\n        likeCount,\n        commentCount,\n        engagementScore: metrics.engagement.engagementScore,\n      });\n\n      return metrics;\n\n    } catch (error) {\n      this.logger.error('Failed to get video metrics', {\n        videoId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw new Error(`Failed to get video metrics: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Get comprehensive video information\n   */\n  async getVideoInfo(videoId: string): Promise<VideoInfo> {\n    this.logger.info('Getting video info', { videoId });\n\n    try {\n      const response = await this.makeYouTubeAPIRequest('videos', {\n        part: 'snippet,statistics,contentDetails,status',\n        id: videoId,\n      });\n\n      if (!response.items || response.items.length === 0) {\n        throw new Error(`Video not found: ${videoId}`);\n      }\n\n      const video = response.items[0] as YouTubeVideoResponse;\n      const metrics = await this.getVideoMetrics(videoId);\n\n      const videoInfo: VideoInfo = {\n        videoId,\n        title: video.snippet.title,\n        description: video.snippet.description,\n        channelId: video.snippet.channelId,\n        channelTitle: video.snippet.channelTitle,\n        metrics,\n        tags: video.snippet.tags || [],\n        categoryId: video.snippet.categoryId,\n        thumbnails: {\n          default: video.snippet.thumbnails.default?.url,\n          medium: video.snippet.thumbnails.medium?.url,\n          high: video.snippet.thumbnails.high?.url,\n        },\n        contentDetails: {\n          duration: video.contentDetails?.duration || 'PT0S',\n          definition: video.contentDetails?.definition || 'sd',\n          caption: video.contentDetails?.caption === 'true',\n          licensedContent: video.contentDetails?.licensedContent || false,\n        },\n        status: {\n          privacyStatus: video.status?.privacyStatus || 'public',\n          embeddable: video.status?.embeddable || true,\n          publicStatsViewable: video.status?.publicStatsViewable || true,\n        },\n      };\n\n      this.logger.info('Video info retrieved successfully', {\n        videoId,\n        title: videoInfo.title,\n        channelTitle: videoInfo.channelTitle,\n        duration: videoInfo.contentDetails.duration,\n      });\n\n      return videoInfo;\n\n    } catch (error) {\n      this.logger.error('Failed to get video info', {\n        videoId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw new Error(`Failed to get video info: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Public method to make YouTube API requests (for tool usage)\n   */\n  async makeAPIRequest(\n    endpoint: string,\n    params: Record<string, string>\n  ): Promise<any> {\n    return this.makeYouTubeAPIRequest(endpoint, params);\n  }\n\n  /**\n   * Make YouTube API request with error handling and rate limiting\n   */\n  private async makeYouTubeAPIRequest(\n    endpoint: string,\n    params: Record<string, string>\n  ): Promise<any> {\n    const url = new URL(`${this.baseUrl}/${endpoint}`);\n    url.searchParams.set('key', this.apiKey);\n    \n    Object.entries(params).forEach(([key, value]) => {\n      url.searchParams.set(key, value);\n    });\n\n    this.logger.debug('Making YouTube API request', {\n      endpoint,\n      params,\n      url: url.toString(),\n    });\n\n    try {\n      const response = await fetch(url.toString(), {\n        method: 'GET',\n        headers: {\n          'User-Agent': 'YouTube-MCP-Server/1.0',\n          'Accept': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json() as { error: YouTubeAPIError };\n        throw new YouTubeAPIRequestError(\n          errorData.error.code,\n          errorData.error.message,\n          errorData.error.status\n        );\n      }\n\n      const data = await response.json();\n      \n      this.logger.debug('YouTube API request successful', {\n        endpoint,\n        status: response.status,\n        resultCount: data.items?.length || 0,\n      });\n\n      return data;\n\n    } catch (error) {\n      if (error instanceof YouTubeAPIRequestError) {\n        throw error;\n      }\n\n      this.logger.error('YouTube API request failed', {\n        endpoint,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw new Error(`YouTube API request failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Find the best caption track for the requested language\n   */\n  private findBestCaptionTrack(captionTracks: any[], language: string): any | null {\n    // First, try to find exact language match\n    let track = captionTracks.find(track => track.snippet.language === language);\n    if (track) return track;\n\n    // Try language without region (e.g., 'en' instead of 'en-US')\n    const baseLanguage = language.split('-')[0];\n    track = captionTracks.find(track => track.snippet.language.startsWith(baseLanguage));\n    if (track) return track;\n\n    // Fall back to English\n    track = captionTracks.find(track => track.snippet.language.startsWith('en'));\n    if (track) return track;\n\n    // Fall back to any available track\n    return captionTracks[0] || null;\n  }\n\n  /**\n   * Create a fallback transcript response when direct API access is limited\n   */\n  private createFallbackTranscriptResponse(videoId: string, videoInfo: VideoInfo, language: string): VideoTranscript {\n    return {\n      videoId,\n      language,\n      isAutoGenerated: true, // Most YouTube videos have auto-generated captions\n      segments: this.createPlaceholderSegments(videoInfo),\n      fullText: this.createTranscriptPlaceholder(videoInfo),\n      wordCount: 0,\n      estimatedReadingTime: 0,\n    };\n  }\n\n  /**\n   * Create placeholder segments based on video duration\n   */\n  private createPlaceholderSegments(videoInfo: VideoInfo): TranscriptSegment[] {\n    const durationSeconds = this.parseDuration(videoInfo.contentDetails.duration);\n    const segments: TranscriptSegment[] = [];\n    \n    // Create segments every 30 seconds as placeholders\n    const segmentDuration = 30;\n    const numSegments = Math.ceil(durationSeconds / segmentDuration);\n    \n    for (let i = 0; i < Math.min(numSegments, 10); i++) { // Limit to 10 placeholder segments\n      const start = i * segmentDuration;\n      const end = Math.min(start + segmentDuration, durationSeconds);\n      \n      segments.push({\n        text: `[Transcript segment ${i + 1} - ${this.formatTime(start)} to ${this.formatTime(end)}]`,\n        start,\n        duration: end - start,\n        end,\n      });\n    }\n    \n    return segments;\n  }\n\n  /**\n   * Create transcript placeholder text with available information\n   */\n  private createTranscriptPlaceholder(videoInfo: VideoInfo, captionTrack?: any): string {\n    const lines = [\n      `Video: ${videoInfo.title}`,\n      `Channel: ${videoInfo.channelTitle}`,\n      `Duration: ${this.formatDuration(videoInfo.contentDetails.duration)}`,\n      ``,\n      `Transcript Status: Captions are available for this video.`,\n      ``\n    ];\n\n    if (captionTrack) {\n      lines.push(\n        `Caption Language: ${captionTrack.snippet.language}`,\n        `Caption Type: ${captionTrack.snippet.trackKind === 'asr' ? 'Auto-generated' : 'Manual'}`,\n        ``\n      );\n    }\n\n    lines.push(\n      `Note: Full transcript extraction requires additional authentication for the YouTube Captions API.`,\n      `This response provides video metadata and confirms transcript availability.`,\n      ``,\n      `To access the full transcript, consider:`,\n      `1. Using YouTube's auto-generated transcript feature directly on the video page`,\n      `2. Implementing OAuth 2.0 authentication for the YouTube Captions API`,\n      `3. Using an external transcript extraction service`\n    );\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Parse ISO 8601 duration to seconds\n   */\n  private parseDuration(duration: string): number {\n    const match = duration.match(/PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?/);\n    if (!match) return 0;\n    \n    const hours = parseInt(match[1] || '0');\n    const minutes = parseInt(match[2] || '0');\n    const seconds = parseInt(match[3] || '0');\n    \n    return hours * 3600 + minutes * 60 + seconds;\n  }\n\n  /**\n   * Format seconds to MM:SS or HH:MM:SS\n   */\n  private formatTime(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = seconds % 60;\n    \n    if (hours > 0) {\n      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n  }\n\n  /**\n   * Format ISO 8601 duration to human readable\n   */\n  private formatDuration(duration: string): string {\n    const seconds = this.parseDuration(duration);\n    return this.formatTime(seconds);\n  }\n\n  /**\n   * Parse transcript content from various formats\n   */\n  private parseTranscriptContent(content: string): TranscriptSegment[] {\n    // This would parse VTT, SRT, or other caption formats\n    // For now, return placeholder implementation\n    const segments: TranscriptSegment[] = [];\n    \n    // Split content into segments (simplified parsing)\n    const lines = content.split('\\n').filter(line => line.trim());\n    \n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n      if (line && !line.includes('-->') && !line.match(/^\\d+$/)) {\n        segments.push({\n          text: line,\n          start: i * 3, // Placeholder timing\n          duration: 3,\n          end: (i + 1) * 3,\n        });\n      }\n    }\n\n    return segments;\n  }\n\n  /**\n   * Get data from cache\n   */\n  private async getCachedData<T>(key: string): Promise<T | null> {\n    try {\n      if (!this.config.getCacheConfig().enabled) {\n        return null;\n      }\n\n      const cached = await this.env.CACHE_KV?.get(key);\n      if (cached) {\n        return JSON.parse(cached) as T;\n      }\n    } catch (error) {\n      this.logger.warn('Cache read failed', {\n        key,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n    return null;\n  }\n\n  /**\n   * Set data in cache\n   */\n  private async setCachedData<T>(key: string, data: T, ttl: number): Promise<void> {\n    try {\n      if (!this.config.getCacheConfig().enabled) {\n        return;\n      }\n\n      await this.env.CACHE_KV?.put(key, JSON.stringify(data), {\n        expirationTtl: ttl,\n      });\n\n      this.logger.debug('Data cached successfully', { key, ttl });\n    } catch (error) {\n      this.logger.warn('Cache write failed', {\n        key,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n\n  /**\n   * Extract video ID from various YouTube URL formats\n   */\n  static extractVideoId(url: string): string | null {\n    const patterns = [\n      /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/|youtube\\.com\\/embed\\/)([^&\\n?#]+)/,\n      /^([a-zA-Z0-9_-]{11})$/, // Direct video ID\n    ];\n\n    for (const pattern of patterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[1];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validate video ID format\n   */\n  static isValidVideoId(videoId: string): boolean {\n    return /^[a-zA-Z0-9_-]{11}$/.test(videoId);\n  }\n}\n\n/**\n * Custom error classes\n */\nexport class YouTubeAPIRequestError extends Error {\n  public readonly code: number;\n  public readonly status: string;\n\n  constructor(code: number, message: string, status: string) {\n    super(message);\n    this.name = 'YouTubeAPIRequestError';\n    this.code = code;\n    this.status = status;\n  }\n}\n\nexport class TranscriptNotAvailableError extends Error implements TranscriptError {\n  public readonly videoId: string;\n  public readonly error: 'not_available' | 'language_not_supported' | 'private_video' | 'api_error';\n  public readonly availableLanguages?: string[];\n\n  constructor(\n    videoId: string,\n    error: TranscriptError['error'],\n    message: string,\n    availableLanguages?: string[]\n  ) {\n    super(message);\n    this.name = 'TranscriptNotAvailableError';\n    this.videoId = videoId;\n    this.error = error;\n    this.availableLanguages = availableLanguages;\n  }\n}", "/**\n * Logger Utility\n * \n * Centralized logging utility with structured logging support\n * and environment-aware log levels.\n */\n\nimport type { ServerConfiguration } from '@/types/environment.types';\n\nexport interface LogContext {\n  [key: string]: unknown;\n}\n\nexport interface LogLevel {\n  level: 'debug' | 'info' | 'warn' | 'error';\n  priority: number;\n}\n\nexport class LoggerUtil {\n  private config: ServerConfiguration;\n  private logLevels: Record<string, LogLevel> = {\n    debug: { level: 'debug', priority: 0 },\n    info: { level: 'info', priority: 1 },\n    warn: { level: 'warn', priority: 2 },\n    error: { level: 'error', priority: 3 },\n  };\n\n  constructor(config: ServerConfiguration) {\n    this.config = config;\n  }\n\n  /**\n   * Log debug message\n   */\n  debug(message: string, context?: LogContext): void {\n    this.log('debug', message, context);\n  }\n\n  /**\n   * Log info message\n   */\n  info(message: string, context?: LogContext): void {\n    this.log('info', message, context);\n  }\n\n  /**\n   * Log warning message\n   */\n  warn(message: string, context?: LogContext): void {\n    this.log('warn', message, context);\n  }\n\n  /**\n   * Log error message\n   */\n  error(message: string, context?: LogContext): void {\n    this.log('error', message, context);\n  }\n\n  /**\n   * Core logging method\n   */\n  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, context?: LogContext): void {\n    const currentLevel = this.logLevels[this.config.monitoring.logLevel];\n    const targetLevel = this.logLevels[level];\n\n    // Skip if log level is below configured threshold\n    if (targetLevel.priority < currentLevel.priority) {\n      return;\n    }\n\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      environment: this.config.environment,\n      ...context,\n    };\n\n    // Use appropriate console method\n    switch (level) {\n      case 'debug':\n        console.debug(JSON.stringify(logEntry));\n        break;\n      case 'info':\n        console.info(JSON.stringify(logEntry));\n        break;\n      case 'warn':\n        console.warn(JSON.stringify(logEntry));\n        break;\n      case 'error':\n        console.error(JSON.stringify(logEntry));\n        break;\n    }\n  }\n\n  /**\n   * Log performance metrics\n   */\n  logPerformance(operation: string, startTime: number, context?: LogContext): void {\n    const duration = Date.now() - startTime;\n    this.info(`Performance: ${operation}`, {\n      operation,\n      duration,\n      performanceCategory: duration < 100 ? 'fast' : duration < 500 ? 'medium' : 'slow',\n      ...context,\n    });\n  }\n\n  /**\n   * Log request metrics\n   */\n  logRequest(\n    method: string,\n    url: string,\n    statusCode: number,\n    duration: number,\n    context?: LogContext\n  ): void {\n    const level = statusCode >= 400 ? 'warn' : 'info';\n    this.log(level, `${method} ${url} ${statusCode}`, {\n      method,\n      url,\n      statusCode,\n      duration,\n      requestCategory: statusCode >= 500 ? 'server_error' : statusCode >= 400 ? 'client_error' : 'success',\n      ...context,\n    });\n  }\n\n  /**\n   * Log quota usage\n   */\n  logQuotaUsage(\n    operation: string,\n    quotaUsed: number,\n    quotaRemaining: number,\n    context?: LogContext\n  ): void {\n    const usagePercent = (quotaUsed / (quotaUsed + quotaRemaining)) * 100;\n    const level = usagePercent > 90 ? 'warn' : usagePercent > 75 ? 'info' : 'debug';\n    \n    this.log(level, `Quota usage: ${operation}`, {\n      operation,\n      quotaUsed,\n      quotaRemaining,\n      usagePercent: Math.round(usagePercent),\n      quotaCategory: usagePercent > 90 ? 'critical' : usagePercent > 75 ? 'high' : 'normal',\n      ...context,\n    });\n  }\n\n  /**\n   * Log cache metrics\n   */\n  logCacheMetrics(\n    operation: string,\n    hit: boolean,\n    key: string,\n    ttl?: number,\n    context?: LogContext\n  ): void {\n    this.debug(`Cache ${hit ? 'hit' : 'miss'}: ${operation}`, {\n      operation,\n      cacheHit: hit,\n      cacheKey: key,\n      ttl,\n      ...context,\n    });\n  }\n\n  /**\n   * Create child logger with persistent context\n   */\n  child(persistentContext: LogContext): LoggerUtil {\n    const childLogger = new LoggerUtil(this.config);\n    \n    // Override log method to include persistent context\n    const originalLog = childLogger.log.bind(childLogger);\n    childLogger.log = (\n      level: 'debug' | 'info' | 'warn' | 'error',\n      message: string,\n      context?: LogContext\n    ) => {\n      originalLog(level, message, { ...persistentContext, ...context });\n    };\n    \n    return childLogger;\n  }\n\n  /**\n   * Get current log level\n   */\n  getLogLevel(): string {\n    return this.config.monitoring.logLevel;\n  }\n\n  /**\n   * Check if level should be logged\n   */\n  shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n    const currentLevel = this.logLevels[this.config.monitoring.logLevel];\n    const targetLevel = this.logLevels[level];\n    return targetLevel.priority >= currentLevel.priority;\n  }\n}", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/chicali/Code/YT-MCP/.wrangler/tmp/bundle-9NTBqh/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/chicali/Code/YT-MCP/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/chicali/Code/YT-MCP/.wrangler/tmp/bundle-9NTBqh/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/chicali/Code/YT-MCP/.wrangler/tmp/bundle-9NTBqh/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/chicali/Code/YT-MCP/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/chicali/Code/YT-MCP/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/chicali/Code/YT-MCP/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/chicali/Code/YT-MCP/src/index.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "/**\n * YouTube Scraping MCP Server\n * Cloudflare Workers entry point with Remote MCP capabilities\n */\n\nimport { RemoteMCPServer } from './remote-mcp-server';\nimport { ConfigurationService } from './services/configuration.service';\nimport { LoggerUtil } from './utils/logger.util';\nimport { ErrorHandlerUtil } from './utils/error-handler.util';\nimport { ToolRegistryUtil } from './utils/tool-registry.util';\nimport type { CloudflareEnvironment, ExecutionContext, CloudflareRequestContext } from './types/environment.types';\n\n/**\n * Global service instances (lazy loaded)\n */\nlet configService: ConfigurationService | null = null;\nlet logger: LoggerUtil | null = null;\nlet toolRegistry: ToolRegistryUtil | null = null;\nlet errorHandler: ErrorHandlerUtil | null = null;\nlet remoteMCPServer: RemoteMCPServer | null = null;\n\n/**\n * Cloudflare Worker interface\n */\ninterface Env extends CloudflareEnvironment {}\n\n/**\n * Worker export interface\n */\nexport interface ExportedHandler {\n  fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response>;\n}\n\n/**\n * Initialize all services with lazy loading pattern\n */\nasync function initializeServices(env: CloudflareEnvironment): Promise<void> {\n  // Return early if already initialized\n  if (configService && logger && toolRegistry && errorHandler && remoteMCPServer) {\n    return;\n  }\n\n  try {\n    // Initialize configuration service\n    if (!configService) {\n      configService = new ConfigurationService(env);\n      await configService.initialize();\n    }\n\n    // Initialize logger\n    if (!logger) {\n      logger = new LoggerUtil(configService.getConfiguration());\n    }\n\n    // Initialize error handler\n    if (!errorHandler) {\n      errorHandler = new ErrorHandlerUtil(logger);\n    }\n\n    // Initialize tool registry\n    if (!toolRegistry) {\n      toolRegistry = new ToolRegistryUtil(configService, logger);\n    }\n\n    // Initialize Remote MCP Server\n    if (!remoteMCPServer) {\n      remoteMCPServer = new RemoteMCPServer(env);\n      await remoteMCPServer.initialize();\n    }\n\n    logger.info('All services initialized successfully');\n\n  } catch (error) {\n    console.error('Service initialization failed:', error);\n    throw error;\n  }\n}\n\n/**\n * Main fetch handler for Cloudflare Workers\n */\nasync function fetch(request: Request, env: CloudflareEnvironment, ctx: ExecutionContext): Promise<Response> {\n  try {\n    // Initialize services if not already done\n    await initializeServices(env);\n\n    // Ensure services are initialized\n    if (!configService || !logger || !toolRegistry || !errorHandler || !remoteMCPServer) {\n      throw new Error('Failed to initialize services');\n    }\n\n    // Create the context object that handleRequest expects\n    const context: CloudflareRequestContext = {\n      request,\n      env,\n      ctx\n    };\n\n    // Handle the request through the Remote MCP Server\n    return await remoteMCPServer.handleRequest(context);\n\n  } catch (error) {\n    // Fallback error handling if services aren't initialized\n    console.error('Worker error:', error);\n    \n    return new Response(JSON.stringify({\n      jsonrpc: '2.0',\n      error: {\n        code: -32603,\n        message: 'Internal error',\n        data: {\n          error: error instanceof Error ? error.message : 'Unknown error',\n          timestamp: new Date().toISOString()\n        }\n      },\n      id: null\n    }), {\n      status: 500,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization'\n      }\n    });\n  }\n}\n\n/**\n * Health check endpoint for service monitoring\n */\nasync function healthCheck(\n  request: Request,\n  env: CloudflareEnvironment,\n  ctx: ExecutionContext\n): Promise<Response> {\n  try {\n    await initializeServices(env);\n\n    const health = {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      services: {\n        configuration: configService?.isInitialized() ?? false,\n        logger: logger !== null,\n        toolRegistry: toolRegistry !== null,\n        errorHandler: errorHandler !== null,\n        remoteMCPServer: remoteMCPServer !== null\n      },\n      environment: env.ENVIRONMENT,\n      version: '0.3.0'\n    };\n\n    return new Response(JSON.stringify(health, null, 2), {\n      status: 200,\n      headers: {\n        'Content-Type': 'application/json',\n        'Cache-Control': 'no-cache'\n      }\n    });\n\n  } catch (error) {\n    const errorHealth = {\n      status: 'unhealthy',\n      timestamp: new Date().toISOString(),\n      error: error instanceof Error ? error.message : 'Unknown error',\n      version: '0.3.0'\n    };\n\n    return new Response(JSON.stringify(errorHealth, null, 2), {\n      status: 503,\n      headers: {\n        'Content-Type': 'application/json',\n        'Cache-Control': 'no-cache'\n      }\n    });\n  }\n}\n\n/**\n * Export the default handler for Cloudflare Workers\n */\nexport default {\n  fetch,\n  healthCheck\n};", "/**\n * Remote MCP Server\n * Main orchestrator for multi-client Remote MCP server functionality\n * Extends the core MCP server with WebSocket transport and authentication\n */\n\nimport type { CloudflareEnvironment, CloudflareRequestContext, ExecutionContext } from './types/cloudflare.types';\nimport type { ServerHealth, RemoteMCPContext } from './types/remote-mcp.types';\nimport type { MCPContext } from './types/mcp.types';\n\n// Core services\nimport { ConfigurationService } from './services/configuration.service';\nimport { YouTubeService } from './services/youtube.service';\n\n// Remote MCP services\nimport { AuthenticationService } from './services/authentication.service';\nimport { ConnectionManagementService } from './services/connection-management.service';\nimport { WebSocketTransportService } from './services/websocket-transport.service';\n\n// Utilities\nimport { LoggerUtil } from './utils/logger.util';\nimport { ErrorHandlerUtil } from './utils/error-handler.util';\nimport { ToolRegistryUtil } from './utils/tool-registry.util';\n\n/**\n * Remote MCP Server Class\n * Handles WebSocket connections, authentication, and tool execution\n */\nexport class RemoteMCPServer {\n  private configService: ConfigurationService;\n  private logger: LoggerUtil;\n  private errorHandler: ErrorHandlerUtil;\n  private toolRegistry: ToolRegistryUtil;\n  \n  // Core services\n  private youTubeService: YouTubeService;\n  \n  // Remote MCP services\n  private authService: AuthenticationService;\n  private connectionManager: ConnectionManagementService;\n  private wsTransport: WebSocketTransportService;\n\n  constructor(private env: CloudflareEnvironment) {\n    // Initialize core utilities\n    this.configService = new ConfigurationService(env);\n    this.logger = new LoggerUtil(this.configService.getConfiguration());\n    this.errorHandler = new ErrorHandlerUtil(this.logger);\n    this.toolRegistry = new ToolRegistryUtil(this.configService, this.logger);\n\n    // Initialize core services\n    this.youTubeService = new YouTubeService(this.configService, this.logger, env);\n\n    // Initialize remote MCP services\n    this.authService = new AuthenticationService(env, this.logger, this.errorHandler);\n    this.connectionManager = new ConnectionManagementService(env, this.logger, this.errorHandler);\n    this.wsTransport = new WebSocketTransportService(\n      env, \n      this.logger, \n      this.errorHandler, \n      this.authService, \n      this.connectionManager\n    );\n  }\n\n  /**\n   * Initialize the Remote MCP server\n   */\n  async initialize(): Promise<void> {\n    try {\n      this.logger.info('Initializing Remote MCP Server');\n\n      // Register placeholder tools (actual tools to be implemented)\n      await this.registerPlaceholderTools();\n\n      this.logger.info('Remote MCP Server initialized successfully', {\n        toolsRegistered: this.toolRegistry.listTools().length,\n        serverCapabilities: ['websocket', 'authentication', 'real-time', 'multi-user']\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to initialize Remote MCP Server', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Handle incoming HTTP requests\n   */\n  async handleRequest(context: CloudflareRequestContext): Promise<Response> {\n    const { request, env, ctx } = context;\n    const url = new URL(request.url);\n\n    try {\n      // Health check endpoint\n      if (url.pathname === '/health') {\n        return await this.handleHealthCheck();\n      }\n\n      // WebSocket upgrade for real-time connections\n      if (url.pathname === '/ws' && request.headers.get('Upgrade') === 'websocket') {\n        return await this.wsTransport.handleUpgrade(request);\n      }\n\n      // HTTP API endpoints for tools (fallback for non-WebSocket clients)\n      if (url.pathname.startsWith('/api/')) {\n        return await this.handleApiRequest(request);\n      }\n\n      // MCP protocol endpoint (standard MCP over HTTP)\n      if (url.pathname === '/mcp' && request.method === 'POST') {\n        return await this.handleMCPRequest(request);\n      }\n\n      // Default response\n      return new Response('Remote MCP Server - WebSocket endpoint available at /ws', {\n        status: 200,\n        headers: { 'Content-Type': 'text/plain' }\n      });\n\n    } catch (error) {\n      this.logger.error('Request handling failed', {\n        method: request.method,\n        url: request.url,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n\n      return this.errorHandler.createErrorResponse(\n        500, \n        'Internal server error', \n        'request-handling'\n      );\n    }\n  }\n\n  /**\n   * Handle health check requests\n   */\n  private async handleHealthCheck(): Promise<Response> {\n    try {\n      const health = await this.getServerHealth();\n      \n      const statusCode = health.status === 'healthy' ? 200 : \n                        health.status === 'degraded' ? 200 : 503;\n\n      return new Response(JSON.stringify(health), {\n        status: statusCode,\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n    } catch (error) {\n      return this.errorHandler.createErrorResponse(\n        503, \n        'Health check failed', \n        'health-check'\n      );\n    }\n  }\n\n  /**\n   * Handle HTTP API requests (REST-like interface)\n   */\n  private async handleApiRequest(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n    const pathParts = url.pathname.split('/').filter(Boolean);\n\n    // API routes: /api/tools, /api/tools/{toolName}\n    if (pathParts[1] === 'tools') {\n      if (request.method === 'GET' && pathParts.length === 2) {\n        // List all tools\n        const tools = this.toolRegistry.listTools();\n        return new Response(JSON.stringify({ tools }), {\n          headers: { 'Content-Type': 'application/json' }\n        });\n      }\n\n      if (request.method === 'POST' && pathParts.length === 3) {\n        // Execute specific tool\n        const toolName = pathParts[2];\n        const input = await request.json();\n        \n        // Create a mock context for HTTP API\n        const mockContext: MCPContext = {\n          environment: 'development',\n          requestId: crypto.randomUUID()\n        };\n\n        try {\n          const result = await this.toolRegistry.executeTool(toolName, input, mockContext);\n          return new Response(JSON.stringify(result), {\n            headers: { 'Content-Type': 'application/json' }\n          });\n        } catch (error) {\n          return this.errorHandler.createErrorResponse(\n            400, \n            error instanceof Error ? error.message : 'Tool execution failed', \n            'tool-execution'\n          );\n        }\n      }\n    }\n\n    return this.errorHandler.createErrorResponse(404, 'API endpoint not found', 'api-not-found');\n  }\n\n  /**\n   * Handle standard MCP protocol requests over HTTP\n   */\n  private async handleMCPRequest(request: Request): Promise<Response> {\n    try {\n      const mcpRequest = await request.json();\n      \n      // Handle standard MCP methods\n      switch (mcpRequest.method) {\n        case 'tools/list':\n          const tools = this.toolRegistry.listTools();\n          return new Response(JSON.stringify({\n            jsonrpc: '2.0',\n            id: mcpRequest.id,\n            result: { tools }\n          }), {\n            headers: { 'Content-Type': 'application/json' }\n          });\n\n        case 'tools/call':\n          const mockContext: MCPContext = {\n            environment: 'development',\n            requestId: crypto.randomUUID()\n          };\n\n          const result = await this.toolRegistry.executeTool(\n            mcpRequest.params.name, \n            mcpRequest.params.arguments, \n            mockContext\n          );\n\n          return new Response(JSON.stringify({\n            jsonrpc: '2.0',\n            id: mcpRequest.id,\n            result\n          }), {\n            headers: { 'Content-Type': 'application/json' }\n          });\n\n        default:\n          return this.errorHandler.createErrorResponse(\n            400, \n            `Unknown MCP method: ${mcpRequest.method}`, \n            'unknown-method'\n          );\n      }\n\n    } catch (error) {\n      this.logger.error('MCP request handling failed', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n\n      return this.errorHandler.createErrorResponse(\n        400, \n        'Invalid MCP request', \n        'invalid-mcp'\n      );\n    }\n  }\n\n  /**\n   * Initialize built-in tools from ToolRegistry\n   */\n  private async registerPlaceholderTools(): Promise<void> {\n    // The ToolRegistryUtil automatically registers all built-in tools during initialization\n    // including getVideoTranscript, getVideoAnalytics, analyzeChannelPerformance, etc.\n    await this.toolRegistry.initialize();\n\n    const registeredTools = this.toolRegistry.listTools();\n    \n    this.logger.info('Built-in tools registered successfully', {\n      toolCount: registeredTools.length,\n      toolNames: registeredTools.map(t => t.name)\n    });\n  }\n\n  /**\n   * Get comprehensive server health status\n   */\n  async getServerHealth(): Promise<ServerHealth> {\n    try {\n      // Get connection statistics\n      const connectionStats = this.connectionManager.getConnectionStats();\n      const authStats = this.authService.getAuthStats();\n      const wsStats = this.wsTransport.getConnectionStats();\n\n      // Test core services\n      const services = {\n        youtube: 'online' as const, // Would test YouTube API connectivity\n        cache: 'online' as const,   // Would test KV connectivity\n        database: 'online' as const // Would test persistent storage\n      };\n\n      // Calculate health status\n      let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n      \n      if (connectionStats.activeConnections < connectionStats.totalConnections * 0.7) {\n        status = 'degraded';\n      }\n\n      return {\n        status,\n        timestamp: new Date().toISOString(),\n        metrics: {\n          activeConnections: connectionStats.activeConnections,\n          totalRequests: 0, // Would track this in production\n          averageResponseTime: 0, // Would calculate from metrics\n          errorRate: 0, // Would calculate from error tracking\n          quotaUsage: authStats.totalQuotaUsed\n        },\n        services\n      };\n\n    } catch (error) {\n      this.logger.error('Health check failed', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n\n      return {\n        status: 'unhealthy',\n        timestamp: new Date().toISOString(),\n        metrics: {\n          activeConnections: 0,\n          totalRequests: 0,\n          averageResponseTime: 0,\n          errorRate: 100,\n          quotaUsage: 0\n        },\n        services: {\n          youtube: 'offline',\n          cache: 'offline',\n          database: 'offline'\n        }\n      };\n    }\n  }\n\n  /**\n   * Graceful shutdown\n   */\n  async shutdown(): Promise<void> {\n    this.logger.info('Shutting down Remote MCP Server');\n\n    try {\n      // Close all WebSocket connections\n      await this.wsTransport.closeAllConnections();\n      \n      // Cleanup services\n      await Promise.all([\n        this.connectionManager.cleanup(),\n        this.authService.cleanup()\n      ]);\n\n      this.logger.info('Remote MCP Server shutdown completed');\n\n    } catch (error) {\n      this.logger.error('Error during shutdown', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n}\n\n/**\n * Cloudflare Workers entry point for Remote MCP Server\n */\nlet remoteMCPServer: RemoteMCPServer | null = null;\n\nexport default {\n  async fetch(request: Request, env: CloudflareEnvironment, ctx: ExecutionContext): Promise<Response> {\n    try {\n      // Initialize server if not already done\n      if (!remoteMCPServer) {\n        remoteMCPServer = new RemoteMCPServer(env);\n        await remoteMCPServer.initialize();\n      }\n\n      // Handle the request\n      return await remoteMCPServer.handleRequest({ request, env, ctx });\n\n    } catch (error) {\n      console.error('Remote MCP Server error:', error);\n      \n      return new Response(JSON.stringify({\n        error: 'Internal server error',\n        message: error instanceof Error ? error.message : 'Unknown error'\n      }), {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n  }\n};", "/**\n * Authentication Service for Remote MCP\n * Handles API key validation, user sessions, and quota management\n */\n\nimport type { CloudflareEnvironment } from '../types/cloudflare.types';\nimport type { UserSession, UserPermissions, QuotaInfo } from '../types/remote-mcp.types';\nimport type { LoggerUtil } from '../utils/logger.util';\nimport type { ErrorHandlerUtil } from '../utils/error-handler.util';\n\nexport class AuthenticationService {\n  private sessionCache: Map<string, UserSession> = new Map();\n  private apiKeyCache: Map<string, UserSession> = new Map();\n  private cacheTimeout: number = 300000; // 5 minutes\n\n  constructor(\n    private env: CloudflareEnvironment,\n    private logger: LoggerUtil,\n    private errorHandler: ErrorHandlerUtil\n  ) {}\n\n  /**\n   * Validate API key and return user session\n   */\n  async validateApiKey(apiKey: string): Promise<UserSession | null> {\n    try {\n      // Check cache first\n      const cachedSession = this.apiKeyCache.get(apiKey);\n      if (cachedSession && this.isSessionValid(cachedSession)) {\n        return cachedSession;\n      }\n\n      // Validate API key format\n      if (!this.isValidApiKeyFormat(apiKey)) {\n        this.logger.warn('Invalid API key format', { apiKey: apiKey.substring(0, 8) + '...' });\n        return null;\n      }\n\n      // Check KV storage for API key\n      const sessionData = await this.env.YOUTUBE_MCP_KV.get(`apikey:${apiKey}`, 'json') as UserSession | null;\n      \n      if (!sessionData) {\n        this.logger.warn('API key not found', { apiKey: apiKey.substring(0, 8) + '...' });\n        return null;\n      }\n\n      // Create/update session\n      const session: UserSession = {\n        ...sessionData,\n        lastActivity: new Date().toISOString(),\n      };\n\n      // Update session in KV\n      await this.updateUserSession(session);\n\n      // Cache the session\n      this.sessionCache.set(session.id, session);\n      this.apiKeyCache.set(apiKey, session);\n\n      this.logger.info('API key validated successfully', {\n        userId: session.id,\n        quotaUsed: session.quotaUsed,\n        quotaLimit: session.quotaLimit\n      });\n\n      return session;\n\n    } catch (error) {\n      this.logger.error('API key validation failed', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        apiKey: apiKey.substring(0, 8) + '...'\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Create a new user session with API key\n   */\n  async createUserSession(\n    apiKey: string, \n    permissions: UserPermissions = this.getDefaultPermissions()\n  ): Promise<UserSession> {\n    try {\n      const userId = crypto.randomUUID();\n      const now = new Date().toISOString();\n\n      const session: UserSession = {\n        id: userId,\n        apiKey,\n        quotaUsed: 0,\n        quotaLimit: 10000 * permissions.quotaMultiplier, // Base 10k per day\n        createdAt: now,\n        lastActivity: now,\n        permissions,\n      };\n\n      // Store in KV\n      await Promise.all([\n        this.env.YOUTUBE_MCP_KV.put(`session:${userId}`, JSON.stringify(session)),\n        this.env.YOUTUBE_MCP_KV.put(`apikey:${apiKey}`, JSON.stringify(session)),\n        this.env.YOUTUBE_MCP_KV.put(`quota:${userId}`, JSON.stringify({\n          used: 0,\n          limit: session.quotaLimit,\n          resetAt: this.getNextQuotaReset(),\n          lastUpdated: now\n        }))\n      ]);\n\n      // Cache the session\n      this.sessionCache.set(userId, session);\n      this.apiKeyCache.set(apiKey, session);\n\n      this.logger.info('User session created', {\n        userId,\n        quotaLimit: session.quotaLimit,\n        permissions: permissions\n      });\n\n      return session;\n\n    } catch (error) {\n      this.logger.error('Failed to create user session', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user quota usage information\n   */\n  async getUserQuotaUsage(userId: string): Promise<QuotaInfo> {\n    try {\n      // Check cache first\n      const session = this.sessionCache.get(userId);\n      if (session) {\n        return {\n          used: session.quotaUsed,\n          limit: session.quotaLimit,\n          resetAt: this.getNextQuotaReset(),\n          warningThreshold: 80\n        };\n      }\n\n      // Get from KV storage\n      const quotaData = await this.env.YOUTUBE_MCP_KV.get(`quota:${userId}`, 'json') as QuotaInfo | null;\n      \n      if (!quotaData) {\n        // Return default quota if not found\n        return {\n          used: 0,\n          limit: 10000,\n          resetAt: this.getNextQuotaReset(),\n          warningThreshold: 80\n        };\n      }\n\n      return quotaData;\n\n    } catch (error) {\n      this.logger.error('Failed to get user quota', {\n        userId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      // Return safe defaults on error\n      return {\n        used: 0,\n        limit: 10000,\n        resetAt: this.getNextQuotaReset(),\n        warningThreshold: 80\n      };\n    }\n  }\n\n  /**\n   * Update user quota usage\n   */\n  async updateQuotaUsage(userId: string, quotaUsed: number): Promise<QuotaInfo> {\n    try {\n      const currentQuota = await this.getUserQuotaUsage(userId);\n      const newUsage = currentQuota.used + quotaUsed;\n\n      const updatedQuota: QuotaInfo = {\n        ...currentQuota,\n        used: newUsage,\n        lastUpdated: new Date().toISOString()\n      };\n\n      // Update in KV storage\n      await this.env.YOUTUBE_MCP_KV.put(`quota:${userId}`, JSON.stringify(updatedQuota));\n\n      // Update cached session if exists\n      const session = this.sessionCache.get(userId);\n      if (session) {\n        session.quotaUsed = newUsage;\n        session.lastActivity = new Date().toISOString();\n      }\n\n      // Check if quota warning threshold is exceeded\n      const usagePercentage = (newUsage / updatedQuota.limit) * 100;\n      if (usagePercentage >= updatedQuota.warningThreshold) {\n        this.logger.warn('Quota usage warning', {\n          userId,\n          used: newUsage,\n          limit: updatedQuota.limit,\n          percentage: Math.round(usagePercentage)\n        });\n      }\n\n      return updatedQuota;\n\n    } catch (error) {\n      this.logger.error('Failed to update quota usage', {\n        userId,\n        quotaUsed,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Check if user has quota available\n   */\n  async hasQuotaAvailable(userId: string, requiredQuota: number = 1): Promise<boolean> {\n    try {\n      const quotaInfo = await this.getUserQuotaUsage(userId);\n      return (quotaInfo.used + requiredQuota) <= quotaInfo.limit;\n    } catch (error) {\n      this.logger.error('Failed to check quota availability', {\n        userId,\n        requiredQuota,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return false; // Fail safely\n    }\n  }\n\n  /**\n   * Reset user quota (daily reset)\n   */\n  async resetUserQuota(userId: string): Promise<void> {\n    try {\n      const session = await this.getUserSession(userId);\n      if (!session) {\n        throw new Error('User session not found');\n      }\n\n      const resetQuota: QuotaInfo = {\n        used: 0,\n        limit: session.quotaLimit,\n        resetAt: this.getNextQuotaReset(),\n        lastUpdated: new Date().toISOString(),\n        warningThreshold: 80\n      };\n\n      // Update in KV storage\n      await this.env.YOUTUBE_MCP_KV.put(`quota:${userId}`, JSON.stringify(resetQuota));\n\n      // Update cached session\n      if (this.sessionCache.has(userId)) {\n        const cachedSession = this.sessionCache.get(userId)!;\n        cachedSession.quotaUsed = 0;\n        cachedSession.lastActivity = new Date().toISOString();\n      }\n\n      this.logger.info('User quota reset', {\n        userId,\n        newLimit: resetQuota.limit,\n        nextReset: resetQuota.resetAt\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to reset user quota', {\n        userId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get user session by ID\n   */\n  async getUserSession(userId: string): Promise<UserSession | null> {\n    try {\n      // Check cache first\n      const cachedSession = this.sessionCache.get(userId);\n      if (cachedSession && this.isSessionValid(cachedSession)) {\n        return cachedSession;\n      }\n\n      // Get from KV storage\n      const sessionData = await this.env.YOUTUBE_MCP_KV.get(`session:${userId}`, 'json') as UserSession | null;\n      \n      if (sessionData) {\n        // Cache the session\n        this.sessionCache.set(userId, sessionData);\n        return sessionData;\n      }\n\n      return null;\n\n    } catch (error) {\n      this.logger.error('Failed to get user session', {\n        userId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Update user session\n   */\n  async updateUserSession(session: UserSession): Promise<void> {\n    try {\n      session.lastActivity = new Date().toISOString();\n\n      // Update in KV storage\n      await Promise.all([\n        this.env.YOUTUBE_MCP_KV.put(`session:${session.id}`, JSON.stringify(session)),\n        this.env.YOUTUBE_MCP_KV.put(`apikey:${session.apiKey}`, JSON.stringify(session))\n      ]);\n\n      // Update cache\n      this.sessionCache.set(session.id, session);\n      this.apiKeyCache.set(session.apiKey, session);\n\n    } catch (error) {\n      this.logger.error('Failed to update user session', {\n        userId: session.id,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Invalidate user session\n   */\n  async invalidateSession(userId: string): Promise<void> {\n    try {\n      const session = await this.getUserSession(userId);\n      if (!session) {\n        return;\n      }\n\n      // Remove from KV storage\n      await Promise.all([\n        this.env.YOUTUBE_MCP_KV.delete(`session:${userId}`),\n        this.env.YOUTUBE_MCP_KV.delete(`apikey:${session.apiKey}`),\n        this.env.YOUTUBE_MCP_KV.delete(`quota:${userId}`)\n      ]);\n\n      // Remove from cache\n      this.sessionCache.delete(userId);\n      this.apiKeyCache.delete(session.apiKey);\n\n      this.logger.info('User session invalidated', { userId });\n\n    } catch (error) {\n      this.logger.error('Failed to invalidate session', {\n        userId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Check if API key format is valid\n   */\n  private isValidApiKeyFormat(apiKey: string): boolean {\n    // API key should be at least 32 characters and contain only alphanumeric characters\n    return /^[a-zA-Z0-9_-]{32,}$/.test(apiKey);\n  }\n\n  /**\n   * Check if session is still valid\n   */\n  private isSessionValid(session: UserSession): boolean {\n    const lastActivity = new Date(session.lastActivity);\n    const now = new Date();\n    const timeDiff = now.getTime() - lastActivity.getTime();\n    \n    // Session is valid if last activity was within cache timeout\n    return timeDiff < this.cacheTimeout;\n  }\n\n  /**\n   * Get default user permissions\n   */\n  private getDefaultPermissions(): UserPermissions {\n    return {\n      canUseTools: [\n        'getVideoTranscript',\n        'getVideoAnalytics',\n        'getChannelAnalytics',\n        'getVideoComments',\n        'searchVideos',\n        'getTrendingVideos',\n        'getCompetitorAnalysis'\n      ],\n      canAccessSharedCache: true,\n      canReceiveNotifications: true,\n      quotaMultiplier: 1.0\n    };\n  }\n\n  /**\n   * Get next quota reset time (daily at midnight UTC)\n   */\n  private getNextQuotaReset(): string {\n    const tomorrow = new Date();\n    tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);\n    tomorrow.setUTCHours(0, 0, 0, 0);\n    return tomorrow.toISOString();\n  }\n\n  /**\n   * Clean up expired cache entries\n   */\n  private cleanupExpiredCache(): void {\n    const now = new Date();\n    \n    for (const [userId, session] of this.sessionCache.entries()) {\n      if (!this.isSessionValid(session)) {\n        this.sessionCache.delete(userId);\n        this.apiKeyCache.delete(session.apiKey);\n      }\n    }\n  }\n\n  /**\n   * Get authentication statistics\n   */\n  getAuthStats(): {\n    activeSessions: number;\n    cachedSessions: number;\n    totalQuotaUsed: number;\n    averageQuotaUsage: number;\n  } {\n    this.cleanupExpiredCache();\n    \n    const sessions = Array.from(this.sessionCache.values());\n    const totalQuotaUsed = sessions.reduce((sum, session) => sum + session.quotaUsed, 0);\n    const averageQuotaUsage = sessions.length > 0 ? totalQuotaUsed / sessions.length : 0;\n\n    return {\n      activeSessions: sessions.filter(s => this.isSessionValid(s)).length,\n      cachedSessions: sessions.length,\n      totalQuotaUsed,\n      averageQuotaUsage: Math.round(averageQuotaUsage)\n    };\n  }\n\n  /**\n   * Cleanup method for graceful shutdown\n   */\n  async cleanup(): Promise<void> {\n    // Clear all caches\n    this.sessionCache.clear();\n    this.apiKeyCache.clear();\n    \n    this.logger.info('Authentication service cleaned up');\n  }\n}", "/**\n * Connection Management Service for Remote MCP\n * Handles WebSocket connection lifecycle, monitoring, and cleanup\n */\n\nimport type { CloudflareEnvironment } from '../types/cloudflare.types';\nimport type { ClientConnection, ConnectionMetadata } from '../types/remote-mcp.types';\nimport type { LoggerUtil } from '../utils/logger.util';\nimport type { ErrorHandlerUtil } from '../utils/error-handler.util';\n\nexport class ConnectionManagementService {\n  private connections: Map<string, ClientConnection> = new Map();\n  private connectionMetrics: Map<string, ConnectionStats> = new Map();\n  private cleanupInterval: number | null = null;\n\n  constructor(\n    private env: CloudflareEnvironment,\n    private logger: LoggerUtil,\n    private errorHandler: ErrorHandlerUtil\n  ) {\n    // Start cleanup interval for stale connections\n    this.startCleanupInterval();\n  }\n\n  /**\n   * Register a new client connection\n   */\n  async registerConnection(sessionId: string, connection: ClientConnection): Promise<void> {\n    try {\n      // Store connection\n      this.connections.set(sessionId, connection);\n\n      // Initialize connection metrics\n      this.connectionMetrics.set(sessionId, {\n        sessionId,\n        connectedAt: connection.connectedAt,\n        lastActivity: connection.lastPing,\n        messagesSent: 0,\n        messagesReceived: 0,\n        bytesTransferred: 0,\n        errors: 0\n      });\n\n      // Store in KV for persistence (optional, for analytics)\n      await this.env.YOUTUBE_MCP_KV.put(\n        `connection:${sessionId}`,\n        JSON.stringify({\n          sessionId,\n          connectedAt: connection.connectedAt.toISOString(),\n          metadata: connection.metadata\n        }),\n        { expirationTtl: 86400 } // 24 hours\n      );\n\n      this.logger.info('Connection registered', {\n        sessionId,\n        totalConnections: this.connections.size,\n        metadata: connection.metadata\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to register connection', {\n        sessionId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Unregister a client connection\n   */\n  async unregisterConnection(sessionId: string): Promise<void> {\n    try {\n      const connection = this.connections.get(sessionId);\n      if (!connection) {\n        return; // Already unregistered\n      }\n\n      // Calculate session duration\n      const duration = Date.now() - connection.connectedAt.getTime();\n\n      // Get final metrics\n      const metrics = this.connectionMetrics.get(sessionId);\n\n      // Remove from memory\n      this.connections.delete(sessionId);\n      this.connectionMetrics.delete(sessionId);\n\n      // Clean up from KV\n      await this.env.YOUTUBE_MCP_KV.delete(`connection:${sessionId}`);\n\n      this.logger.info('Connection unregistered', {\n        sessionId,\n        duration,\n        totalConnections: this.connections.size,\n        finalMetrics: metrics\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to unregister connection', {\n        sessionId,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n    }\n  }\n\n  /**\n   * Get connection by session ID\n   */\n  getConnection(sessionId: string): ClientConnection | null {\n    return this.connections.get(sessionId) || null;\n  }\n\n  /**\n   * Get all active connections\n   */\n  getAllConnections(): ClientConnection[] {\n    return Array.from(this.connections.values());\n  }\n\n  /**\n   * Update connection activity\n   */\n  updateConnectionActivity(sessionId: string): void {\n    const connection = this.connections.get(sessionId);\n    const metrics = this.connectionMetrics.get(sessionId);\n\n    if (connection) {\n      connection.lastPing = new Date();\n    }\n\n    if (metrics) {\n      metrics.lastActivity = new Date();\n    }\n  }\n\n  /**\n   * Track message sent from connection\n   */\n  trackMessageSent(sessionId: string, messageSize: number = 0): void {\n    const metrics = this.connectionMetrics.get(sessionId);\n    if (metrics) {\n      metrics.messagesSent++;\n      metrics.bytesTransferred += messageSize;\n      metrics.lastActivity = new Date();\n    }\n  }\n\n  /**\n   * Track message received by connection\n   */\n  trackMessageReceived(sessionId: string, messageSize: number = 0): void {\n    const metrics = this.connectionMetrics.get(sessionId);\n    if (metrics) {\n      metrics.messagesReceived++;\n      metrics.bytesTransferred += messageSize;\n      metrics.lastActivity = new Date();\n    }\n  }\n\n  /**\n   * Track connection error\n   */\n  trackConnectionError(sessionId: string, error: Error): void {\n    const metrics = this.connectionMetrics.get(sessionId);\n    if (metrics) {\n      metrics.errors++;\n    }\n\n    this.logger.warn('Connection error tracked', {\n      sessionId,\n      error: error.message,\n      totalErrors: metrics?.errors || 0\n    });\n  }\n\n  /**\n   * Get connection statistics\n   */\n  getConnectionStats(): {\n    totalConnections: number;\n    activeConnections: number;\n    averageConnectionTime: number;\n    totalMessages: number;\n    totalBytes: number;\n    errorRate: number;\n  } {\n    const now = new Date();\n    const metrics = Array.from(this.connectionMetrics.values());\n    \n    const activeConnections = metrics.filter(m => \n      now.getTime() - m.lastActivity.getTime() < 300000 // 5 minutes\n    ).length;\n\n    const totalMessages = metrics.reduce((sum, m) => sum + m.messagesSent + m.messagesReceived, 0);\n    const totalBytes = metrics.reduce((sum, m) => sum + m.bytesTransferred, 0);\n    const totalErrors = metrics.reduce((sum, m) => sum + m.errors, 0);\n    \n    const connectionTimes = metrics.map(m => now.getTime() - m.connectedAt.getTime());\n    const averageConnectionTime = connectionTimes.length > 0 \n      ? connectionTimes.reduce((sum, time) => sum + time, 0) / connectionTimes.length\n      : 0;\n\n    const errorRate = totalMessages > 0 ? (totalErrors / totalMessages) * 100 : 0;\n\n    return {\n      totalConnections: this.connections.size,\n      activeConnections,\n      averageConnectionTime: Math.round(averageConnectionTime),\n      totalMessages,\n      totalBytes,\n      errorRate: Math.round(errorRate * 100) / 100\n    };\n  }\n\n  /**\n   * Get connections by criteria\n   */\n  getConnectionsByCriteria(criteria: {\n    platform?: string;\n    userAgent?: string;\n    minConnectedTime?: number;\n    maxIdleTime?: number;\n  }): ClientConnection[] {\n    const now = new Date();\n    \n    return this.getAllConnections().filter(connection => {\n      // Platform filter\n      if (criteria.platform && connection.metadata.platform !== criteria.platform) {\n        return false;\n      }\n\n      // User agent filter\n      if (criteria.userAgent && !connection.metadata.userAgent?.includes(criteria.userAgent)) {\n        return false;\n      }\n\n      // Minimum connected time\n      if (criteria.minConnectedTime) {\n        const connectedTime = now.getTime() - connection.connectedAt.getTime();\n        if (connectedTime < criteria.minConnectedTime) {\n          return false;\n        }\n      }\n\n      // Maximum idle time\n      if (criteria.maxIdleTime) {\n        const idleTime = now.getTime() - connection.lastPing.getTime();\n        if (idleTime > criteria.maxIdleTime) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Close connections matching criteria\n   */\n  async closeConnections(criteria: {\n    sessionIds?: string[];\n    platform?: string;\n    maxIdleTime?: number;\n    reason?: string;\n  }): Promise<number> {\n    let closedCount = 0;\n    const reason = criteria.reason || 'Server initiated close';\n\n    try {\n      let connectionsToClose: ClientConnection[] = [];\n\n      if (criteria.sessionIds) {\n        // Close specific connections\n        connectionsToClose = criteria.sessionIds\n          .map(id => this.connections.get(id))\n          .filter(Boolean) as ClientConnection[];\n      } else {\n        // Close by criteria\n        connectionsToClose = this.getConnectionsByCriteria(criteria);\n      }\n\n      for (const connection of connectionsToClose) {\n        try {\n          connection.websocket.close(1000, reason);\n          await this.unregisterConnection(connection.sessionId);\n          closedCount++;\n        } catch (error) {\n          this.logger.warn('Failed to close connection', {\n            sessionId: connection.sessionId,\n            error: error instanceof Error ? error.message : 'Unknown error'\n          });\n        }\n      }\n\n      this.logger.info('Bulk connection close completed', {\n        closedCount,\n        totalConnections: this.connections.size,\n        criteria\n      });\n\n    } catch (error) {\n      this.logger.error('Failed to close connections', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        criteria\n      });\n    }\n\n    return closedCount;\n  }\n\n  /**\n   * Start periodic cleanup of stale connections\n   */\n  private startCleanupInterval(): void {\n    // Run cleanup every 5 minutes\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupStaleConnections();\n    }, 300000) as any;\n  }\n\n  /**\n   * Clean up stale connections\n   */\n  private async cleanupStaleConnections(): Promise<void> {\n    const maxIdleTime = 600000; // 10 minutes\n    const staleConnections = this.getConnectionsByCriteria({ maxIdleTime });\n\n    if (staleConnections.length > 0) {\n      this.logger.info('Cleaning up stale connections', {\n        staleCount: staleConnections.length,\n        maxIdleTime\n      });\n\n      await this.closeConnections({\n        sessionIds: staleConnections.map(c => c.sessionId),\n        reason: 'Connection idle timeout'\n      });\n    }\n  }\n\n  /**\n   * Stop cleanup interval\n   */\n  private stopCleanupInterval(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n  }\n\n  /**\n   * Cleanup method for graceful shutdown\n   */\n  async cleanup(): Promise<void> {\n    this.logger.info('Connection management cleanup started');\n\n    // Stop cleanup interval\n    this.stopCleanupInterval();\n\n    // Close all connections\n    await this.closeConnections({\n      sessionIds: Array.from(this.connections.keys()),\n      reason: 'Server shutting down'\n    });\n\n    // Clear all data\n    this.connections.clear();\n    this.connectionMetrics.clear();\n\n    this.logger.info('Connection management cleanup completed');\n  }\n}\n\n/**\n * Connection statistics interface\n */\ninterface ConnectionStats {\n  sessionId: string;\n  connectedAt: Date;\n  lastActivity: Date;\n  messagesSent: number;\n  messagesReceived: number;\n  bytesTransferred: number;\n  errors: number;\n}", "/**\n * WebSocket Transport Service for Remote MCP\n * Handles WebSocket connections, message routing, and real-time communication\n */\n\nimport type { CloudflareEnvironment, CloudflareWebSocket, WebSocketPair } from '../types/cloudflare.types';\nimport type { \n  WebSocketMessage, \n  ClientConnection, \n  UserSession, \n  MCPEvent,\n  AuthRequest,\n  AuthResponse,\n  RemoteMCPTool\n} from '../types/remote-mcp.types';\nimport type { LoggerUtil } from '../utils/logger.util';\nimport type { ErrorHandlerUtil } from '../utils/error-handler.util';\n\n// Forward declare service types to avoid circular dependencies\ninterface AuthenticationService {\n  validateApiKey(apiKey: string): Promise<UserSession | null>;\n  getUserQuotaUsage(userId: string): Promise<{ used: number; limit: number; resetAt: string; warningThreshold: number; }>;\n}\n\ninterface ConnectionManagementService {\n  registerConnection(sessionId: string, connection: ClientConnection): Promise<void>;\n  unregisterConnection(sessionId: string): Promise<void>;\n}\n\nexport class WebSocketTransportService {\n  private connections: Map<string, ClientConnection> = new Map();\n  private messageHandlers: Map<string, (message: WebSocketMessage, connection: ClientConnection) => Promise<void>> = new Map();\n\n  constructor(\n    private env: CloudflareEnvironment,\n    private logger: LoggerUtil,\n    private errorHandler: ErrorHandlerUtil,\n    private authService: AuthenticationService,\n    private connectionManager: ConnectionManagementService\n  ) {\n    this.setupMessageHandlers();\n  }\n\n  /**\n   * Handle WebSocket upgrade request\n   */\n  async handleUpgrade(request: Request): Promise<Response> {\n    try {\n      // Validate WebSocket upgrade headers\n      const upgradeHeader = request.headers.get('Upgrade');\n      if (upgradeHeader !== 'websocket') {\n        return new Response('Expected WebSocket upgrade', { status: 426 });\n      }\n\n      // Create WebSocket pair\n      const webSocketPair = new WebSocketPair();\n      const [client, server] = Object.values(webSocketPair);\n\n      // Accept the WebSocket connection\n      await this.acceptWebSocket(server, request);\n\n      // Return the client WebSocket to the browser\n      return new Response(null, {\n        status: 101,\n        webSocket: client\n      } as any); // Type assertion for Cloudflare Workers\n\n    } catch (error) {\n      this.logger.error('WebSocket upgrade failed', { \n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      return this.errorHandler.createErrorResponse(500, 'WebSocket upgrade failed', 'ws-upgrade');\n    }\n  }\n\n  /**\n   * Accept and configure WebSocket connection\n   */\n  private async acceptWebSocket(websocket: CloudflareWebSocket, request: Request): Promise<void> {\n    // Extract connection metadata\n    const metadata = {\n      userAgent: request.headers.get('User-Agent') || undefined,\n      ipAddress: request.headers.get('CF-Connecting-IP') || undefined,\n      clientVersion: request.headers.get('X-Client-Version') || undefined,\n      platform: request.headers.get('X-Client-Platform') || undefined,\n    };\n\n    // Create temporary connection (auth required)\n    const tempConnection: Partial<ClientConnection> = {\n      websocket,\n      connectedAt: new Date(),\n      lastPing: new Date(),\n      subscriptions: new Set(),\n      metadata,\n    };\n\n    // Set up event listeners\n    websocket.addEventListener('message', async (event: MessageEvent) => {\n      await this.handleMessage(event, tempConnection as ClientConnection);\n    });\n\n    websocket.addEventListener('close', async (event: CloseEvent) => {\n      await this.handleDisconnection(tempConnection as ClientConnection, event.code, event.reason);\n    });\n\n    websocket.addEventListener('error', async (event: Event) => {\n      this.logger.error('WebSocket error', { \n        sessionId: tempConnection.sessionId, \n        error: 'WebSocket connection error'\n      });\n    });\n\n    // Send initial handshake\n    await this.sendHandshake(websocket);\n\n    this.logger.info('WebSocket connection accepted', { metadata });\n  }\n\n  /**\n   * Send initial handshake message\n   */\n  private async sendHandshake(websocket: CloudflareWebSocket): Promise<void> {\n    const handshake: WebSocketMessage = {\n      id: crypto.randomUUID(),\n      type: 'notification',\n      method: 'handshake',\n      params: {\n        serverVersion: '1.0.0',\n        protocolVersion: '2024-11-05',\n        capabilities: ['tools', 'resources', 'notifications', 'streaming'],\n        authRequired: true,\n      },\n      timestamp: new Date().toISOString(),\n    };\n\n    websocket.send(JSON.stringify(handshake));\n  }\n\n  /**\n   * Handle incoming WebSocket messages\n   */\n  private async handleMessage(event: MessageEvent, connection: ClientConnection): Promise<void> {\n    try {\n      const data = JSON.parse(event.data as string) as WebSocketMessage;\n      \n      // Update last activity\n      connection.lastPing = new Date();\n\n      // Route message to appropriate handler\n      const handler = this.messageHandlers.get(data.method || data.type);\n      if (handler) {\n        await handler(data, connection);\n      } else {\n        await this.handleUnknownMessage(data, connection);\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to handle WebSocket message', {\n        sessionId: connection.sessionId,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n\n      await this.sendError(connection.websocket, 'invalid_message', 'Failed to parse message', '');\n    }\n  }\n\n  /**\n   * Setup message handlers for different message types\n   */\n  private setupMessageHandlers(): void {\n    this.messageHandlers.set('authenticate', this.handleAuthentication.bind(this));\n    this.messageHandlers.set('ping', this.handlePing.bind(this));\n    this.messageHandlers.set('pong', this.handlePong.bind(this));\n    this.messageHandlers.set('tools/list', this.handleToolsList.bind(this));\n    this.messageHandlers.set('tools/call', this.handleToolCall.bind(this));\n    this.messageHandlers.set('subscribe', this.handleSubscribe.bind(this));\n    this.messageHandlers.set('unsubscribe', this.handleUnsubscribe.bind(this));\n  }\n\n  /**\n   * Handle authentication request\n   */\n  private async handleAuthentication(message: WebSocketMessage, connection: ClientConnection): Promise<void> {\n    try {\n      const authRequest = message.params as AuthRequest;\n      \n      // Validate API key\n      const session = await this.authService.validateApiKey(authRequest.apiKey);\n      if (!session) {\n        await this.sendAuthResponse(connection.websocket, {\n          success: false,\n          error: 'Invalid API key',\n          serverInfo: {\n            version: '1.0.0',\n            capabilities: [],\n            quotaLimits: { used: 0, limit: 0, resetAt: '', warningThreshold: 80 }\n          }\n        }, message.id);\n        return;\n      }\n\n      // Update connection with session info\n      connection.sessionId = session.id;\n      \n      // Register authenticated connection\n      await this.connectionManager.registerConnection(session.id, connection);\n      this.connections.set(session.id, connection);\n\n      // Send successful auth response\n      const quotaInfo = await this.authService.getUserQuotaUsage(session.id);\n      await this.sendAuthResponse(connection.websocket, {\n        success: true,\n        session,\n        serverInfo: {\n          version: '1.0.0',\n          capabilities: ['tools', 'resources', 'notifications', 'streaming'],\n          quotaLimits: quotaInfo\n        }\n      }, message.id);\n\n      this.logger.info('Client authenticated successfully', {\n        sessionId: session.id,\n        clientInfo: authRequest.clientInfo\n      });\n\n    } catch (error) {\n      this.logger.error('Authentication failed', { \n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      await this.sendError(connection.websocket, 'auth_failed', 'Authentication failed', message.id);\n    }\n  }\n\n  /**\n   * Handle ping messages for keepalive\n   */\n  private async handlePing(message: WebSocketMessage, connection: ClientConnection): Promise<void> {\n    const pong: WebSocketMessage = {\n      id: crypto.randomUUID(),\n      type: 'pong',\n      timestamp: new Date().toISOString(),\n    };\n\n    connection.websocket.send(JSON.stringify(pong));\n  }\n\n  /**\n   * Handle pong responses\n   */\n  private async handlePong(message: WebSocketMessage, connection: ClientConnection): Promise<void> {\n    // Update last ping time for connection health tracking\n    connection.lastPing = new Date();\n  }\n\n  /**\n   * Handle tools list request\n   */\n  private async handleToolsList(message: WebSocketMessage, connection: ClientConnection): Promise<void> {\n    try {\n      if (!connection.sessionId) {\n        await this.sendError(connection.websocket, 'not_authenticated', 'Authentication required', message.id);\n        return;\n      }\n\n      // Get tools from registry (would be injected)\n      const tools: RemoteMCPTool[] = []; // TODO: Get from tool registry\n      \n      const response: WebSocketMessage = {\n        id: message.id,\n        type: 'response',\n        result: { tools },\n        timestamp: new Date().toISOString(),\n      };\n\n      connection.websocket.send(JSON.stringify(response));\n\n    } catch (error) {\n      await this.sendError(\n        connection.websocket, \n        'tools_list_failed', \n        error instanceof Error ? error.message : 'Unknown error', \n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handle tool execution request\n   */\n  private async handleToolCall(message: WebSocketMessage, connection: ClientConnection): Promise<void> {\n    try {\n      if (!connection.sessionId) {\n        await this.sendError(connection.websocket, 'not_authenticated', 'Authentication required', message.id);\n        return;\n      }\n\n      // TODO: Execute tool via tool registry\n      const result = { message: 'Tool execution not yet implemented' };\n      \n      const response: WebSocketMessage = {\n        id: message.id,\n        type: 'response',\n        result,\n        timestamp: new Date().toISOString(),\n      };\n\n      connection.websocket.send(JSON.stringify(response));\n\n    } catch (error) {\n      await this.sendError(\n        connection.websocket, \n        'tool_call_failed', \n        error instanceof Error ? error.message : 'Unknown error', \n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handle subscription to notifications\n   */\n  private async handleSubscribe(message: WebSocketMessage, connection: ClientConnection): Promise<void> {\n    try {\n      const { toolName } = message.params as { toolName: string };\n      \n      if (!connection.sessionId) {\n        await this.sendError(connection.websocket, 'not_authenticated', 'Authentication required', message.id);\n        return;\n      }\n\n      connection.subscriptions.add(toolName);\n      \n      const response: WebSocketMessage = {\n        id: message.id,\n        type: 'response',\n        result: { subscribed: toolName },\n        timestamp: new Date().toISOString(),\n      };\n\n      connection.websocket.send(JSON.stringify(response));\n\n      this.logger.info('Client subscribed to notifications', {\n        sessionId: connection.sessionId,\n        toolName\n      });\n\n    } catch (error) {\n      await this.sendError(\n        connection.websocket, \n        'subscribe_failed', \n        error instanceof Error ? error.message : 'Unknown error', \n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handle unsubscription from notifications\n   */\n  private async handleUnsubscribe(message: WebSocketMessage, connection: ClientConnection): Promise<void> {\n    try {\n      const { toolName } = message.params as { toolName: string };\n      \n      if (!connection.sessionId) {\n        await this.sendError(connection.websocket, 'not_authenticated', 'Authentication required', message.id);\n        return;\n      }\n\n      connection.subscriptions.delete(toolName);\n      \n      const response: WebSocketMessage = {\n        id: message.id,\n        type: 'response',\n        result: { unsubscribed: toolName },\n        timestamp: new Date().toISOString(),\n      };\n\n      connection.websocket.send(JSON.stringify(response));\n\n    } catch (error) {\n      await this.sendError(\n        connection.websocket, \n        'unsubscribe_failed', \n        error instanceof Error ? error.message : 'Unknown error', \n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handle unknown message types\n   */\n  private async handleUnknownMessage(message: WebSocketMessage, connection: ClientConnection): Promise<void> {\n    await this.sendError(\n      connection.websocket, \n      'unknown_method', \n      `Unknown method: ${message.method}`, \n      message.id\n    );\n  }\n\n  /**\n   * Handle client disconnection\n   */\n  private async handleDisconnection(connection: ClientConnection, code: number, reason: string): Promise<void> {\n    if (connection.sessionId) {\n      this.connections.delete(connection.sessionId);\n      await this.connectionManager.unregisterConnection(connection.sessionId);\n      \n      this.logger.info('Client disconnected', {\n        sessionId: connection.sessionId,\n        code,\n        reason,\n        duration: Date.now() - connection.connectedAt.getTime()\n      });\n    }\n  }\n\n  /**\n   * Send authentication response\n   */\n  private async sendAuthResponse(websocket: CloudflareWebSocket, response: AuthResponse, messageId: string): Promise<void> {\n    const message: WebSocketMessage = {\n      id: messageId,\n      type: 'response',\n      result: response,\n      timestamp: new Date().toISOString(),\n    };\n\n    websocket.send(JSON.stringify(message));\n  }\n\n  /**\n   * Send error message\n   */\n  private async sendError(websocket: CloudflareWebSocket, code: string, message: string, messageId: string): Promise<void> {\n    const errorMessage: WebSocketMessage = {\n      id: messageId,\n      type: 'response',\n      error: {\n        code,\n        message,\n      },\n      timestamp: new Date().toISOString(),\n    };\n\n    websocket.send(JSON.stringify(errorMessage));\n  }\n\n  /**\n   * Broadcast event to subscribed clients\n   */\n  async broadcastEvent(event: MCPEvent): Promise<void> {\n    const targetConnections = event.data.targetUsers \n      ? event.data.targetUsers.map(userId => this.connections.get(userId)).filter(Boolean)\n      : Array.from(this.connections.values());\n\n    const message: WebSocketMessage = {\n      id: crypto.randomUUID(),\n      type: 'notification',\n      method: 'event',\n      params: event,\n      timestamp: new Date().toISOString(),\n    };\n\n    const messageStr = JSON.stringify(message);\n\n    for (const connection of targetConnections) {\n      if (connection) {\n        try {\n          connection.websocket.send(messageStr);\n        } catch (error) {\n          this.logger.warn('Failed to send event to client', {\n            sessionId: connection.sessionId,\n            error: error instanceof Error ? error.message : 'Unknown error'\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Get connection statistics\n   */\n  getConnectionStats(): {\n    totalConnections: number;\n    authenticatedConnections: number;\n    subscriptions: Record<string, number>;\n  } {\n    const authenticated = Array.from(this.connections.values()).filter(c => c.sessionId);\n    const subscriptions: Record<string, number> = {};\n\n    for (const connection of authenticated) {\n      for (const sub of connection.subscriptions) {\n        subscriptions[sub] = (subscriptions[sub] || 0) + 1;\n      }\n    }\n\n    return {\n      totalConnections: this.connections.size,\n      authenticatedConnections: authenticated.length,\n      subscriptions,\n    };\n  }\n\n  /**\n   * Close all connections (for shutdown)\n   */\n  async closeAllConnections(): Promise<void> {\n    for (const connection of this.connections.values()) {\n      try {\n        connection.websocket.close(1001, 'Server shutting down');\n      } catch (error) {\n        // Ignore errors during shutdown\n      }\n    }\n    this.connections.clear();\n  }\n}", "/**\n * Error Handler Utility\n * \n * Provides comprehensive error handling, logging, and response generation\n * for the YouTube Scraping MCP Server with proper HTTP status mapping.\n */\n\nimport type { LoggerUtil } from '@/utils/logger.util';\nimport type { MCPResponse, MCPErrorCode } from '@/types/mcp.types';\nimport { MCPErrorCodes } from '@/types/mcp.types';\n\nexport interface ErrorContext {\n  requestId?: string;\n  userId?: string;\n  operation?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface ErrorDetails {\n  code: number;\n  message: string;\n  details?: string;\n  stack?: string;\n  context?: ErrorContext;\n}\n\nexport class ErrorHandlerUtil {\n  private logger: LoggerUtil;\n\n  constructor(logger: LoggerUtil) {\n    this.logger = logger;\n  }\n\n  /**\n   * Create standardized HTTP error response\n   */\n  createErrorResponse(\n    code: number,\n    message: string,\n    id: string | null = null,\n    details?: string\n  ): Response {\n    const errorResponse = {\n      jsonrpc: '2.0' as const,\n      id,\n      error: {\n        code: this.mapHttpToMCPErrorCode(code),\n        message,\n        data: details ? { details } : undefined,\n      },\n    };\n\n    this.logger.error('HTTP Error Response Created', {\n      httpCode: code,\n      mcpCode: errorResponse.error.code,\n      message,\n      details,\n      requestId: id,\n    });\n\n    return new Response(JSON.stringify(errorResponse), {\n      status: code,\n      headers: {\n        'Content-Type': 'application/json',\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n      },\n    });\n  }\n\n  /**\n   * Create MCP error response for JSON-RPC\n   */\n  createMCPErrorResponse(\n    code: MCPErrorCode,\n    message: string,\n    id: string | number | null = null,\n    data?: unknown\n  ) {\n    const errorResponse = {\n      jsonrpc: '2.0' as const,\n      id,\n      error: {\n        code,\n        message,\n        data,\n      },\n    };\n\n    this.logger.error('MCP Error Response Created', {\n      code,\n      message,\n      data,\n      requestId: id,\n    });\n\n    return errorResponse;\n  }\n\n  /**\n   * Wrap async function with error handling\n   */\n  async wrapAsync<T>(\n    fn: () => Promise<T>,\n    context?: ErrorContext\n  ): Promise<T> {\n    try {\n      return await fn();\n    } catch (error) {\n      this.handleError(error, context);\n      throw error;\n    }\n  }\n\n  /**\n   * Wrap synchronous function with error handling\n   */\n  wrapSync<T>(\n    fn: () => T,\n    context?: ErrorContext\n  ): T {\n    try {\n      return fn();\n    } catch (error) {\n      this.handleError(error, context);\n      throw error;\n    }\n  }\n\n  /**\n   * Handle and log errors with context\n   */\n  handleError(error: unknown, context?: ErrorContext): ErrorDetails {\n    const errorDetails = this.extractErrorDetails(error, context);\n    \n    this.logger.error('Error handled', {\n      code: errorDetails.code,\n      message: errorDetails.message,\n      details: errorDetails.details,\n      context: errorDetails.context,\n      stack: errorDetails.stack,\n    });\n\n    return errorDetails;\n  }\n\n  /**\n   * Extract structured error details from various error types\n   */\n  private extractErrorDetails(error: unknown, context?: ErrorContext): ErrorDetails {\n    let code = 500;\n    let message = 'Internal Server Error';\n    let details: string | undefined;\n    let stack: string | undefined;\n\n    if (error instanceof Error) {\n      message = error.message;\n      stack = error.stack;\n      \n      // Handle specific error types\n      if (error.name === 'ValidationError') {\n        code = 400;\n      } else if (error.name === 'NotFoundError' || error.name === 'ToolNotFoundError') {\n        code = 404;\n      } else if (error.name === 'AuthenticationError') {\n        code = 401;\n      } else if (error.name === 'AuthorizationError') {\n        code = 403;\n      } else if (error.name === 'RateLimitError') {\n        code = 429;\n      } else if (error.name === 'YouTubeAPIRequestError') {\n        // Extract YouTube API error details\n        const youtubeError = error as any;\n        code = youtubeError.code || 500;\n        details = youtubeError.status;\n      } else if (error.name === 'TranscriptNotAvailableError') {\n        code = 404;\n        details = 'Transcript not available for this video';\n      }\n    } else if (typeof error === 'string') {\n      message = error;\n    } else if (error && typeof error === 'object') {\n      const errorObj = error as any;\n      message = errorObj.message || errorObj.error || 'Unknown error';\n      code = errorObj.code || errorObj.status || 500;\n      details = errorObj.details;\n    }\n\n    return {\n      code,\n      message,\n      details,\n      stack,\n      context,\n    };\n  }\n\n  /**\n   * Map HTTP status codes to MCP error codes\n   */\n  private mapHttpToMCPErrorCode(httpCode: number): MCPErrorCode {\n    switch (httpCode) {\n      case 400:\n        return MCPErrorCodes.INVALID_REQUEST;\n      case 401:\n        return MCPErrorCodes.INVALID_REQUEST; // Use closest available\n      case 403:\n        return MCPErrorCodes.INVALID_REQUEST; // Use closest available\n      case 404:\n        return MCPErrorCodes.METHOD_NOT_FOUND; // Use closest available\n      case 405:\n        return MCPErrorCodes.METHOD_NOT_FOUND;\n      case 408:\n        return MCPErrorCodes.INTERNAL_ERROR; // Use closest available\n      case 409:\n        return MCPErrorCodes.INTERNAL_ERROR; // Use closest available\n      case 422:\n        return MCPErrorCodes.INVALID_PARAMS;\n      case 429:\n        return MCPErrorCodes.RATE_LIMITED;\n      case 500:\n        return MCPErrorCodes.INTERNAL_ERROR;\n      case 501:\n        return MCPErrorCodes.INTERNAL_ERROR; // Use closest available\n      case 503:\n        return MCPErrorCodes.INTERNAL_ERROR; // Use closest available\n      default:\n        return MCPErrorCodes.INTERNAL_ERROR;\n    }\n  }\n\n  /**\n   * Check if error is retryable\n   */\n  isRetryableError(error: unknown): boolean {\n    const details = this.extractErrorDetails(error);\n    \n    // Retryable HTTP status codes\n    const retryableCodes = [408, 429, 500, 502, 503, 504];\n    \n    return retryableCodes.includes(details.code);\n  }\n\n  /**\n   * Get retry delay for exponential backoff\n   */\n  getRetryDelay(attempt: number, baseDelay: number = 1000, maxDelay: number = 30000): number {\n    const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\n    // Add jitter to prevent thundering herd\n    const jitter = Math.random() * 0.1 * delay;\n    return Math.floor(delay + jitter);\n  }\n\n  /**\n   * Execute function with retry logic\n   */\n  async withRetry<T>(\n    fn: () => Promise<T>,\n    maxRetries: number = 3,\n    baseDelay: number = 1000,\n    context?: ErrorContext\n  ): Promise<T> {\n    let lastError: unknown;\n    \n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error;\n        \n        if (attempt === maxRetries || !this.isRetryableError(error)) {\n          this.handleError(error, { ...context, metadata: { attempt, maxRetries } });\n          throw error;\n        }\n\n        const delay = this.getRetryDelay(attempt, baseDelay);\n        \n        this.logger.warn('Retrying after error', {\n          attempt: attempt + 1,\n          maxRetries,\n          delay,\n          error: error instanceof Error ? error.message : String(error),\n          context,\n        });\n\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Create user-friendly error message\n   */\n  createUserFriendlyMessage(error: unknown): string {\n    const details = this.extractErrorDetails(error);\n    \n    switch (details.code) {\n      case 400:\n        return 'Invalid request. Please check your input and try again.';\n      case 401:\n        return 'Authentication required. Please provide valid credentials.';\n      case 403:\n        return 'Access denied. You do not have permission to perform this action.';\n      case 404:\n        return 'The requested resource was not found.';\n      case 429:\n        return 'Rate limit exceeded. Please wait a moment and try again.';\n      case 500:\n        return 'An internal server error occurred. Please try again later.';\n      case 503:\n        return 'Service temporarily unavailable. Please try again later.';\n      default:\n        return 'An unexpected error occurred. Please try again.';\n    }\n  }\n\n  /**\n   * Sanitize error for client response (remove sensitive information)\n   */\n  sanitizeError(error: unknown, includeStack: boolean = false): Partial<ErrorDetails> {\n    const details = this.extractErrorDetails(error);\n    \n    return {\n      code: details.code,\n      message: details.message,\n      details: details.details,\n      ...(includeStack && { stack: details.stack }),\n    };\n  }\n}", "/**\n * MCP (Model Context Protocol) Types\n * \n * Comprehensive type definitions for the MCP protocol including\n * requests, responses, tools, and server management.\n */\n\n// JSON Schema type for tool input validation\nexport interface JSONSchema {\n  type: string;\n  properties?: Record<string, JSONSchema>;\n  required?: string[];\n  items?: JSONSchema;\n  additionalProperties?: boolean | JSONSchema;\n  description?: string;\n  enum?: unknown[];\n  const?: unknown;\n  anyOf?: JSONSchema[];\n  oneOf?: JSONSchema[];\n  allOf?: JSONSchema[];\n  not?: JSONSchema;\n  if?: JSONSchema;\n  then?: JSONSchema;\n  else?: JSONSchema;\n  format?: string;\n  pattern?: string;\n  minimum?: number;\n  maximum?: number;\n  minLength?: number;\n  maxLength?: number;\n  minItems?: number;\n  maxItems?: number;\n  uniqueItems?: boolean;\n  multipleOf?: number;\n  exclusiveMinimum?: number;\n  exclusiveMaximum?: number;\n  default?: unknown; // Added for default values\n}\n\n// MCP Error Codes (as const enum for runtime usage)\nexport const MCPErrorCodes = {\n  PARSE_ERROR: -32700,\n  INVALID_REQUEST: -32600,\n  METHOD_NOT_FOUND: -32601,\n  INVALID_PARAMS: -32602,\n  INTERNAL_ERROR: -32603,\n  SERVER_ERROR: -32000,\n  TOOL_NOT_FOUND: -32001,\n  AUTHENTICATION_FAILED: -32002,\n  AUTHORIZATION_FAILED: -32003,\n  QUOTA_EXCEEDED: -32004,\n  RATE_LIMITED: -32005,\n  VALIDATION_FAILED: -32006,\n  EXTERNAL_API_ERROR: -32007,\n  CACHE_ERROR: -32008,\n  CONFIGURATION_ERROR: -32009,\n} as const;\n\nexport type MCPErrorCode = typeof MCPErrorCodes[keyof typeof MCPErrorCodes];\n\n// Base MCP Request\nexport interface MCPRequest {\n  jsonrpc: '2.0';\n  id: string | number;\n  method: string;\n  params?: unknown;\n}\n\n// MCP Error object\nexport interface MCPError {\n  code: MCPErrorCode;\n  message: string;\n  data?: unknown;\n}\n\n// Base MCP Response\nexport interface MCPResponse {\n  jsonrpc: '2.0';\n  id: string | number;\n  result?: unknown;\n  error?: MCPError;\n}\n\n// Tool Definition for Registration\nexport interface MCPTool {\n  name: string;\n  description: string;\n  inputSchema: JSONSchema;\n  handler: (input: unknown, context: MCPContext) => Promise<MCPToolResponse>;\n}\n\n// Tool Response\nexport interface MCPToolResponse {\n  content: MCPContent[];\n  isError?: boolean;\n}\n\n// Content types for tool responses\nexport interface MCPContent {\n  type: 'text' | 'image' | 'resource';\n  text?: string;\n  data?: string;\n  mimeType?: string;\n  uri?: string;\n}\n\n// MCP Context for request processing\nexport interface MCPContext {\n  environment: 'development' | 'production';\n  requestId: string;\n  userAgent?: string;\n  clientInfo?: {\n    name: string;\n    version: string;\n  };\n  auth?: {\n    type: 'api_key' | 'oauth';\n    userId: string;\n    scopes: string[];\n  };\n}\n\n// Server Information\nexport interface MCPServerInfo {\n  name: string;\n  version: string;\n  protocolVersion: string;\n  capabilities: MCPServerCapabilities;\n}\n\nexport interface MCPServerCapabilities {\n  tools?: {\n    listChanged?: boolean;\n  };\n  resources?: {\n    subscribe?: boolean;\n    listChanged?: boolean;\n  };\n  prompts?: {\n    listChanged?: boolean;\n  };\n  logging?: Record<string, unknown>;\n}\n\n// Tool List Response\nexport interface MCPToolListResponse {\n  tools: Array<{\n    name: string;\n    description: string;\n    inputSchema: JSONSchema;\n  }>;\n}\n\n// Tool Call Request\nexport interface MCPToolCallRequest extends MCPRequest {\n  method: 'tools/call';\n  params: {\n    name: string;\n    arguments?: Record<string, unknown>;\n  };\n}\n\n// Server State Management\nexport interface MCPServerState {\n  initialized: boolean;\n  tools: Map<string, MCPTool>;\n  clientInfo?: {\n    name: string;\n    version: string;\n  };\n  capabilities: MCPServerCapabilities;\n}\n\n// Tool Registry Interface\nexport interface MCPToolRegistry {\n  register(tool: MCPTool): void;\n  unregister(toolName: string): boolean;\n  get(toolName: string): MCPTool | undefined;\n  list(): MCPTool[];\n  has(toolName: string): boolean;\n  clear(): void;\n  count(): number;\n}\n\n// Tool Execution Context\nexport interface MCPToolExecutionContext extends MCPContext {\n  tool: MCPTool;\n  input: unknown;\n  startTime: number;\n}\n\n// Tool Execution Result\nexport interface MCPToolExecutionResult {\n  success: boolean;\n  response?: MCPToolResponse;\n  error?: MCPError;\n  executionTime: number;\n}\n\n// Validation Result\nexport interface MCPValidationResult {\n  valid: boolean;\n  errors: MCPValidationError[];\n}\n\nexport interface MCPValidationError {\n  path: string;\n  message: string;\n  code: string;\n  value?: unknown;\n}\n\n// Resource Types (for future expansion)\nexport interface MCPResource {\n  uri: string;\n  name: string;\n  description?: string;\n  mimeType?: string;\n}\n\nexport interface MCPResourceListResponse {\n  resources: MCPResource[];\n}\n\n// Prompt Types (for future expansion)\nexport interface MCPPrompt {\n  name: string;\n  description?: string;\n  arguments?: JSONSchema;\n}\n\nexport interface MCPPromptListResponse {\n  prompts: MCPPrompt[];\n}\n\n// Event Types for Server Events\nexport interface MCPServerEvent {\n  type: 'tool_registered' | 'tool_unregistered' | 'tool_called' | 'error' | 'initialized';\n  timestamp: string;\n  data?: unknown;\n}\n\n// Metrics and Monitoring\nexport interface MCPMetrics {\n  requestCount: number;\n  toolCalls: Record<string, number>;\n  errorCount: number;\n  averageResponseTime: number;\n  uptime: number;\n}\n\n// Configuration for MCP Server\nexport interface MCPServerConfig {\n  maxRequestSize: number;\n  requestTimeout: number;\n  enableMetrics: boolean;\n  enableLogging: boolean;\n  toolExecutionTimeout: number;\n  maxConcurrentRequests: number;\n}\n\n// Health Check Response\nexport interface MCPHealthCheck {\n  status: 'healthy' | 'unhealthy' | 'degraded';\n  timestamp: string;\n  version: string;\n  uptime: number;\n  checks: {\n    name: string;\n    status: 'pass' | 'fail' | 'warn';\n    message?: string;\n  }[];\n}\n\n// Rate Limiting\nexport interface MCPRateLimit {\n  limit: number;\n  remaining: number;\n  resetTime: number;\n  retryAfter?: number;\n}\n\n// Caching Interface\nexport interface MCPCacheEntry<T = unknown> {\n  key: string;\n  value: T;\n  ttl: number;\n  createdAt: number;\n  accessCount: number;\n  lastAccessed: number;\n}\n\n// Batch Operations\nexport interface MCPBatchRequest extends MCPRequest {\n  method: 'batch';\n  params: {\n    requests: MCPRequest[];\n  };\n}\n\nexport interface MCPBatchResponse extends MCPResponse {\n  result: {\n    responses: MCPResponse[];\n  };\n}\n\n// Security Context\nexport interface MCPSecurityContext {\n  authenticated: boolean;\n  userId?: string;\n  permissions: string[];\n  rateLimit: MCPRateLimit;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\n// Tool Metadata for Advanced Features\nexport interface MCPToolMetadata {\n  category: string;\n  tags: string[];\n  author: string;\n  version: string;\n  documentation?: string;\n  examples?: Array<{\n    input: unknown;\n    output: MCPToolResponse;\n    description: string;\n  }>;\n  requirements?: {\n    permissions: string[];\n    quotaCost: number;\n    estimatedTime: number;\n  };\n}\n\n// Extended Tool Definition with Metadata\nexport interface MCPToolWithMetadata extends MCPTool {\n  metadata: MCPToolMetadata;\n}\n\n// Tool Discovery and Search\nexport interface MCPToolQuery {\n  category?: string;\n  tags?: string[];\n  search?: string;\n  limit?: number;\n  offset?: number;\n}\n\nexport interface MCPToolSearchResult {\n  tools: MCPToolWithMetadata[];\n  total: number;\n  hasMore: boolean;\n}", "/**\n * Tool Registry Utility\n * \n * Manages MCP tool registration, discovery, validation, and execution\n * with comprehensive error handling and logging.\n */\n\nimport type { \n  MCPTool, \n  MCPToolResponse, \n  MCPContext, \n  MCPToolRegistry,\n  MCPToolExecutionResult,\n  MCPValidationResult,\n  MCPErrorCode,\n  JSONSchema\n} from '@/types/mcp.types';\nimport { MCPErrorCodes } from '@/types/mcp.types';\nimport type { ConfigurationService } from '@/services/configuration.service';\nimport type { LoggerUtil } from '@/utils/logger.util';\n\nexport class ToolRegistryUtil implements MCPToolRegistry {\n  private tools: Map<string, MCPTool> = new Map();\n  private config: ConfigurationService;\n  private logger: LoggerUtil;\n  private initialized: boolean = false;\n\n  constructor(config: ConfigurationService, logger: LoggerUtil) {\n    this.config = config;\n    this.logger = logger;\n  }\n\n  /**\n   * Initialize the tool registry\n   */\n  async initialize(): Promise<void> {\n    try {\n      // Register built-in tools\n      await this.registerBuiltInTools();\n      \n      this.initialized = true;\n      this.logger.info('Tool registry initialized', {\n        toolCount: this.tools.size,\n        tools: Array.from(this.tools.keys()),\n      });\n    } catch (error) {\n      this.logger.error('Failed to initialize tool registry', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Register a new tool\n   */\n  register(tool: MCPTool): void {\n    // Validate tool definition\n    const validation = this.validateTool(tool);\n    if (!validation.valid) {\n      const errorMessage = validation.errors.map(e => e.message).join(', ');\n      throw new Error(`Invalid tool definition: ${errorMessage}`);\n    }\n\n    // Check for existing tool with same name\n    if (this.tools.has(tool.name)) {\n      this.logger.warn('Overwriting existing tool', { toolName: tool.name });\n    }\n\n    this.tools.set(tool.name, tool);\n    this.logger.info('Tool registered', {\n      toolName: tool.name,\n      description: tool.description,\n    });\n  }\n\n  /**\n   * Unregister a tool\n   */\n  unregister(toolName: string): boolean {\n    const existed = this.tools.has(toolName);\n    this.tools.delete(toolName);\n    \n    if (existed) {\n      this.logger.info('Tool unregistered', { toolName });\n    }\n    \n    return existed;\n  }\n\n  /**\n   * Get a specific tool\n   */\n  get(toolName: string): MCPTool | undefined {\n    return this.tools.get(toolName);\n  }\n\n  /**\n   * List all registered tools\n   */\n  list(): MCPTool[] {\n    return Array.from(this.tools.values());\n  }\n\n  /**\n   * Check if a tool exists\n   */\n  has(toolName: string): boolean {\n    return this.tools.has(toolName);\n  }\n\n  /**\n   * Clear all tools\n   */\n  clear(): void {\n    const toolCount = this.tools.size;\n    this.tools.clear();\n    this.logger.info('All tools cleared', { clearedCount: toolCount });\n  }\n\n  /**\n   * Get tool count\n   */\n  count(): number {\n    return this.tools.size;\n  }\n\n  /**\n   * Get registered tool count (alias for external interface)\n   */\n  getRegisteredToolCount(): number {\n    return this.tools.size;\n  }\n\n  /**\n   * List tools for MCP response\n   */\n  listTools(): Array<{ name: string; description: string; inputSchema: JSONSchema }> {\n    return this.list().map(tool => ({\n      name: tool.name,\n      description: tool.description,\n      inputSchema: tool.inputSchema,\n    }));\n  }\n\n  /**\n   * Execute a tool with comprehensive error handling\n   */\n  async executeTool(\n    toolName: string, \n    input: unknown, \n    context: MCPContext\n  ): Promise<MCPToolResponse> {\n    const startTime = Date.now();\n    \n    this.logger.info('Executing tool', {\n      toolName,\n      requestId: context.requestId,\n      userId: context.auth?.userId,\n    });\n\n    try {\n      // Check if tool exists\n      const tool = this.tools.get(toolName);\n      if (!tool) {\n        throw new ToolNotFoundError(`Tool '${toolName}' not found`);\n      }\n\n      // Validate input against schema\n      const validation = this.validateInput(tool.inputSchema, input);\n      if (!validation.valid) {\n        const errorMessage = validation.errors.map(e => `${e.path}: ${e.message}`).join(', ');\n        throw new ValidationError(`Input validation failed: ${errorMessage}`);\n      }\n\n      // Execute the tool\n      const result = await tool.handler(input, context);\n      \n      const executionTime = Date.now() - startTime;\n      this.logger.info('Tool executed successfully', {\n        toolName,\n        executionTime,\n        requestId: context.requestId,\n      });\n\n      return result;\n\n    } catch (error) {\n      const executionTime = Date.now() - startTime;\n      \n      this.logger.error('Tool execution failed', {\n        toolName,\n        executionTime,\n        requestId: context.requestId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      // Convert error to MCP format\n      if (error instanceof ToolNotFoundError) {\n        throw new MCPToolError(MCPErrorCodes.TOOL_NOT_FOUND, error.message);\n      }\n      \n      if (error instanceof ValidationError) {\n        throw new MCPToolError(MCPErrorCodes.VALIDATION_FAILED, error.message);\n      }\n\n      if (error instanceof MCPToolError) {\n        throw error;\n      }\n\n      // Generic error\n      throw new MCPToolError(\n        MCPErrorCodes.INTERNAL_ERROR,\n        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Validate tool definition\n   */\n  private validateTool(tool: MCPTool): MCPValidationResult {\n    const errors: Array<{ path: string; message: string; code: string }> = [];\n\n    // Validate name\n    if (!tool.name || typeof tool.name !== 'string') {\n      errors.push({\n        path: 'name',\n        message: 'Tool name is required and must be a string',\n        code: 'MISSING_NAME',\n      });\n    } else if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(tool.name)) {\n      errors.push({\n        path: 'name',\n        message: 'Tool name must start with a letter and contain only letters, numbers, and underscores',\n        code: 'INVALID_NAME',\n      });\n    }\n\n    // Validate description\n    if (!tool.description || typeof tool.description !== 'string') {\n      errors.push({\n        path: 'description',\n        message: 'Tool description is required and must be a string',\n        code: 'MISSING_DESCRIPTION',\n      });\n    }\n\n    // Validate input schema\n    if (!tool.inputSchema || typeof tool.inputSchema !== 'object') {\n      errors.push({\n        path: 'inputSchema',\n        message: 'Tool input schema is required and must be a valid JSON Schema',\n        code: 'MISSING_SCHEMA',\n      });\n    }\n\n    // Validate handler\n    if (!tool.handler || typeof tool.handler !== 'function') {\n      errors.push({\n        path: 'handler',\n        message: 'Tool handler is required and must be a function',\n        code: 'MISSING_HANDLER',\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Validate input against JSON Schema\n   */\n  private validateInput(schema: JSONSchema, input: unknown): MCPValidationResult {\n    const errors: Array<{ path: string; message: string; code: string }> = [];\n\n    try {\n      // Basic type validation\n      if (schema.type) {\n        const actualType = this.getJSONType(input);\n        if (schema.type !== actualType) {\n          errors.push({\n            path: '',\n            message: `Expected type '${schema.type}', got '${actualType}'`,\n            code: 'TYPE_MISMATCH',\n          });\n        }\n      }\n\n      // Required properties validation\n      if (schema.type === 'object' && schema.required && typeof input === 'object' && input !== null) {\n        const obj = input as Record<string, unknown>;\n        for (const requiredProp of schema.required) {\n          if (!(requiredProp in obj)) {\n            errors.push({\n              path: requiredProp,\n              message: `Required property '${requiredProp}' is missing`,\n              code: 'MISSING_PROPERTY',\n            });\n          }\n        }\n      }\n\n      // Enum validation\n      if (schema.enum && !schema.enum.includes(input)) {\n        errors.push({\n          path: '',\n          message: `Value must be one of: ${schema.enum.map(v => JSON.stringify(v)).join(', ')}`,\n          code: 'ENUM_VIOLATION',\n        });\n      }\n\n      // String length validation\n      if (schema.type === 'string' && typeof input === 'string') {\n        if (schema.minLength !== undefined && input.length < schema.minLength) {\n          errors.push({\n            path: '',\n            message: `String length must be at least ${schema.minLength}`,\n            code: 'MIN_LENGTH',\n          });\n        }\n        if (schema.maxLength !== undefined && input.length > schema.maxLength) {\n          errors.push({\n            path: '',\n            message: `String length must be at most ${schema.maxLength}`,\n            code: 'MAX_LENGTH',\n          });\n        }\n      }\n\n      // Number range validation\n      if (schema.type === 'number' && typeof input === 'number') {\n        if (schema.minimum !== undefined && input < schema.minimum) {\n          errors.push({\n            path: '',\n            message: `Number must be at least ${schema.minimum}`,\n            code: 'MIN_VALUE',\n          });\n        }\n        if (schema.maximum !== undefined && input > schema.maximum) {\n          errors.push({\n            path: '',\n            message: `Number must be at most ${schema.maximum}`,\n            code: 'MAX_VALUE',\n          });\n        }\n      }\n\n    } catch (error) {\n      errors.push({\n        path: '',\n        message: `Validation error: ${error instanceof Error ? error.message : String(error)}`,\n        code: 'VALIDATION_ERROR',\n      });\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Get JSON type of a value\n   */\n  private getJSONType(value: unknown): string {\n    if (value === null) return 'null';\n    if (Array.isArray(value)) return 'array';\n    return typeof value;\n  }\n\n  /**\n   * Calculate consistency score based on video performance variance\n   */\n  private calculateConsistencyScore(videos: Array<{ performanceScore: number }>): number {\n    if (videos.length < 2) return 100;\n    \n    const scores = videos.map(v => v.performanceScore);\n    const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length;\n    const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;\n    const standardDeviation = Math.sqrt(variance);\n    \n    // Convert to consistency score (lower deviation = higher consistency)\n    // Normalize to 0-100 scale where 100 is perfect consistency\n    const coefficientOfVariation = mean > 0 ? standardDeviation / mean : 0;\n    const consistencyScore = Math.max(0, 100 - (coefficientOfVariation * 100));\n    \n    return Math.round(consistencyScore * 100) / 100;\n  }\n\n  /**\n   * Parse ISO 8601 duration to seconds\n   */\n  private parseDurationToSeconds(duration: string): number {\n    const match = duration.match(/PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?/);\n    if (!match) return 0;\n    \n    const hours = parseInt(match[1] || '0');\n    const minutes = parseInt(match[2] || '0');\n    const seconds = parseInt(match[3] || '0');\n    \n    return hours * 3600 + minutes * 60 + seconds;\n  }\n\n  /**\n   * Identify channel strengths based on performance metrics\n   */\n  private identifyChannelStrengths(\n    avgViews: number,\n    avgEngagement: number,\n    subscriberEngagementRate: number,\n    videosPerWeek: number\n  ): string[] {\n    const strengths: string[] = [];\n    \n    if (avgViews > 100000) strengths.push('High viewership');\n    if (avgEngagement > 5) strengths.push('Excellent engagement');\n    else if (avgEngagement > 3) strengths.push('Good engagement');\n    \n    if (subscriberEngagementRate > 50) strengths.push('Strong subscriber loyalty');\n    else if (subscriberEngagementRate > 20) strengths.push('Good subscriber engagement');\n    \n    if (videosPerWeek > 3) strengths.push('High content frequency');\n    else if (videosPerWeek > 1) strengths.push('Consistent content schedule');\n    \n    if (strengths.length === 0) strengths.push('Growth opportunity');\n    \n    return strengths;\n  }\n\n  /**\n   * Analyze engagement distribution across videos\n   */\n  private analyzeEngagementDistribution(videoMetrics: Array<{ engagementScore: number; viewCount: number }>): {\n    high: number;\n    medium: number;\n    low: number;\n    averageEngagement: number;\n  } {\n    let high = 0, medium = 0, low = 0;\n    const totalEngagement = videoMetrics.reduce((sum, v) => sum + v.engagementScore, 0);\n    \n    videoMetrics.forEach(video => {\n      if (video.engagementScore > 5) high++;\n      else if (video.engagementScore > 2) medium++;\n      else low++;\n    });\n    \n    return {\n      high,\n      medium,\n      low,\n      averageEngagement: videoMetrics.length > 0 ?\n        Math.round((totalEngagement / videoMetrics.length) * 10000) / 10000 : 0,\n    };\n  }\n\n  /**\n   * Perform competitive comparison between channels\n   */\n  private performCompetitiveComparison(channelAnalyses: Array<any>): {\n    leader: any;\n    rankings: Array<{ rank: number; channel: any; score: number }>;\n    insights: string[];\n  } {\n    const validChannels = channelAnalyses.filter(c => !c.error && c.performance);\n    \n    if (validChannels.length === 0) {\n      return {\n        leader: null,\n        rankings: [],\n        insights: ['No valid channels to compare'],\n      };\n    }\n    \n    // Calculate competitive scores\n    const scoredChannels = validChannels.map(channel => {\n      const perf = channel.performance;\n      \n      // Weighted scoring: views (40%), engagement (30%), consistency (20%), frequency (10%)\n      const viewScore = Math.min(perf.averageViews / 100000 * 40, 40);\n      const engagementScore = Math.min(perf.averageEngagementRate * 6, 30);\n      const consistencyScore = channel.engagementAnalysis ?\n        (channel.engagementAnalysis.consistency / 100) * 20 : 10;\n      const frequencyScore = Math.min(perf.videosPerWeek * 2, 10);\n      \n      const totalScore = viewScore + engagementScore + consistencyScore + frequencyScore;\n      \n      return {\n        channel,\n        score: Math.round(totalScore * 100) / 100,\n      };\n    });\n    \n    // Sort by score descending\n    scoredChannels.sort((a, b) => b.score - a.score);\n    \n    const rankings = scoredChannels.map((item, index) => ({\n      rank: index + 1,\n      channel: item.channel,\n      score: item.score,\n    }));\n    \n    const leader = rankings[0];\n    \n    // Generate insights\n    const insights: string[] = [];\n    \n    if (leader) {\n      insights.push(`${leader.channel.channel.title} leads with a score of ${leader.score}`);\n      \n      const topPerformer = validChannels.reduce((prev, curr) =>\n        prev.performance.averageViews > curr.performance.averageViews ? prev : curr\n      );\n      insights.push(`Highest average views: ${topPerformer.channel.title} (${topPerformer.performance.averageViews.toLocaleString()})`);\n      \n      const mostEngaged = validChannels.reduce((prev, curr) =>\n        prev.performance.averageEngagementRate > curr.performance.averageEngagementRate ? prev : curr\n      );\n      insights.push(`Best engagement rate: ${mostEngaged.channel.title} (${mostEngaged.performance.averageEngagementRate}%)`);\n      \n      const mostConsistent = validChannels.reduce((prev, curr) =>\n        prev.performance.videosPerWeek > curr.performance.videosPerWeek ? prev : curr\n      );\n      insights.push(`Most consistent publisher: ${mostConsistent.channel.title} (${mostConsistent.performance.videosPerWeek} videos/week)`);\n    }\n    \n    return {\n      leader: leader ? leader.channel : null,\n      rankings,\n      insights,\n    };\n  }\n\n  /**\n   * Format seconds to readable time format\n   */\n  private formatSecondsToTime(seconds: number): string {\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = seconds % 60;\n    \n    if (hours > 0) {\n      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n    }\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n  }\n\n  /**\n   * Analyze keyword matches in video content\n   */\n  private analyzeKeywordMatches(\n    keywords: string[],\n    title: string,\n    description: string,\n    tags: string[]\n  ): {\n    foundKeywords: string[];\n    titleMatches: number;\n    descriptionMatches: number;\n    tagMatches: number;\n    relevanceScore: number;\n  } {\n    const foundKeywords: string[] = [];\n    let titleMatches = 0;\n    let descriptionMatches = 0;\n    let tagMatches = 0;\n\n    const titleLower = title.toLowerCase();\n    const descriptionLower = description.toLowerCase();\n    const tagsLower = tags.map(tag => tag.toLowerCase());\n\n    keywords.forEach((keyword: string) => {\n      const keywordLower = keyword.toLowerCase();\n      let found = false;\n\n      // Check title\n      if (titleLower.includes(keywordLower)) {\n        titleMatches++;\n        found = true;\n      }\n\n      // Check description\n      if (descriptionLower.includes(keywordLower)) {\n        descriptionMatches++;\n        found = true;\n      }\n\n      // Check tags\n      if (tagsLower.some(tag => tag.includes(keywordLower))) {\n        tagMatches++;\n        found = true;\n      }\n\n      if (found) {\n        foundKeywords.push(keyword);\n      }\n    });\n\n    // Calculate relevance score (weighted: title=50%, description=30%, tags=20%)\n    const maxPossibleMatches = keywords.length;\n    const titleScore = maxPossibleMatches > 0 ? (titleMatches / maxPossibleMatches) * 50 : 0;\n    const descriptionScore = maxPossibleMatches > 0 ? (descriptionMatches / maxPossibleMatches) * 30 : 0;\n    const tagScore = maxPossibleMatches > 0 ? (tagMatches / maxPossibleMatches) * 20 : 0;\n    \n    const relevanceScore = titleScore + descriptionScore + tagScore;\n\n    return {\n      foundKeywords,\n      titleMatches,\n      descriptionMatches,\n      tagMatches,\n      relevanceScore: Math.round(relevanceScore * 100) / 100,\n    };\n  }\n\n  /**\n   * Generate insights from keyword search results\n   */\n  private generateKeywordSearchInsights(\n    keywords: string[],\n    keywordStats: Record<string, { count: number; videos: string[] }>,\n    results: Array<any>\n  ): {\n    topKeyword: string | null;\n    averageRelevanceScore: number;\n    recommendations: string[];\n  } {\n    const recommendations: string[] = [];\n    \n    // Find most popular keyword\n    let topKeyword: string | null = null;\n    let maxCount = 0;\n    \n    Object.entries(keywordStats).forEach(([keyword, stats]) => {\n      if (stats.count > maxCount) {\n        maxCount = stats.count;\n        topKeyword = keyword;\n      }\n    });\n\n    // Calculate average relevance score\n    const totalRelevance = results.reduce((sum, result) => sum + result.keywordAnalysis.relevanceScore, 0);\n    const averageRelevanceScore = results.length > 0 ?\n      Math.round((totalRelevance / results.length) * 100) / 100 : 0;\n\n    // Generate recommendations\n    if (results.length === 0) {\n      recommendations.push('No results found. Try broader keywords or different search terms.');\n    } else {\n      if (averageRelevanceScore < 30) {\n        recommendations.push('Low relevance scores detected. Consider refining your keywords for better matches.');\n      }\n      \n      if (topKeyword) {\n        recommendations.push(`\"${topKeyword}\" appears most frequently in search results (${maxCount} videos).`);\n      }\n      \n      const highRelevanceVideos = results.filter(r => r.keywordAnalysis.relevanceScore > 70).length;\n      if (highRelevanceVideos > 0) {\n        recommendations.push(`${highRelevanceVideos} video(s) show high keyword relevance (>70%).`);\n      }\n      \n      // Suggest content opportunities\n      const underrepresentedKeywords = keywords.filter(k => keywordStats[k.toLowerCase()].count < 2);\n      if (underrepresentedKeywords.length > 0) {\n        recommendations.push(`Content opportunity: Keywords \"${underrepresentedKeywords.join('\", \"')}\" have limited coverage.`);\n      }\n    }\n\n    return {\n      topKeyword,\n      averageRelevanceScore,\n      recommendations,\n    };\n  }\n\n  /**\n   * Extract topics from text content\n   */\n  private extractTopicsFromText(text: string): string[] {\n    const topics: string[] = [];\n    const lowerText = text.toLowerCase();\n    \n    // Common YouTube topic keywords\n    const topicKeywords = [\n      'gaming', 'music', 'tech', 'technology', 'ai', 'tutorial', 'review', 'unboxing',\n      'cooking', 'fitness', 'workout', 'travel', 'vlog', 'comedy', 'news', 'politics',\n      'sports', 'education', 'science', 'health', 'beauty', 'fashion', 'diy', 'art',\n      'crypto', 'blockchain', 'investing', 'business', 'startup', 'productivity',\n      'motivation', 'lifestyle', 'food', 'recipe', 'movie', 'film', 'tv', 'anime',\n      'minecraft', 'fortnite', 'valorant', 'league', 'pokemon', 'react', 'javascript',\n      'python', 'coding', 'programming', 'web', 'mobile', 'app', 'ios', 'android'\n    ];\n    \n    topicKeywords.forEach(keyword => {\n      if (lowerText.includes(keyword)) {\n        topics.push(keyword);\n      }\n    });\n    \n    return [...new Set(topics)]; // Remove duplicates\n  }\n\n  /**\n   * Generate trend predictions and recommendations\n   */\n  private generateTrendPredictions(\n    topTopics: Array<{ topic: string; frequency: number }>,\n    durationPatterns: { short: number; medium: number; long: number },\n    bestPublishHours: Array<{ hour: number; videoCount: number }>,\n    trendingVideos: Array<any>\n  ): string[] {\n    const predictions: string[] = [];\n    \n    // Topic-based predictions\n    if (topTopics.length > 0) {\n      const dominantTopic = topTopics[0];\n      predictions.push(`\"${dominantTopic.topic}\" is currently trending with ${dominantTopic.frequency} videos in top results.`);\n      \n      if (topTopics.length > 1) {\n        predictions.push(`Emerging topics: ${topTopics.slice(1, 3).map(t => t.topic).join(', ')}`);\n      }\n    }\n    \n    // Duration-based predictions\n    const totalVideos = durationPatterns.short + durationPatterns.medium + durationPatterns.long;\n    if (totalVideos > 0) {\n      const shortPercentage = (durationPatterns.short / totalVideos) * 100;\n      const mediumPercentage = (durationPatterns.medium / totalVideos) * 100;\n      \n      if (shortPercentage > 60) {\n        predictions.push('Short-form content (<5min) is dominating trending videos. Consider creating bite-sized content.');\n      } else if (mediumPercentage > 50) {\n        predictions.push('Medium-form content (5-20min) shows strong performance. Detailed tutorials and reviews are trending.');\n      } else {\n        predictions.push('Long-form content (>20min) is performing well. In-depth analysis and comprehensive guides are valued.');\n      }\n    }\n    \n    // Timing predictions\n    if (bestPublishHours.length > 0) {\n      const topHour = bestPublishHours[0];\n      predictions.push(`Optimal publish time: ${topHour.hour}:00 UTC (${topHour.videoCount} trending videos published at this hour).`);\n    }\n    \n    // Engagement predictions\n    const highEngagementVideos = trendingVideos.filter(v => v.statistics.engagementRate > 5).length;\n    if (highEngagementVideos > trendingVideos.length * 0.3) {\n      predictions.push('High engagement rates (>5%) are common in trending content. Focus on community interaction.');\n    }\n    \n    return predictions;\n  }\n\n  /**\n   * Identify content opportunity based on analysis\n   */\n  private identifyContentOpportunity(\n    topTopics: Array<{ topic: string; frequency: number }>,\n    durationPatterns: { short: number; medium: number; long: number }\n  ): string {\n    if (topTopics.length === 0) {\n      return 'Diverse content landscape - opportunity for niche specialization';\n    }\n    \n    const totalDuration = durationPatterns.short + durationPatterns.medium + durationPatterns.long;\n    const dominantFormat = totalDuration > 0 ?\n      (durationPatterns.short > Math.max(durationPatterns.medium, durationPatterns.long) ? 'short' :\n       durationPatterns.medium > durationPatterns.long ? 'medium' : 'long') : 'unknown';\n    \n    const dominantTopic = topTopics[0].topic;\n    \n    return `${dominantFormat}-form ${dominantTopic} content shows strong trending potential`;\n  }\n\n  /**\n   * Generate trend insights from analysis data\n   */\n  private generateTrendInsights(\n    sortedTrends: Array<any>,\n    trendingKeywords: Array<{ keyword: string; frequency: number }>,\n    category?: string,\n    timeframe?: string\n  ): string[] {\n    const insights: string[] = [];\n    \n    if (sortedTrends.length === 0) {\n      insights.push('No significant trends detected in the current timeframe.');\n      return insights;\n    }\n\n    // Top trend analysis\n    const topTrend = sortedTrends[0];\n    insights.push(`Highest trending video: \"${topTrend.video.title}\" (trend score: ${topTrend.metrics.trendScore})`);\n\n    // Keyword analysis\n    if (trendingKeywords.length > 0) {\n      const topKeyword = trendingKeywords[0];\n      insights.push(`Most frequent trending keyword: \"${topKeyword.keyword}\" (appears in ${topKeyword.frequency} videos)`);\n    }\n\n    // Engagement insights\n    const highEngagementTrends = sortedTrends.filter(t => t.metrics.engagementRate > 5);\n    if (highEngagementTrends.length > 0) {\n      insights.push(`${highEngagementTrends.length} trending videos show high engagement (>5%)`);\n    }\n\n    // Recency insights\n    const recentTrends = sortedTrends.filter(t => t.metrics.daysSincePublished <= 3);\n    if (recentTrends.length > sortedTrends.length * 0.5) {\n      insights.push('Most trends are very recent (within 3 days) - indicating rapid viral spread');\n    }\n\n    // Category-specific insights\n    if (category) {\n      insights.push(`${category} category shows strong trending activity in the ${timeframe} timeframe`);\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate trend recommendations\n   */\n  private generateTrendRecommendations(\n    trendingKeywords: Array<{ keyword: string; frequency: number }>,\n    emergingTrends: Array<{ keyword: string; frequency: number }>,\n    timeframe?: string\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (trendingKeywords.length > 0) {\n      const topKeywords = trendingKeywords.slice(0, 3).map(k => k.keyword).join(', ');\n      recommendations.push(`Consider creating content around trending topics: ${topKeywords}`);\n    }\n\n    if (emergingTrends.length > 0) {\n      const emergingTopics = emergingTrends.slice(0, 2).map(k => k.keyword).join(', ');\n      recommendations.push(`Early opportunity: \"${emergingTopics}\" are emerging trends with growth potential`);\n    }\n\n    if (timeframe === '24h') {\n      recommendations.push('Rapid content creation recommended - trends are moving fast in the 24h window');\n    } else if (timeframe === '30d') {\n      recommendations.push('Long-term trend analysis shows stable patterns - good for strategic content planning');\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Monitor trends closely and create content that aligns with audience interests');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Analyze channel performance and generate insights\n   */\n  private analyzeChannelPerformance(channel: any, recentVideos: any[]): any {\n    const stats = channel.statistics;\n    const subscriberCount = parseInt(stats?.subscriberCount || '0');\n    const viewCount = parseInt(stats?.viewCount || '0');\n    const videoCount = parseInt(stats?.videoCount || '0');\n\n    // Calculate averages\n    const avgViewsPerVideo = videoCount > 0 ? Math.round(viewCount / videoCount) : 0;\n    const avgViewsPerSubscriber = subscriberCount > 0 ? Math.round(viewCount / subscriberCount) : 0;\n\n    // Analyze recent video performance\n    let recentPerformance = null;\n    if (recentVideos.length > 0) {\n      const totalRecentViews = recentVideos.reduce((sum, video) => sum + parseInt(video.statistics?.viewCount || '0'), 0);\n      const avgRecentViews = Math.round(totalRecentViews / recentVideos.length);\n      const totalRecentLikes = recentVideos.reduce((sum, video) => sum + parseInt(video.statistics?.likeCount || '0'), 0);\n      const avgEngagement = totalRecentViews > 0 ? Math.round((totalRecentLikes / totalRecentViews) * 10000) / 100 : 0;\n\n      recentPerformance = {\n        avgViewsLast10Videos: avgRecentViews,\n        avgEngagementRate: avgEngagement,\n        performanceVsChannel: avgViewsPerVideo > 0 ? Math.round((avgRecentViews / avgViewsPerVideo) * 100) : 0,\n      };\n    }\n\n    // Channel growth indicators\n    const growthIndicators = {\n      subscriberToVideoRatio: videoCount > 0 ? Math.round(subscriberCount / videoCount) : 0,\n      viewToSubscriberRatio: avgViewsPerSubscriber,\n      contentFrequency: this.estimateContentFrequency(recentVideos),\n    };\n\n    return {\n      channelMetrics: {\n        avgViewsPerVideo,\n        avgViewsPerSubscriber,\n        subscriberCount,\n        viewCount,\n        videoCount,\n      },\n      recentPerformance,\n      growthIndicators,\n      insights: this.generateChannelInsights(stats, recentPerformance, growthIndicators),\n    };\n  }\n\n  /**\n   * Generate competitor search queries based on channel info\n   */\n  private generateCompetitorSearchQueries(title: string, description: string): string[] {\n    const queries: string[] = [];\n    \n    // Extract key terms from title\n    const titleWords = title.toLowerCase().split(/\\s+/).filter(word => word.length > 3);\n    if (titleWords.length > 0) {\n      queries.push(titleWords.slice(0, 2).join(' '));\n    }\n\n    // Extract topics from description\n    const topics = this.extractTopicsFromText(description);\n    topics.slice(0, 2).forEach(topic => {\n      if (!queries.includes(topic)) {\n        queries.push(topic);\n      }\n    });\n\n    // Add generic search terms\n    queries.push('similar channels', 'youtube creator');\n\n    return queries;\n  }\n\n  /**\n   * Find competitor channels\n   */\n  private async findCompetitors(youtubeService: any, searchQueries: string[], excludeChannelId: string): Promise<any> {\n    const competitors: any[] = [];\n    let quotaCost = 0;\n\n    for (const query of searchQueries) {\n      try {\n        const searchResponse = await youtubeService.makeAPIRequest('search', {\n          part: 'snippet',\n          type: 'channel',\n          q: query,\n          maxResults: '5',\n        });\n        quotaCost += 100;\n\n        if (searchResponse.items) {\n          const channelIds = searchResponse.items\n            .map((item: any) => item.id.channelId)\n            .filter((id: string) => id !== excludeChannelId)\n            .slice(0, 3);\n\n          if (channelIds.length > 0) {\n            const channelsResponse = await youtubeService.makeAPIRequest('channels', {\n              part: 'snippet,statistics',\n              id: channelIds.join(','),\n            });\n            quotaCost += 1;\n\n            if (channelsResponse.items) {\n              channelsResponse.items.forEach((channel: any) => {\n                competitors.push({\n                  id: channel.id,\n                  title: channel.snippet.title,\n                  subscriberCount: parseInt(channel.statistics?.subscriberCount || '0'),\n                  videoCount: parseInt(channel.statistics?.videoCount || '0'),\n                  viewCount: parseInt(channel.statistics?.viewCount || '0'),\n                });\n              });\n            }\n          }\n        }\n      } catch (error) {\n        // Continue with other queries if one fails\n        continue;\n      }\n    }\n\n    // Sort by subscriber count and remove duplicates\n    const uniqueCompetitors = competitors\n      .filter((comp, index, self) => self.findIndex(c => c.id === comp.id) === index)\n      .sort((a, b) => b.subscriberCount - a.subscriberCount)\n      .slice(0, 5);\n\n    return {\n      competitors: uniqueCompetitors,\n      analysis: this.analyzeCompetitors(uniqueCompetitors),\n      quotaCost,\n    };\n  }\n\n  /**\n   * Generate channel recommendations\n   */\n  private generateChannelRecommendations(channelInsights: any, recentVideos: any[], competitorAnalysis: any): string[] {\n    const recommendations: string[] = [];\n    const insights = channelInsights.insights;\n    const recent = channelInsights.recentPerformance;\n\n    // Performance-based recommendations\n    if (recent && recent.performanceVsChannel < 80) {\n      recommendations.push('Recent videos are underperforming vs channel average. Consider analyzing successful content patterns.');\n    }\n\n    if (insights.includes('low engagement')) {\n      recommendations.push('Focus on improving audience engagement through calls-to-action and interactive content.');\n    }\n\n    if (insights.includes('inconsistent posting')) {\n      recommendations.push('Establish a consistent posting schedule to improve audience retention and growth.');\n    }\n\n    // Growth recommendations\n    const metrics = channelInsights.channelMetrics;\n    if (metrics.avgViewsPerSubscriber < 10) {\n      recommendations.push('Low views per subscriber ratio. Focus on creating content that resonates with your existing audience.');\n    }\n\n    if (metrics.subscriberCount > 1000 && metrics.avgViewsPerVideo < metrics.subscriberCount * 0.1) {\n      recommendations.push('Views per video are low relative to subscriber count. Consider refreshing content strategy.');\n    }\n\n    // Competitor-based recommendations\n    if (competitorAnalysis && competitorAnalysis.competitors.length > 0) {\n      const avgCompetitorSubs = competitorAnalysis.competitors.reduce((sum: number, comp: any) => sum + comp.subscriberCount, 0) / competitorAnalysis.competitors.length;\n      \n      if (metrics.subscriberCount < avgCompetitorSubs * 0.5) {\n        recommendations.push('Significant growth opportunity exists. Analyze competitor content strategies and posting patterns.');\n      }\n    }\n\n    // Content recommendations\n    if (recentVideos.length > 0) {\n      const avgDuration = recentVideos.reduce((sum, video) => sum + this.parseDurationToSeconds(video.contentDetails?.duration || 'PT0S'), 0) / recentVideos.length;\n      \n      if (avgDuration < 300) {\n        recommendations.push('Consider creating longer-form content to increase watch time and algorithm performance.');\n      } else if (avgDuration > 1200) {\n        recommendations.push('Experiment with shorter, more digestible content to improve retention rates.');\n      }\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Channel shows strong performance metrics. Continue current strategy and monitor trends.');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Estimate content frequency from recent videos\n   */\n  private estimateContentFrequency(recentVideos: any[]): string {\n    if (recentVideos.length < 2) return 'Unknown';\n\n    const dates = recentVideos\n      .map(video => new Date(video.snippet.publishedAt))\n      .sort((a, b) => b.getTime() - a.getTime());\n\n    let totalDays = 0;\n    for (let i = 0; i < dates.length - 1; i++) {\n      totalDays += (dates[i].getTime() - dates[i + 1].getTime()) / (1000 * 60 * 60 * 24);\n    }\n\n    const avgDaysBetween = totalDays / (dates.length - 1);\n\n    if (avgDaysBetween <= 1.5) return 'Daily';\n    if (avgDaysBetween <= 3.5) return 'Every 2-3 days';\n    if (avgDaysBetween <= 7.5) return 'Weekly';\n    if (avgDaysBetween <= 15) return 'Bi-weekly';\n    if (avgDaysBetween <= 31) return 'Monthly';\n    return 'Irregular';\n  }\n\n  /**\n   * Generate channel insights\n   */\n  private generateChannelInsights(stats: any, recentPerformance: any, growthIndicators: any): string[] {\n    const insights: string[] = [];\n    const subscriberCount = parseInt(stats?.subscriberCount || '0');\n    const videoCount = parseInt(stats?.videoCount || '0');\n\n    // Subscriber insights\n    if (subscriberCount < 1000) {\n      insights.push('Growing channel - focus on consistency and niche content');\n    } else if (subscriberCount < 10000) {\n      insights.push('Established audience - optimize for engagement and retention');\n    } else if (subscriberCount < 100000) {\n      insights.push('Strong channel - diversify content and collaborate with others');\n    } else {\n      insights.push('Major channel - focus on brand partnerships and expansion');\n    }\n\n    // Engagement insights\n    if (recentPerformance && recentPerformance.avgEngagementRate < 2) {\n      insights.push('low engagement');\n    } else if (recentPerformance && recentPerformance.avgEngagementRate > 5) {\n      insights.push('high audience engagement');\n    }\n\n    // Content frequency insights\n    if (growthIndicators.contentFrequency === 'Irregular') {\n      insights.push('inconsistent posting');\n    } else if (growthIndicators.contentFrequency === 'Daily') {\n      insights.push('high content frequency');\n    }\n\n    // Growth potential\n    if (growthIndicators.viewToSubscriberRatio > 20) {\n      insights.push('strong viral potential');\n    }\n\n    return insights;\n  }\n\n  /**\n   * Analyze competitor data\n   */\n  private analyzeCompetitors(competitors: any[]): any {\n    if (competitors.length === 0) {\n      return { summary: 'No competitors found for analysis' };\n    }\n\n    const totalSubs = competitors.reduce((sum, comp) => sum + comp.subscriberCount, 0);\n    const avgSubs = Math.round(totalSubs / competitors.length);\n    const topCompetitor = competitors[0];\n\n    return {\n      summary: `Found ${competitors.length} similar channels`,\n      averageSubscribers: avgSubs,\n      topCompetitor: {\n        title: topCompetitor.title,\n        subscribers: topCompetitor.subscriberCount,\n      },\n      competitionLevel: avgSubs > 100000 ? 'High' : avgSubs > 10000 ? 'Medium' : 'Low',\n    };\n  }\n\n  /**\n   * Register built-in tools\n   */\n  private async registerBuiltInTools(): Promise<void> {\n    // Register placeholder tools for the 7 planned tools\n    const builtInTools: MCPTool[] = [\n      {\n        name: 'getVideoTranscript',\n        description: 'Extract transcript from a YouTube video URL or video ID',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            videoUrl: {\n              type: 'string',\n              description: 'YouTube video URL or direct video ID (supports youtube.com/watch, youtu.be, and direct video IDs)',\n              minLength: 11,\n            },\n            language: {\n              type: 'string',\n              description: 'Preferred language code (optional, defaults to English)',\n              default: 'en',\n              pattern: '^[a-z]{2}(-[A-Z]{2})?$',\n            },\n          },\n          required: ['videoUrl'],\n          additionalProperties: false,\n        },\n        handler: async (input: unknown, context: MCPContext): Promise<MCPToolResponse> => {\n          try {\n            // Import services dynamically to avoid circular dependencies\n            const { YouTubeService } = await import('@/services/youtube.service');\n            const { ConfigurationService } = await import('@/services/configuration.service');\n            const { LoggerUtil } = await import('@/utils/logger.util');\n            \n            // Validate input\n            const validatedInput = input as { videoUrl: string; language?: string };\n            \n            // Get environment from context (this should be available in the execution context)\n            const env = (context as any).env as import('@/types/environment.types').CloudflareEnvironment;\n            if (!env) {\n              throw new Error('Environment not available in execution context');\n            }\n\n            // Initialize services\n            const config = new ConfigurationService(env);\n            await config.initialize();\n            \n            const logger = new LoggerUtil(config.getConfiguration());\n            const youtubeService = new YouTubeService(config, logger, env);\n\n            // Extract transcript\n            const transcript = await youtubeService.getVideoTranscript(\n              validatedInput.videoUrl,\n              validatedInput.language || 'en'\n            );\n\n            // Format response\n            const response = {\n              videoId: transcript.videoId,\n              title: `Video transcript for ${transcript.videoId}`,\n              language: transcript.language,\n              isAutoGenerated: transcript.isAutoGenerated,\n              transcript: {\n                fullText: transcript.fullText,\n                segments: transcript.segments,\n                wordCount: transcript.wordCount,\n                estimatedReadingTime: transcript.estimatedReadingTime\n              }\n            };\n\n            return {\n              content: [{\n                type: 'text',\n                text: JSON.stringify(response, null, 2),\n              }],\n              isError: false,\n            };\n\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            \n            return {\n              content: [{\n                type: 'text',\n                text: `Error extracting transcript: ${errorMessage}`,\n              }],\n              isError: true,\n            };\n          }\n        },\n      },\n      {\n        name: 'getVideoAnalytics',\n        description: 'Get comprehensive analytics and statistics for a YouTube video',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            url: {\n              type: 'string',\n              description: 'YouTube video URL (any format) or video ID',\n              minLength: 11,\n            },\n            includeChannel: {\n              type: 'boolean',\n              description: 'Include detailed channel analytics',\n              default: true,\n            },\n            includeEngagement: {\n              type: 'boolean',\n              description: 'Calculate engagement metrics and ratios',\n              default: true,\n            },\n          },\n          required: ['url'],\n          additionalProperties: false,\n        },\n        handler: async (input: unknown, context: MCPContext): Promise<MCPToolResponse> => {\n          try {\n            // Import services dynamically to avoid circular dependencies\n            const { YouTubeService } = await import('@/services/youtube.service');\n            const { ConfigurationService } = await import('@/services/configuration.service');\n            const { LoggerUtil } = await import('@/utils/logger.util');\n            \n            // Validate input\n            const validatedInput = input as {\n              url: string;\n              includeChannel?: boolean;\n              includeEngagement?: boolean;\n            };\n            \n            // Get environment from context\n            const env = (context as any).env as import('@/types/environment.types').CloudflareEnvironment;\n            if (!env) {\n              throw new Error('Environment not available in execution context');\n            }\n\n            // Initialize services\n            const config = new ConfigurationService(env);\n            await config.initialize();\n            \n            const logger = new LoggerUtil(config.getConfiguration());\n            const youtubeService = new YouTubeService(config, logger, env);\n\n            // Extract video ID from URL\n            const videoId = YouTubeService.extractVideoId(validatedInput.url);\n            if (!videoId) {\n              throw new Error(`Invalid YouTube URL or video ID: ${validatedInput.url}`);\n            }\n\n            // Validate video ID format\n            if (!YouTubeService.isValidVideoId(videoId)) {\n              throw new Error(`Invalid video ID format: ${videoId}`);\n            }\n\n            // Get comprehensive video information\n            const videoInfo = await youtubeService.getVideoInfo(videoId);\n            \n            // Get video metrics\n            const metrics = await youtubeService.getVideoMetrics(videoId);\n\n            // Get channel information if requested\n            let channelInfo: any = null;\n            if (validatedInput.includeChannel !== false) {\n              try {\n                // Make YouTube API request for channel information\n                const channelResponse = await youtubeService.makeAPIRequest('channels', {\n                  part: 'snippet,statistics',\n                  id: videoInfo.channelId,\n                });\n\n                if (channelResponse.items && channelResponse.items.length > 0) {\n                  const channel = channelResponse.items[0];\n                  channelInfo = {\n                    id: channel.id,\n                    title: channel.snippet.title,\n                    customUrl: channel.snippet.customUrl,\n                    publishedAt: channel.snippet.publishedAt,\n                    subscriberCount: parseInt(channel.statistics?.subscriberCount || '0'),\n                    videoCount: parseInt(channel.statistics?.videoCount || '0'),\n                    viewCount: parseInt(channel.statistics?.viewCount || '0'),\n                  };\n                }\n              } catch (error) {\n                logger.warn('Failed to get channel information', {\n                  channelId: videoInfo.channelId,\n                  error: error instanceof Error ? error.message : String(error)\n                });\n              }\n            }\n\n            // Calculate advanced analytics if requested\n            let analytics: any = {};\n            if (validatedInput.includeEngagement !== false) {\n              const publishDate = new Date(metrics.publishedAt);\n              const now = new Date();\n              const daysFromUpload = Math.floor((now.getTime() - publishDate.getTime()) / (1000 * 60 * 60 * 24));\n              \n              // Calculate engagement metrics\n              const engagementRate = metrics.viewCount > 0 ?\n                ((metrics.likeCount + metrics.commentCount) / metrics.viewCount) * 100 : 0;\n              const likeToViewRatio = metrics.viewCount > 0 ?\n                (metrics.likeCount / metrics.viewCount) * 100 : 0;\n              const commentToViewRatio = metrics.viewCount > 0 ?\n                (metrics.commentCount / metrics.viewCount) * 100 : 0;\n              const averageViewsPerDay = daysFromUpload > 0 ?\n                metrics.viewCount / daysFromUpload : metrics.viewCount;\n\n              // Determine performance category\n              let performanceCategory: 'viral' | 'high' | 'average' | 'low' = 'low';\n              if (engagementRate > 10) performanceCategory = 'viral';\n              else if (engagementRate > 5) performanceCategory = 'high';\n              else if (engagementRate > 2) performanceCategory = 'average';\n\n              analytics = {\n                engagementRate: Math.round(engagementRate * 100) / 100,\n                likeToViewRatio: Math.round(likeToViewRatio * 100) / 100,\n                commentToViewRatio: Math.round(commentToViewRatio * 100) / 100,\n                averageViewsPerDay: Math.round(averageViewsPerDay),\n                performanceCategory,\n                daysFromUpload,\n              };\n            }\n\n            // Parse video duration for better formatting\n            const parseDuration = (duration: string): string => {\n              const match = duration.match(/PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?/);\n              if (!match) return duration;\n              \n              const hours = parseInt(match[1] || '0');\n              const minutes = parseInt(match[2] || '0');\n              const seconds = parseInt(match[3] || '0');\n              \n              if (hours > 0) {\n                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n              }\n              return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n            };\n\n            // Calculate quota cost (estimated)\n            let quotaCost = 1; // Base video request\n            if (channelInfo) quotaCost += 1; // Channel request\n            \n            // Build comprehensive analytics response\n            const response = {\n              video: {\n                id: videoInfo.videoId,\n                title: videoInfo.title,\n                description: videoInfo.description.substring(0, 500) + (videoInfo.description.length > 500 ? '...' : ''),\n                publishedAt: metrics.publishedAt,\n                duration: parseDuration(videoInfo.contentDetails.duration),\n                categoryId: videoInfo.categoryId,\n                defaultLanguage: (videoInfo as any).defaultLanguage,\n                tags: videoInfo.tags.slice(0, 10), // Limit tags for readability\n              },\n              statistics: {\n                viewCount: metrics.viewCount,\n                likeCount: metrics.likeCount,\n                commentCount: metrics.commentCount,\n                favoriteCount: metrics.favoriteCount,\n                ...(metrics.dislikeCount !== undefined && { dislikeCount: metrics.dislikeCount }),\n              },\n              ...(channelInfo && {\n                channel: channelInfo,\n              }),\n              ...(Object.keys(analytics).length > 0 && {\n                analytics: analytics,\n              }),\n              metadata: {\n                retrievedAt: new Date().toISOString(),\n                cached: false, // This will be updated by caching logic\n                quota_cost: quotaCost,\n              },\n            };\n\n            return {\n              content: [{\n                type: 'text',\n                text: JSON.stringify(response, null, 2),\n              }],\n              isError: false,\n            };\n\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            \n            return {\n              content: [{\n                type: 'text',\n                text: `Error getting video analytics: ${errorMessage}`,\n              }],\n              isError: true,\n            };\n          }\n        },\n      },\n      {\n        name: 'analyzeChannelPerformance',\n        description: 'Analyze channel performance and find top-performing videos with detailed insights',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            channelId: {\n              type: 'string',\n              description: 'YouTube channel ID (format: UC...)',\n              pattern: '^UC[a-zA-Z0-9_-]{22}$',\n            },\n            videoCount: {\n              type: 'number',\n              description: 'Number of recent videos to analyze',\n              minimum: 1,\n              maximum: 50,\n              default: 10,\n            },\n            includeAnalytics: {\n              type: 'boolean',\n              description: 'Include detailed performance analytics',\n              default: true,\n            },\n          },\n          required: ['channelId'],\n          additionalProperties: false,\n        },\n        handler: async (input: unknown, context: MCPContext): Promise<MCPToolResponse> => {\n          try {\n            // Import services dynamically\n            const { YouTubeService } = await import('@/services/youtube.service');\n            const { ConfigurationService } = await import('@/services/configuration.service');\n            const { LoggerUtil } = await import('@/utils/logger.util');\n            \n            // Validate input\n            const validatedInput = input as {\n              channelId: string;\n              videoCount?: number;\n              includeAnalytics?: boolean;\n            };\n            \n            // Get environment from context\n            const env = (context as any).env as import('@/types/environment.types').CloudflareEnvironment;\n            if (!env) {\n              throw new Error('Environment not available in execution context');\n            }\n\n            // Initialize services\n            const config = new ConfigurationService(env);\n            await config.initialize();\n            \n            const logger = new LoggerUtil(config.getConfiguration());\n            const youtubeService = new YouTubeService(config, logger, env);\n\n            const channelId = validatedInput.channelId;\n            const videoCount = validatedInput.videoCount || 10;\n            const includeAnalytics = validatedInput.includeAnalytics !== false;\n\n            // Get channel information\n            const channelResponse = await youtubeService.makeAPIRequest('channels', {\n              part: 'snippet,statistics,brandingSettings',\n              id: channelId,\n            });\n\n            if (!channelResponse.items || channelResponse.items.length === 0) {\n              throw new Error(`Channel not found: ${channelId}`);\n            }\n\n            const channelData = channelResponse.items[0];\n            const channelInfo = {\n              id: channelData.id,\n              title: channelData.snippet.title,\n              description: channelData.snippet.description.substring(0, 300) + (channelData.snippet.description.length > 300 ? '...' : ''),\n              customUrl: channelData.snippet.customUrl,\n              publishedAt: channelData.snippet.publishedAt,\n              country: channelData.snippet.country,\n              subscriberCount: parseInt(channelData.statistics?.subscriberCount || '0'),\n              videoCount: parseInt(channelData.statistics?.videoCount || '0'),\n              viewCount: parseInt(channelData.statistics?.viewCount || '0'),\n              hiddenSubscriberCount: channelData.statistics?.hiddenSubscriberCount || false,\n            };\n\n            // Get recent videos from channel\n            const searchResponse = await youtubeService.makeAPIRequest('search', {\n              part: 'id,snippet',\n              channelId: channelId,\n              type: 'video',\n              order: 'date',\n              maxResults: videoCount.toString(),\n            });\n\n            if (!searchResponse.items || searchResponse.items.length === 0) {\n              throw new Error(`No videos found for channel: ${channelId}`);\n            }\n\n            // Get detailed metrics for each video\n            const videoIds = searchResponse.items.map((item: any) => item.id.videoId);\n            const videosResponse = await youtubeService.makeAPIRequest('videos', {\n              part: 'snippet,statistics,contentDetails',\n              id: videoIds.join(','),\n            });\n\n            const videos = [];\n            let totalViews = 0;\n            let totalLikes = 0;\n            let totalComments = 0;\n            let highestPerformer = { video: null as any, score: 0 };\n\n            for (const video of videosResponse.items || []) {\n              const stats = video.statistics;\n              const viewCount = parseInt(stats?.viewCount || '0');\n              const likeCount = parseInt(stats?.likeCount || '0');\n              const commentCount = parseInt(stats?.commentCount || '0');\n\n              // Calculate engagement score\n              const engagementScore = viewCount > 0 ?\n                ((likeCount + commentCount) / viewCount) * 100 : 0;\n\n              // Calculate performance score (weighted metric)\n              const performanceScore = (viewCount * 0.6) + (likeCount * 0.25) + (commentCount * 0.15);\n\n              if (performanceScore > highestPerformer.score) {\n                highestPerformer = { video, score: performanceScore };\n              }\n\n              totalViews += viewCount;\n              totalLikes += likeCount;\n              totalComments += commentCount;\n\n              // Parse duration\n              const parseDuration = (duration: string): string => {\n                const match = duration.match(/PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)S)?/);\n                if (!match) return duration;\n                \n                const hours = parseInt(match[1] || '0');\n                const minutes = parseInt(match[2] || '0');\n                const seconds = parseInt(match[3] || '0');\n                \n                if (hours > 0) {\n                  return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n                }\n                return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n              };\n\n              videos.push({\n                id: video.id,\n                title: video.snippet.title,\n                publishedAt: video.snippet.publishedAt,\n                duration: parseDuration(video.contentDetails?.duration || 'PT0S'),\n                viewCount,\n                likeCount,\n                commentCount,\n                favoriteCount: parseInt(stats?.favoriteCount || '0'),\n                engagementScore: Math.round(engagementScore * 100) / 100,\n                performanceScore: Math.round(performanceScore),\n              });\n            }\n\n            // Sort videos by performance score\n            videos.sort((a, b) => b.performanceScore - a.performanceScore);\n\n            // Calculate channel analytics\n            let analytics: any = {};\n            if (includeAnalytics) {\n              const avgViews = videos.length > 0 ? Math.round(totalViews / videos.length) : 0;\n              const avgLikes = videos.length > 0 ? Math.round(totalLikes / videos.length) : 0;\n              const avgComments = videos.length > 0 ? Math.round(totalComments / videos.length) : 0;\n              const avgEngagement = videos.length > 0 ?\n                videos.reduce((sum, v) => sum + v.engagementScore, 0) / videos.length : 0;\n\n              // Channel performance insights\n              const subscriberToViewRatio = channelInfo.subscriberCount > 0 ?\n                avgViews / channelInfo.subscriberCount : 0;\n              \n              // Performance category\n              let performanceCategory: 'excellent' | 'good' | 'average' | 'needs_improvement' = 'needs_improvement';\n              if (avgEngagement > 5) performanceCategory = 'excellent';\n              else if (avgEngagement > 3) performanceCategory = 'good';\n              else if (avgEngagement > 1) performanceCategory = 'average';\n\n              analytics = {\n                averageMetrics: {\n                  views: avgViews,\n                  likes: avgLikes,\n                  comments: avgComments,\n                  engagementRate: Math.round(avgEngagement * 100) / 100,\n                },\n                performanceInsights: {\n                  category: performanceCategory,\n                  subscriberToViewRatio: Math.round(subscriberToViewRatio * 10000) / 10000,\n                  totalEngagement: totalLikes + totalComments,\n                  consistencyScore: this.calculateConsistencyScore(videos),\n                },\n                topPerformingVideo: highestPerformer.video ? {\n                  id: highestPerformer.video.id,\n                  title: highestPerformer.video.snippet.title,\n                  viewCount: parseInt(highestPerformer.video.statistics?.viewCount || '0'),\n                  performanceScore: Math.round(highestPerformer.score),\n                } : null,\n              };\n            }\n\n            // Calculate quota cost\n            let quotaCost = 1; // Channel request\n            quotaCost += 100; // Search request (100 units)\n            quotaCost += 1; // Videos batch request\n\n            const response = {\n              channel: channelInfo,\n              videos: videos,\n              summary: {\n                analyzedVideoCount: videos.length,\n                totalViews: totalViews,\n                totalLikes: totalLikes,\n                totalComments: totalComments,\n                averageViewsPerVideo: videos.length > 0 ? Math.round(totalViews / videos.length) : 0,\n              },\n              ...(Object.keys(analytics).length > 0 && { analytics }),\n              metadata: {\n                analyzedAt: new Date().toISOString(),\n                quotaCost: quotaCost,\n                videoRange: `Last ${videos.length} videos`,\n              },\n            };\n\n            return {\n              content: [{\n                type: 'text',\n                text: JSON.stringify(response, null, 2),\n              }],\n              isError: false,\n            };\n\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            \n            return {\n              content: [{\n                type: 'text',\n                text: `Error analyzing channel performance: ${errorMessage}`,\n              }],\n              isError: true,\n            };\n          }\n        },\n      },\n      {\n        name: 'compareWithCompetitors',\n        description: 'Compare multiple channels for comprehensive competitive analysis',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            channels: {\n              type: 'array',\n              items: {\n                type: 'string',\n                pattern: '^UC[a-zA-Z0-9_-]{22}$',\n              },\n              description: 'Array of YouTube channel IDs to compare (2-5 channels)',\n              minItems: 2,\n              maxItems: 5,\n            },\n            videoSampleSize: {\n              type: 'number',\n              description: 'Number of recent videos to analyze per channel',\n              minimum: 5,\n              maximum: 20,\n              default: 10,\n            },\n            includeEngagementAnalysis: {\n              type: 'boolean',\n              description: 'Include detailed engagement metrics comparison',\n              default: true,\n            },\n          },\n          required: ['channels'],\n          additionalProperties: false,\n        },\n        handler: async (input: unknown, context: MCPContext): Promise<MCPToolResponse> => {\n          try {\n            // Import services dynamically\n            const { YouTubeService } = await import('@/services/youtube.service');\n            const { ConfigurationService } = await import('@/services/configuration.service');\n            const { LoggerUtil } = await import('@/utils/logger.util');\n            \n            // Validate input\n            const validatedInput = input as {\n              channels: string[];\n              videoSampleSize?: number;\n              includeEngagementAnalysis?: boolean;\n            };\n            \n            // Get environment from context\n            const env = (context as any).env as import('@/types/environment.types').CloudflareEnvironment;\n            if (!env) {\n              throw new Error('Environment not available in execution context');\n            }\n\n            // Initialize services\n            const config = new ConfigurationService(env);\n            await config.initialize();\n            \n            const logger = new LoggerUtil(config.getConfiguration());\n            const youtubeService = new YouTubeService(config, logger, env);\n\n            const channelIds = validatedInput.channels;\n            const videoSampleSize = validatedInput.videoSampleSize || 10;\n            const includeEngagement = validatedInput.includeEngagementAnalysis !== false;\n\n            // Analyze each channel\n            const channelAnalyses = [];\n            let totalQuotaCost = 0;\n\n            for (const channelId of channelIds) {\n              try {\n                // Get channel information\n                const channelResponse = await youtubeService.makeAPIRequest('channels', {\n                  part: 'snippet,statistics',\n                  id: channelId,\n                });\n\n                if (!channelResponse.items || channelResponse.items.length === 0) {\n                  logger.warn(`Channel not found: ${channelId}`);\n                  continue;\n                }\n\n                const channelData = channelResponse.items[0];\n                totalQuotaCost += 1; // Channel request\n\n                // Get recent videos\n                const searchResponse = await youtubeService.makeAPIRequest('search', {\n                  part: 'id,snippet',\n                  channelId: channelId,\n                  type: 'video',\n                  order: 'date',\n                  maxResults: videoSampleSize.toString(),\n                });\n\n                totalQuotaCost += 100; // Search request\n\n                if (!searchResponse.items || searchResponse.items.length === 0) {\n                  logger.warn(`No videos found for channel: ${channelId}`);\n                  continue;\n                }\n\n                // Get detailed video metrics\n                const videoIds = searchResponse.items.map((item: any) => item.id.videoId);\n                const videosResponse = await youtubeService.makeAPIRequest('videos', {\n                  part: 'snippet,statistics,contentDetails',\n                  id: videoIds.join(','),\n                });\n\n                totalQuotaCost += 1; // Videos batch request\n\n                // Calculate channel metrics\n                let totalViews = 0;\n                let totalLikes = 0;\n                let totalComments = 0;\n                let totalDuration = 0;\n                const videoMetrics = [];\n\n                for (const video of videosResponse.items || []) {\n                  const stats = video.statistics;\n                  const viewCount = parseInt(stats?.viewCount || '0');\n                  const likeCount = parseInt(stats?.likeCount || '0');\n                  const commentCount = parseInt(stats?.commentCount || '0');\n\n                  // Parse duration to seconds\n                  const duration = this.parseDurationToSeconds(video.contentDetails?.duration || 'PT0S');\n\n                  totalViews += viewCount;\n                  totalLikes += likeCount;\n                  totalComments += commentCount;\n                  totalDuration += duration;\n\n                  const engagementScore = viewCount > 0 ?\n                    ((likeCount + commentCount) / viewCount) * 100 : 0;\n\n                  videoMetrics.push({\n                    viewCount,\n                    likeCount,\n                    commentCount,\n                    duration,\n                    engagementScore: Math.round(engagementScore * 10000) / 10000,\n                  });\n                }\n\n                // Calculate averages and performance indicators\n                const videoCount = videoMetrics.length;\n                const avgViews = videoCount > 0 ? totalViews / videoCount : 0;\n                const avgLikes = videoCount > 0 ? totalLikes / videoCount : 0;\n                const avgComments = videoCount > 0 ? totalComments / videoCount : 0;\n                const avgDuration = videoCount > 0 ? totalDuration / videoCount : 0;\n                const avgEngagement = videoCount > 0 ?\n                  videoMetrics.reduce((sum, v) => sum + v.engagementScore, 0) / videoCount : 0;\n\n                // Calculate subscriber engagement rate\n                const subscriberCount = parseInt(channelData.statistics?.subscriberCount || '0');\n                const subscriberEngagementRate = subscriberCount > 0 ?\n                  (avgViews / subscriberCount) * 100 : 0;\n\n                // Determine content frequency (videos per week)\n                const oldestVideo = searchResponse.items[searchResponse.items.length - 1];\n                const newestVideo = searchResponse.items[0];\n                const timeSpan = new Date(newestVideo.snippet.publishedAt).getTime() -\n                               new Date(oldestVideo.snippet.publishedAt).getTime();\n                const weeksSpan = timeSpan / (1000 * 60 * 60 * 24 * 7);\n                const videosPerWeek = weeksSpan > 0 ? videoCount / weeksSpan : 0;\n\n                channelAnalyses.push({\n                  channel: {\n                    id: channelData.id,\n                    title: channelData.snippet.title,\n                    description: channelData.snippet.description.substring(0, 200) +\n                               (channelData.snippet.description.length > 200 ? '...' : ''),\n                    customUrl: channelData.snippet.customUrl,\n                    subscriberCount,\n                    totalVideoCount: parseInt(channelData.statistics?.videoCount || '0'),\n                    totalViewCount: parseInt(channelData.statistics?.viewCount || '0'),\n                  },\n                  performance: {\n                    analyzedVideos: videoCount,\n                    averageViews: Math.round(avgViews),\n                    averageLikes: Math.round(avgLikes),\n                    averageComments: Math.round(avgComments),\n                    averageDurationSeconds: Math.round(avgDuration),\n                    averageEngagementRate: Math.round(avgEngagement * 10000) / 10000,\n                    subscriberEngagementRate: Math.round(subscriberEngagementRate * 100) / 100,\n                    videosPerWeek: Math.round(videosPerWeek * 100) / 100,\n                  },\n                  strengths: this.identifyChannelStrengths(avgViews, avgEngagement, subscriberEngagementRate, videosPerWeek),\n                  ...(includeEngagement && {\n                    engagementAnalysis: {\n                      consistency: this.calculateConsistencyScore(videoMetrics.map(v => ({ performanceScore: v.viewCount }))),\n                      topPerformingVideoViews: Math.max(...videoMetrics.map(v => v.viewCount)),\n                      engagementDistribution: this.analyzeEngagementDistribution(videoMetrics),\n                    }\n                  }),\n                });\n\n              } catch (error) {\n                logger.error(`Failed to analyze channel ${channelId}`, {\n                  error: error instanceof Error ? error.message : String(error)\n                });\n                \n                channelAnalyses.push({\n                  channel: { id: channelId, error: 'Analysis failed' },\n                  error: error instanceof Error ? error.message : String(error),\n                });\n              }\n            }\n\n            // Perform competitive comparison\n            const comparison = this.performCompetitiveComparison(channelAnalyses);\n\n            const response = {\n              comparison: {\n                channelCount: channelAnalyses.length,\n                leader: comparison.leader,\n                rankings: comparison.rankings,\n                insights: comparison.insights,\n              },\n              channels: channelAnalyses,\n              metadata: {\n                analyzedAt: new Date().toISOString(),\n                videoSampleSize,\n                includeEngagementAnalysis: includeEngagement,\n                quotaCost: totalQuotaCost,\n              },\n            };\n\n            return {\n              content: [{\n                type: 'text',\n                text: JSON.stringify(response, null, 2),\n              }],\n              isError: false,\n            };\n\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            \n            return {\n              content: [{\n                type: 'text',\n                text: `Error performing competitive analysis: ${errorMessage}`,\n              }],\n              isError: true,\n            };\n          }\n        },\n      },\n      {\n        name: 'searchContentByKeywords',\n        description: 'Search for videos containing specific keywords in titles, descriptions, and available transcripts',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            keywords: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Keywords to search for in video content',\n              minItems: 1,\n              maxItems: 10,\n            },\n            channelId: {\n              type: 'string',\n              description: 'Channel ID to search within (optional)',\n              pattern: '^UC[a-zA-Z0-9_-]{22}$',\n            },\n            maxResults: {\n              type: 'number',\n              description: 'Maximum number of results to return',\n              minimum: 1,\n              maximum: 50,\n              default: 20,\n            },\n            publishedAfter: {\n              type: 'string',\n              description: 'Search for videos published after this date (RFC 3339 format)',\n              pattern: '^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d{3})?Z$',\n            },\n            order: {\n              type: 'string',\n              description: 'Sort order for results',\n              enum: ['relevance', 'date', 'viewCount', 'rating'],\n              default: 'relevance',\n            },\n          },\n          required: ['keywords'],\n          additionalProperties: false,\n        },\n        handler: async (input: unknown, context: MCPContext): Promise<MCPToolResponse> => {\n          try {\n            // Import services dynamically\n            const { YouTubeService } = await import('@/services/youtube.service');\n            const { ConfigurationService } = await import('@/services/configuration.service');\n            const { LoggerUtil } = await import('@/utils/logger.util');\n            \n            // Validate input\n            const validatedInput = input as {\n              keywords: string[];\n              channelId?: string;\n              maxResults?: number;\n              publishedAfter?: string;\n              order?: 'relevance' | 'date' | 'viewCount' | 'rating';\n            };\n            \n            // Get environment from context\n            const env = (context as any).env as import('@/types/environment.types').CloudflareEnvironment;\n            if (!env) {\n              throw new Error('Environment not available in execution context');\n            }\n\n            // Initialize services\n            const config = new ConfigurationService(env);\n            await config.initialize();\n            \n            const logger = new LoggerUtil(config.getConfiguration());\n            const youtubeService = new YouTubeService(config, logger, env);\n\n            const keywords = validatedInput.keywords;\n            const channelId = validatedInput.channelId;\n            const maxResults = validatedInput.maxResults || 20;\n            const publishedAfter = validatedInput.publishedAfter;\n            const order = validatedInput.order || 'relevance';\n\n            // Build search query\n            const searchQuery = keywords.map(k => `\"${k}\"`).join(' OR ');\n            \n            // Build search parameters\n            const searchParams: Record<string, string> = {\n              part: 'id,snippet',\n              type: 'video',\n              q: searchQuery,\n              maxResults: maxResults.toString(),\n              order: order,\n            };\n\n            if (channelId) {\n              searchParams.channelId = channelId;\n            }\n\n            if (publishedAfter) {\n              searchParams.publishedAfter = publishedAfter;\n            }\n\n            let quotaCost = 100; // Base search cost\n\n            // Perform search\n            const searchResponse = await youtubeService.makeAPIRequest('search', searchParams);\n\n            if (!searchResponse.items || searchResponse.items.length === 0) {\n              return {\n                content: [{\n                  type: 'text',\n                  text: JSON.stringify({\n                    results: [],\n                    summary: {\n                      keywords,\n                      totalResults: 0,\n                      searchQuery,\n                      message: 'No videos found matching the search criteria',\n                    },\n                    metadata: {\n                      searchedAt: new Date().toISOString(),\n                      quotaCost,\n                    },\n                  }, null, 2),\n                }],\n                isError: false,\n              };\n            }\n\n            // Get detailed video information\n            const videoIds = searchResponse.items.map((item: any) => item.id.videoId);\n            const videosResponse = await youtubeService.makeAPIRequest('videos', {\n              part: 'snippet,statistics,contentDetails',\n              id: videoIds.join(','),\n            });\n\n            quotaCost += 1; // Videos request\n\n            // Process results and analyze keyword matches\n            const results = [];\n            const keywordStats: Record<string, { count: number; videos: string[] }> = {};\n            \n            // Initialize keyword stats\n            keywords.forEach(keyword => {\n              keywordStats[keyword.toLowerCase()] = { count: 0, videos: [] };\n            });\n\n            for (const video of videosResponse.items || []) {\n              const snippet = video.snippet;\n              const stats = video.statistics;\n              \n              // Analyze keyword matches\n              const matches = this.analyzeKeywordMatches(\n                keywords,\n                snippet.title,\n                snippet.description,\n                snippet.tags || []\n              );\n\n              // Update keyword statistics\n              matches.foundKeywords.forEach(keyword => {\n                keywordStats[keyword.toLowerCase()].count++;\n                keywordStats[keyword.toLowerCase()].videos.push(video.id);\n              });\n\n              // Parse duration\n              const duration = this.parseDurationToSeconds(video.contentDetails?.duration || 'PT0S');\n\n              results.push({\n                video: {\n                  id: video.id,\n                  title: snippet.title,\n                  description: snippet.description.substring(0, 300) +\n                             (snippet.description.length > 300 ? '...' : ''),\n                  publishedAt: snippet.publishedAt,\n                  channelId: snippet.channelId,\n                  channelTitle: snippet.channelTitle,\n                  duration: this.formatSecondsToTime(duration),\n                  thumbnails: {\n                    default: snippet.thumbnails.default?.url,\n                    medium: snippet.thumbnails.medium?.url,\n                    high: snippet.thumbnails.high?.url,\n                  },\n                },\n                statistics: {\n                  viewCount: parseInt(stats?.viewCount || '0'),\n                  likeCount: parseInt(stats?.likeCount || '0'),\n                  commentCount: parseInt(stats?.commentCount || '0'),\n                },\n                keywordAnalysis: {\n                  foundKeywords: matches.foundKeywords,\n                  titleMatches: matches.titleMatches,\n                  descriptionMatches: matches.descriptionMatches,\n                  tagMatches: matches.tagMatches,\n                  relevanceScore: matches.relevanceScore,\n                },\n              });\n            }\n\n            // Sort results by relevance score\n            results.sort((a, b) => b.keywordAnalysis.relevanceScore - a.keywordAnalysis.relevanceScore);\n\n            // Generate insights\n            const insights = this.generateKeywordSearchInsights(keywords, keywordStats, results);\n\n            const response = {\n              results: results,\n              summary: {\n                keywords,\n                totalResults: results.length,\n                searchQuery,\n                topKeyword: insights.topKeyword,\n                averageRelevanceScore: insights.averageRelevanceScore,\n              },\n              keywordStatistics: keywordStats,\n              insights: insights.recommendations,\n              metadata: {\n                searchedAt: new Date().toISOString(),\n                searchParameters: {\n                  channelId,\n                  maxResults,\n                  publishedAfter,\n                  order,\n                },\n                quotaCost,\n              },\n            };\n\n            return {\n              content: [{\n                type: 'text',\n                text: JSON.stringify(response, null, 2),\n              }],\n              isError: false,\n            };\n\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            \n            return {\n              content: [{\n                type: 'text',\n                text: `Error searching for keywords: ${errorMessage}`,\n              }],\n              isError: true,\n            };\n          }\n        },\n      },\n      {\n        name: 'detectTrends',\n        description: 'Detect trending topics and keywords',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            category: {\n              type: 'string',\n              description: 'YouTube category to analyze',\n              enum: ['Gaming', 'Music', 'Technology', 'Entertainment', 'Education', 'News'],\n            },\n            timeframe: {\n              type: 'string',\n              description: 'Time period for trend analysis',\n              enum: ['24h', '7d', '30d'],\n              default: '7d',\n            },\n            region: {\n              type: 'string',\n              description: 'Region code for localized trends',\n              pattern: '^[A-Z]{2}$',\n              default: 'US',\n            },\n          },\n          additionalProperties: false,\n        },\n        handler: async (input: unknown, context: MCPContext): Promise<MCPToolResponse> => {\n          try {\n            // Import services dynamically\n            const { YouTubeService } = await import('@/services/youtube.service');\n            const { ConfigurationService } = await import('@/services/configuration.service');\n            const { LoggerUtil } = await import('@/utils/logger.util');\n            \n            // Validate input\n            const validatedInput = input as {\n              category?: string;\n              timeframe?: '24h' | '7d' | '30d';\n              region?: string;\n            };\n            \n            // Get environment from context\n            const env = (context as any).env as import('@/types/environment.types').CloudflareEnvironment;\n            if (!env) {\n              throw new Error('Environment not available in execution context');\n            }\n\n            // Initialize services\n            const config = new ConfigurationService(env);\n            await config.initialize();\n            \n            const logger = new LoggerUtil(config.getConfiguration());\n            const youtubeService = new YouTubeService(config, logger, env);\n\n            const category = validatedInput.category;\n            const timeframe = validatedInput.timeframe || '7d';\n            const region = validatedInput.region || 'US';\n\n            // Calculate date range based on timeframe\n            const now = new Date();\n            const publishedAfter = new Date();\n            switch (timeframe) {\n              case '24h':\n                publishedAfter.setDate(now.getDate() - 1);\n                break;\n              case '7d':\n                publishedAfter.setDate(now.getDate() - 7);\n                break;\n              case '30d':\n                publishedAfter.setDate(now.getDate() - 30);\n                break;\n            }\n\n            // Build search queries for trend detection\n            const trendQueries = [\n              'trending',\n              'viral',\n              'popular',\n              ...(category ? [`${category.toLowerCase()}`] : [])\n            ];\n\n            let quotaCost = 0;\n            const trendData = [];\n            const keywordFrequency = new Map<string, number>();\n\n            // Search for trending content with multiple queries\n            for (const query of trendQueries.slice(0, 3)) { // Limit to 3 queries to manage quota\n              try {\n                const searchParams: Record<string, string> = {\n                  part: 'id,snippet',\n                  type: 'video',\n                  q: query,\n                  maxResults: '25',\n                  order: 'relevance',\n                  publishedAfter: publishedAfter.toISOString(),\n                  regionCode: region,\n                };\n\n                const searchResponse = await youtubeService.makeAPIRequest('search', searchParams);\n                quotaCost += 100; // Search request cost\n\n                if (searchResponse.items && searchResponse.items.length > 0) {\n                  // Get detailed video information\n                  const videoIds = searchResponse.items.map((item: any) => item.id.videoId);\n                  const videosResponse = await youtubeService.makeAPIRequest('videos', {\n                    part: 'snippet,statistics',\n                    id: videoIds.join(','),\n                  });\n                  quotaCost += 1; // Videos request cost\n\n                  // Analyze videos for trends\n                  for (const video of videosResponse.items || []) {\n                    const snippet = video.snippet;\n                    const stats = video.statistics;\n                    \n                    // Extract keywords from title and description\n                    const text = `${snippet.title} ${snippet.description}`.toLowerCase();\n                    const keywords = this.extractTopicsFromText(text);\n                    \n                    // Update keyword frequency\n                    keywords.forEach(keyword => {\n                      keywordFrequency.set(keyword, (keywordFrequency.get(keyword) || 0) + 1);\n                    });\n\n                    // Calculate trend score based on engagement\n                    const viewCount = parseInt(stats?.viewCount || '0');\n                    const likeCount = parseInt(stats?.likeCount || '0');\n                    const commentCount = parseInt(stats?.commentCount || '0');\n                    \n                    const engagementRate = viewCount > 0 ?\n                      ((likeCount + commentCount) / viewCount) * 100 : 0;\n                    \n                    // Calculate days since publication\n                    const publishedDate = new Date(snippet.publishedAt);\n                    const daysSincePublished = Math.max(1,\n                      (now.getTime() - publishedDate.getTime()) / (1000 * 60 * 60 * 24)\n                    );\n                    \n                    // Trend score: recent videos with high engagement get higher scores\n                    const trendScore = (viewCount / 1000) * engagementRate * (30 / daysSincePublished);\n\n                    trendData.push({\n                      query,\n                      video: {\n                        id: video.id,\n                        title: snippet.title,\n                        channelTitle: snippet.channelTitle,\n                        publishedAt: snippet.publishedAt,\n                        categoryId: snippet.categoryId,\n                      },\n                      metrics: {\n                        viewCount,\n                        likeCount,\n                        commentCount,\n                        engagementRate: Math.round(engagementRate * 10000) / 10000,\n                        daysSincePublished: Math.round(daysSincePublished * 10) / 10,\n                        trendScore: Math.round(trendScore * 100) / 100,\n                      },\n                      keywords,\n                    });\n                  }\n                }\n              } catch (error) {\n                logger.warn(`Failed to search for query: ${query}`, {\n                  error: error instanceof Error ? error.message : String(error)\n                });\n              }\n            }\n\n            // Analyze trends\n            const sortedTrends = trendData.sort((a, b) => b.metrics.trendScore - a.metrics.trendScore);\n            \n            // Get top trending keywords\n            const trendingKeywords = Array.from(keywordFrequency.entries())\n              .sort(([, a], [, b]) => b - a)\n              .slice(0, 15)\n              .map(([keyword, frequency]) => ({ keyword, frequency }));\n\n            // Identify emerging trends (keywords with high frequency but recent appearance)\n            const emergingTrends = trendingKeywords\n              .filter(item => item.frequency >= 3)\n              .slice(0, 8);\n\n            // Generate trend insights\n            const insights = this.generateTrendInsights(\n              sortedTrends,\n              trendingKeywords,\n              category,\n              timeframe\n            );\n\n            const response = {\n              trends: {\n                topTrendingVideos: sortedTrends.slice(0, 10),\n                trendingKeywords: trendingKeywords.slice(0, 10),\n                emergingTopics: emergingTrends,\n                insights,\n              },\n              analysis: {\n                totalVideosAnalyzed: trendData.length,\n                timeframe,\n                region,\n                category: category || 'All categories',\n                topTrendScore: sortedTrends.length > 0 ? sortedTrends[0].metrics.trendScore : 0,\n                averageEngagementRate: trendData.length > 0 ?\n                  Math.round((trendData.reduce((sum, item) => sum + item.metrics.engagementRate, 0) / trendData.length) * 10000) / 10000 : 0,\n              },\n              recommendations: this.generateTrendRecommendations(trendingKeywords, emergingTrends, timeframe),\n              metadata: {\n                analyzedAt: new Date().toISOString(),\n                searchQueries: trendQueries.slice(0, 3),\n                quotaCost,\n              },\n            };\n\n            return {\n              content: [{\n                type: 'text',\n                text: JSON.stringify(response, null, 2),\n              }],\n              isError: false,\n            };\n\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            \n            return {\n              content: [{\n                type: 'text',\n                text: `Error detecting trends: ${errorMessage}`,\n              }],\n              isError: true,\n            };\n          }\n        },\n      },\n      {\n        name: 'getChannelInsights',\n        description: 'Get comprehensive insights for a YouTube channel',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            channelId: {\n              type: 'string',\n              description: 'YouTube channel ID',\n              pattern: '^UC[a-zA-Z0-9_-]{22}$',\n            },\n            includeCompetitors: {\n              type: 'boolean',\n              description: 'Include competitor analysis',\n              default: false,\n            },\n          },\n          required: ['channelId'],\n          additionalProperties: false,\n        },\n        handler: async (input: unknown, context: MCPContext): Promise<MCPToolResponse> => {\n          try {\n            // Import services dynamically\n            const { YouTubeService } = await import('@/services/youtube.service');\n            const { ConfigurationService } = await import('@/services/configuration.service');\n            const { LoggerUtil } = await import('@/utils/logger.util');\n            \n            // Validate input\n            const validatedInput = input as {\n              channelId: string;\n              includeCompetitors?: boolean;\n            };\n            \n            // Get environment from context\n            const env = (context as any).env as import('@/types/environment.types').CloudflareEnvironment;\n            if (!env) {\n              throw new Error('Environment not available in execution context');\n            }\n\n            // Initialize services\n            const config = new ConfigurationService(env);\n            await config.initialize();\n            \n            const logger = new LoggerUtil(config.getConfiguration());\n            const youtubeService = new YouTubeService(config, logger, env);\n\n            const channelId = validatedInput.channelId;\n            const includeCompetitors = validatedInput.includeCompetitors || false;\n\n            let quotaCost = 0;\n\n            // Get channel information\n            const channelResponse = await youtubeService.makeAPIRequest('channels', {\n              part: 'snippet,statistics,brandingSettings,contentDetails',\n              id: channelId,\n            });\n            quotaCost += 1;\n\n            if (!channelResponse.items || channelResponse.items.length === 0) {\n              return {\n                content: [{\n                  type: 'text',\n                  text: JSON.stringify({\n                    error: 'Channel not found',\n                    channelId,\n                    suggestions: [\n                      'Verify the channel ID is correct',\n                      'Check if the channel is public',\n                      'Ensure the channel exists',\n                    ],\n                  }, null, 2),\n                }],\n                isError: true,\n              };\n            }\n\n            const channel = channelResponse.items[0];\n            const stats = channel.statistics;\n            const snippet = channel.snippet;\n\n            // Get recent videos from the channel\n            const uploadsPlaylistId = channel.contentDetails?.relatedPlaylists?.uploads;\n            let recentVideos: any[] = [];\n            \n            if (uploadsPlaylistId) {\n              try {\n                const playlistResponse = await youtubeService.makeAPIRequest('playlistItems', {\n                  part: 'snippet',\n                  playlistId: uploadsPlaylistId,\n                  maxResults: '10',\n                });\n                quotaCost += 1;\n\n                if (playlistResponse.items && playlistResponse.items.length > 0) {\n                  const videoIds = playlistResponse.items.map((item: any) => item.snippet.resourceId.videoId);\n                  const videosResponse = await youtubeService.makeAPIRequest('videos', {\n                    part: 'snippet,statistics,contentDetails',\n                    id: videoIds.join(','),\n                  });\n                  quotaCost += 1;\n\n                  recentVideos = videosResponse.items || [];\n                }\n              } catch (error) {\n                logger.warn('Failed to fetch recent videos', {\n                  channelId,\n                  error: error instanceof Error ? error.message : String(error)\n                });\n              }\n            }\n\n            // Analyze channel performance\n            const channelInsights = this.analyzeChannelPerformance(channel, recentVideos);\n\n            // Search for similar channels (competitors) if requested\n            let competitorAnalysis = null;\n            if (includeCompetitors) {\n              try {\n                // Search for channels in similar category/niche\n                const searchQueries = this.generateCompetitorSearchQueries(snippet.title, snippet.description);\n                competitorAnalysis = await this.findCompetitors(youtubeService, searchQueries.slice(0, 2), channelId);\n                quotaCost += competitorAnalysis.quotaCost;\n              } catch (error) {\n                logger.warn('Failed to analyze competitors', {\n                  channelId,\n                  error: error instanceof Error ? error.message : String(error)\n                });\n              }\n            }\n\n            // Generate recommendations\n            const recommendations = this.generateChannelRecommendations(channelInsights, recentVideos, competitorAnalysis);\n\n            const response = {\n              channel: {\n                id: channelId,\n                title: snippet.title,\n                description: snippet.description.substring(0, 500) + (snippet.description.length > 500 ? '...' : ''),\n                customUrl: snippet.customUrl,\n                publishedAt: snippet.publishedAt,\n                country: snippet.country,\n                thumbnails: {\n                  high: snippet.thumbnails.high?.url,\n                },\n                branding: {\n                  bannerImageUrl: channel.brandingSettings?.image?.bannerExternalUrl,\n                  keywords: channel.brandingSettings?.channel?.keywords,\n                },\n              },\n              statistics: {\n                subscriberCount: parseInt(stats?.subscriberCount || '0'),\n                viewCount: parseInt(stats?.viewCount || '0'),\n                videoCount: parseInt(stats?.videoCount || '0'),\n                hiddenSubscriberCount: stats?.hiddenSubscriberCount === 'true',\n              },\n              insights: channelInsights,\n              recentContent: {\n                videos: recentVideos.slice(0, 5).map(video => ({\n                  id: video.id,\n                  title: video.snippet.title,\n                  publishedAt: video.snippet.publishedAt,\n                  viewCount: parseInt(video.statistics?.viewCount || '0'),\n                  likeCount: parseInt(video.statistics?.likeCount || '0'),\n                  commentCount: parseInt(video.statistics?.commentCount || '0'),\n                  duration: this.formatSecondsToTime(this.parseDurationToSeconds(video.contentDetails?.duration || 'PT0S')),\n                })),\n                totalAnalyzed: recentVideos.length,\n              },\n              ...(competitorAnalysis && { competitorAnalysis }),\n              recommendations,\n              metadata: {\n                analyzedAt: new Date().toISOString(),\n                includeCompetitors,\n                quotaCost,\n              },\n            };\n\n            return {\n              content: [{\n                type: 'text',\n                text: JSON.stringify(response, null, 2),\n              }],\n              isError: false,\n            };\n\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            \n            return {\n              content: [{\n                type: 'text',\n                text: `Error analyzing channel insights: ${errorMessage}`,\n              }],\n              isError: true,\n            };\n          }\n        },\n      },\n    ];\n\n    // Register all built-in tools\n    for (const tool of builtInTools) {\n      this.register(tool);\n    }\n  }\n}\n\n/**\n * Custom error classes for tool execution\n */\nexport class ToolNotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ToolNotFoundError';\n  }\n}\n\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nexport class MCPToolError extends Error {\n  public readonly code: MCPErrorCode;\n  \n  constructor(code: MCPErrorCode, message: string) {\n    super(message);\n    this.name = 'MCPToolError';\n    this.code = code;\n  }\n}", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n"],
  "mappings": ";;;;;;;;;;;;AAEA,SAAS,SAAS,SAAS,MAAM;AAChC,QAAM,MACL,mBAAmB,MAChB,UACA,IAAI;AAAA,KACH,OAAO,YAAY,WACjB,IAAI,QAAQ,SAAS,IAAI,IACzB,SACD;AAAA,EACH;AACH,MAAI,IAAI,QAAQ,IAAI,SAAS,SAAS,IAAI,aAAa,UAAU;AAChE,QAAI,CAAC,KAAK,IAAI,IAAI,SAAS,CAAC,GAAG;AAC9B,WAAK,IAAI,IAAI,SAAS,CAAC;AACvB,cAAQ;AAAA,QACP;AAAA,KACO,IAAI,SAAS,CAAC;AAAA;AAAA,MACtB;AAAA,IACD;AAAA,EACD;AACD;AArBA,IAAM;AAAN;AAAA;AAAA;AAAA,IAAM,OAAO,oBAAI,IAAI;AAEZ;AAqBT,eAAW,QAAQ,IAAI,MAAM,WAAW,OAAO;AAAA,MAC9C,MAAM,QAAQ,SAAS,UAAU;AAChC,cAAM,CAAC,SAAS,IAAI,IAAI;AACxB,iBAAS,SAAS,IAAI;AACtB,eAAO,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAAA,MAC/C;AAAA,IACD,CAAC;AAAA;AAAA;;;AC7BD,SAAS,0BAA0B,OAAO,MAAM;AAC/C,QAAM,UAAU,IAAI,QAAQ,OAAO,IAAI;AACvC,UAAQ,QAAQ,OAAO,kBAAkB;AACzC,SAAO;AACR;AAJA;AAAA;AAAA;AAAS;AAMT,eAAW,QAAQ,IAAI,MAAM,WAAW,OAAO;AAAA,MAC9C,MAAM,QAAQ,SAAS,UAAU;AAChC,eAAO,QAAQ,MAAM,QAAQ,SAAS;AAAA,UACrC,0BAA0B,MAAM,MAAM,QAAQ;AAAA,QAC/C,CAAC;AAAA,MACF;AAAA,IACD,CAAC;AAAA;AAAA;;;ACZD,IA4Ra,gBAqCA,sBA8CA;AA/Wb;AAAA;AAAA;AAAA;AAAA;AA4RO,IAAM,iBAAiB;AAAA,MAC5B,qBAAqB;AAAA,MACrB,mBAAmB;AAAA,MACnB,oBAAoB;AAAA,MACpB,uBAAuB;AAAA,MACvB,uBAAuB;AAAA,MACvB,yBAAyB;AAAA,MACzB,sBAAsB;AAAA,MACtB,oBAAoB;AAAA,MACpB,8BAA8B;AAAA,MAC9B,2BAA2B;AAAA,MAC3B,uBAAuB;AAAA,MACvB,wBAAwB;AAAA,MACxB,mBAAmB;AAAA,MACnB,iBAAiB;AAAA,MACjB,mBAAmB;AAAA,MACnB,kBAAkB;AAAA,MAClB,oBAAoB;AAAA,MACpB,oBAAoB;AAAA,MACpB,qBAAqB;AAAA,MACrB,iBAAiB;AAAA,MACjB,uBAAuB;AAAA,MACvB,mBAAmB;AAAA,MACnB,sBAAsB;AAAA,MACtB,UAAU;AAAA,MACV,kBAAkB;AAAA,MAClB,uBAAuB;AAAA,MACvB,yBAAyB;AAAA,MACzB,2BAA2B;AAAA,MAC3B,oBAAoB;AAAA,MACpB,kBAAkB;AAAA,MAClB,oBAAoB;AAAA,IACtB;AAKO,IAAM,uBAAN,MAA2B;AAAA,MAjUlC,OAiUkC;AAAA;AAAA;AAAA,MAChC,OAAO,SAAS,KAA8C;AAC5D,cAAM,SAAiE,CAAC;AAGxE,YAAI,CAAC,IAAI,iBAAiB;AACxB,iBAAO,KAAK,EAAE,OAAO,mBAAmB,SAAS,cAAc,CAAC;AAAA,QAClE;AAEA,YAAI,CAAC,IAAI,aAAa;AACpB,iBAAO,KAAK,EAAE,OAAO,eAAe,SAAS,cAAc,CAAC;AAAA,QAC9D;AAEA,YAAI,CAAC,IAAI,gBAAgB;AACvB,iBAAO,KAAK,EAAE,OAAO,kBAAkB,SAAS,wBAAwB,CAAC;AAAA,QAC3E;AAGA,YAAI,IAAI,gBAAgB,cAAc;AACpC,cAAI,IAAI,UAAU,QAAQ;AACxB,mBAAO,KAAK,EAAE,OAAO,SAAS,SAAS,sCAAsC,CAAC;AAAA,UAChF;AAAA,QACF;AAEA,eAAO;AAAA,UACL,OAAO,OAAO,WAAW;AAAA,UACzB;AAAA,QACF;AAAA,MACF;AAAA,MAEA,OAAO,WAAW,OAA2B,cAA8B;AACzE,YAAI,CAAC,MAAO,QAAO;AACnB,cAAM,SAAS,SAAS,OAAO,EAAE;AACjC,eAAO,MAAM,MAAM,IAAI,eAAe;AAAA,MACxC;AAAA,MAEA,OAAO,WAAW,OAAqC,cAAgC;AACrF,YAAI,UAAU,OAAW,QAAO;AAChC,YAAI,OAAO,UAAU,UAAW,QAAO;AACvC,eAAO,MAAM,YAAY,MAAM;AAAA,MACjC;AAAA,IACF;AAKO,IAAM,uBAAN,MAA2B;AAAA,MA/WlC,OA+WkC;AAAA;AAAA;AAAA,MAChC,OAAO,0BAA0B,KAAiD;AAChF,cAAM,cAAc,qBAAqB,WAAW,IAAI,YAAY,KAAK,KACtD,qBAAqB,WAAW,IAAI,OAAO,KAAK,KAChD,IAAI,gBAAgB;AAEvC,cAAM,kBAAmC;AAAA,UACvC,UAAU,qBAAqB,WAAW,IAAI,qBAAqB,eAAe,mBAAmB;AAAA,UACrG,QAAQ,qBAAqB,WAAW,IAAI,mBAAmB,eAAe,iBAAiB;AAAA,UAC/F,mBAAmB,qBAAqB,WAAW,IAAI,qBAAqB,eAAe,mBAAmB;AAAA,QAChH;AAEA,cAAM,cAA2B;AAAA,UAC/B,SAAS;AAAA,UACT,YAAY,qBAAqB,WAAW,IAAI,mBAAmB,eAAe,iBAAiB;AAAA,UACnG,UAAU,qBAAqB,WAAW,IAAI,iBAAiB,eAAe,eAAe;AAAA,UAC7F,YAAY,qBAAqB,WAAW,IAAI,mBAAmB,eAAe,iBAAiB;AAAA,UACnG,KAAK;AAAA,YACH,aAAa,eAAe;AAAA,YAC5B,cAAc,eAAe;AAAA,YAC7B,gBAAgB,eAAe;AAAA,YAC/B,UAAU,eAAe;AAAA,YACzB,QAAQ,eAAe;AAAA,YACvB,UAAU,eAAe;AAAA,UAC3B;AAAA,QACF;AAEA,eAAO;AAAA,UACL,aAAa,IAAI,gBAAgB,YAAY,gBAAgB,IAAI;AAAA,UACjE,OAAO;AAAA,UACP,MAAM;AAAA,YACJ,SAAS;AAAA,cACP,QAAQ,IAAI;AAAA,cACZ,YAAY,qBAAqB,WAAW,IAAI,oBAAoB,eAAe,kBAAkB;AAAA,cACrG,SAAS,eAAe;AAAA,cACxB,mBAAmB;AAAA,YACrB;AAAA,YACA,GAAI,IAAI,mBAAmB,IAAI,sBAAsB;AAAA,cACnD,OAAO;AAAA,gBACL,UAAU,IAAI;AAAA,gBACd,cAAc,IAAI;AAAA,cACpB;AAAA,YACF,IAAI,CAAC;AAAA,UACP;AAAA,UACA,kBAAkB;AAAA,YAChB,GAAI,IAAI,oBAAoB;AAAA,cAC1B,YAAY;AAAA,gBACV,YAAY,IAAI;AAAA,gBAChB,SAAS;AAAA,cACX;AAAA,YACF,IAAI,CAAC;AAAA,UACP;AAAA,UACA,OAAO;AAAA,UACP,WAAW;AAAA,UACX,YAAY;AAAA;AAAA,UACZ,aAAa;AAAA,YACX,cAAc,qBAAqB,WAAW,IAAI,2BAA2B,eAAe,yBAAyB;AAAA,YACrH,UAAU,qBAAqB,WAAW,IAAI,uBAAuB,eAAe,qBAAqB;AAAA,YACzG,WAAW,qBAAqB,WAAW,IAAI,wBAAwB,eAAe,sBAAsB;AAAA,UAC9G;AAAA,UACA,WAAW;AAAA,YACT,gBAAgB,qBAAqB,WAAW,IAAI,oBAAoB,eAAe,kBAAkB;AAAA,YACzG,mBAAmB,qBAAqB,WAAW,IAAI,uBAAuB,eAAe,qBAAqB;AAAA,YAClH,mBAAmB,qBAAqB,WAAW,IAAI,uBAAuB,eAAe,qBAAqB;AAAA,UACpH;AAAA,UACA,gBAAgB;AAAA,YACd,iBAAiB,qBAAqB,WAAW,IAAI,yBAAyB,eAAe,uBAAuB;AAAA,YACpH,gBAAgB,qBAAqB,WAAW,IAAI,sBAAsB,eAAe,oBAAoB;AAAA,YAC7G,cAAc,qBAAqB,WAAW,IAAI,oBAAoB,eAAe,kBAAkB;AAAA,YACvG,uBAAuB,qBAAqB,WAAW,IAAI,8BAA8B,eAAe,4BAA4B;AAAA,UACtI;AAAA,UACA,MAAM;AAAA,YACJ,SAAS,qBAAqB,WAAW,IAAI,kBAAkB,IAAI,gBAAgB,aAAa;AAAA,YAChG,SAAS,IAAI,mBAAmB,IAAI,iBAAiB,MAAM,GAAG,IAAI,CAAC,GAAG;AAAA,YACtE,SAAS,CAAC,OAAO,QAAQ,OAAO,UAAU,SAAS;AAAA,YACnD,SAAS,CAAC,gBAAgB,iBAAiB,kBAAkB;AAAA,UAC/D;AAAA,UACA,YAAY;AAAA,YACV,SAAS;AAAA,YACT,UAAU,cAAc,UAAU;AAAA,YAClC,kBAAkB,qBAAqB,WAAW,IAAI,mBAAmB,eAAe,iBAAiB;AAAA,YACzG,eAAe,qBAAqB,WAAW,IAAI,wBAAwB,IAAI;AAAA,YAC/E,qBAAqB;AAAA,UACvB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA;;;ACrcA;AAAA;AAAA;AAAA;AAAA,IA8Ba;AA9Bb;AAAA;AAAA;AAAA;AAAA;AAeA;AAeO,IAAM,uBAAN,MAA2B;AAAA,MA9BlC,OA8BkC;AAAA;AAAA;AAAA,MACxB;AAAA,MACA;AAAA,MACA,cAAuB;AAAA,MAE/B,YAAY,KAA4B;AACtC,aAAK,MAAM;AACX,aAAK,SAAS,qBAAQ,0BAA0B,GAAG;AAAA,MACrD;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,aAA4B;AAChC,YAAI,KAAK,YAAa;AAEtB,cAAM,aAAa,KAAK,oBAAoB,KAAK,GAAG;AACpD,YAAI,CAAC,WAAW,OAAO;AACrB,gBAAM,gBAAgB,WAAW,OAAO,IAAI,OAAK,GAAG,EAAE,KAAK,KAAK,EAAE,OAAO,EAAE,EAAE,KAAK,IAAI;AACtF,gBAAM,IAAI,MAAM,sCAAsC,aAAa,EAAE;AAAA,QACvE;AAEA,aAAK,cAAc;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,YAAiC;AAC/B,eAAO,KAAK;AAAA,MACd;AAAA;AAAA;AAAA;AAAA,MAKA,mBAAwC;AACtC,eAAO,KAAK;AAAA,MACd;AAAA;AAAA;AAAA;AAAA,MAKA,iBAA+C;AAC7C,cAAM,MAAM,KAAK,IAAI;AACrB,eAAO,QAAQ,YAAY,gBAAgB;AAAA,MAC7C;AAAA;AAAA;AAAA;AAAA,MAKA,cAAuB;AACrB,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,mBAAmB;AACjB,eAAO,KAAK,OAAO,KAAK;AAAA,MAC1B;AAAA;AAAA;AAAA;AAAA,MAKA,iBAAiB;AACf,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,qBAAqB;AACnB,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,qBAAqB;AACnB,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,gBAAgB;AACd,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,gBAAgB;AACd,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,sBAAsB;AACpB,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,4BAA4B;AAC1B,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,uBAAuB;AACrB,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,gBAAyB;AACvB,eAAO,KAAK;AAAA,MACd;AAAA;AAAA;AAAA;AAAA,MAKQ,oBAAoB,KAAsD;AAChF,cAAM,kBAAkB,qBAAU,SAAS,GAAG;AAC9C,cAAM,WAAmC,CAAC;AAC1C,cAAM,SAAiE,CAAC,GAAG,gBAAgB,MAAM;AAGjG,YAAI,IAAI,gBAAgB,cAAc;AACpC,cAAI,IAAI,UAAU,QAAQ;AACxB,qBAAS,KAAK;AAAA,cACZ,MAAM;AAAA,cACN,SAAS;AAAA,cACT,OAAO;AAAA,cACP,gBAAgB;AAAA,YAClB,CAAC;AAAA,UACH;AAEA,cAAI,CAAC,IAAI,mBAAmB,CAAC,IAAI,qBAAqB;AACpD,qBAAS,KAAK;AAAA,cACZ,MAAM;AAAA,cACN,SAAS;AAAA,cACT,OAAO;AAAA,cACP,gBAAgB;AAAA,YAClB,CAAC;AAAA,UACH;AAAA,QACF;AAGA,cAAM,oBAAoB,qBAAU,WAAW,IAAI,qBAAqB,GAAG;AAC3E,YAAI,oBAAoB,KAAM;AAC5B,mBAAS,KAAK;AAAA,YACZ,MAAM;AAAA,YACN,SAAS;AAAA,YACT,OAAO;AAAA,YACP,gBAAgB;AAAA,UAClB,CAAC;AAAA,QACH;AAGA,YAAI,IAAI,qBAAqB,UAAU,IAAI,gBAAgB,cAAc;AACvE,mBAAS,KAAK;AAAA,YACZ,MAAM;AAAA,YACN,SAAS;AAAA,YACT,OAAO;AAAA,YACP,gBAAgB;AAAA,UAClB,CAAC;AAAA,QACH;AAEA,eAAO;AAAA,UACL,OAAO,OAAO,WAAW;AAAA,UACzB;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKA,2BAAmD;AACjD,cAAM,aAAa,KAAK,oBAAoB,KAAK,GAAG;AACpD,eAAO,WAAW;AAAA,MACpB;AAAA;AAAA;AAAA;AAAA,MAKA,oBAA2C;AACzC,eAAO,KAAK;AAAA,MACd;AAAA;AAAA;AAAA;AAAA,MAKA,kBAAkB,KAAkC;AAClD,aAAK,MAAM;AACX,aAAK,SAAS,qBAAQ,0BAA0B,GAAG;AACnD,aAAK,cAAc;AAAA,MACrB;AAAA;AAAA;AAAA;AAAA,MAKA,wBAAkD;AAChD,eAAO,KAAK,oBAAoB,KAAK,GAAG;AAAA,MAC1C;AAAA,IACF;AAAA;AAAA;;;ACjPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA2Ba,gBAskBA,wBAYA;AA7mBb;AAAA;AAAA;AAAA;AAAA;AA2BO,IAAM,iBAAN,MAAM,gBAAkD;AAAA,MA3B/D,OA2B+D;AAAA;AAAA;AAAA,MACrD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MAER,YACE,QACAA,SACA,KACA;AACA,aAAK,SAAS;AACd,aAAK,SAASA;AACd,aAAK,MAAM;AAEX,cAAM,gBAAgB,KAAK,OAAO,iBAAiB;AACnD,aAAK,SAAS,cAAc;AAC5B,aAAK,UAAU,cAAc;AAAA,MAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,MAAM,mBAAmB,UAAkB,WAAmB,MAAgC;AAC5F,aAAK,OAAO,KAAK,4BAA4B,EAAE,UAAU,SAAS,CAAC;AAEnE,YAAI;AAEF,gBAAM,UAAU,gBAAe,eAAe,QAAQ;AACtD,cAAI,CAAC,SAAS;AACZ,kBAAM,IAAI,MAAM,oCAAoC,QAAQ,EAAE;AAAA,UAChE;AAGA,cAAI,CAAC,gBAAe,eAAe,OAAO,GAAG;AAC3C,kBAAM,IAAI,MAAM,4BAA4B,OAAO,EAAE;AAAA,UACvD;AAGA,gBAAM,WAAW,cAAc,OAAO,IAAI,QAAQ;AAClD,gBAAM,SAAS,MAAM,KAAK,cAA+B,QAAQ;AACjE,cAAI,QAAQ;AACV,iBAAK,OAAO,KAAK,wBAAwB,EAAE,SAAS,SAAS,CAAC;AAC9D,mBAAO;AAAA,UACT;AAGA,gBAAM,YAAY,MAAM,KAAK,aAAa,OAAO;AAGjD,cAAI,CAAC,UAAU,eAAe,SAAS;AACrC,kBAAM,IAAI;AAAA,cACR;AAAA,cACA;AAAA,cACA;AAAA,cACA,CAAC;AAAA,YACH;AAAA,UACF;AAGA,cAAI;AACJ,cAAI;AACF,+BAAmB,MAAM,KAAK;AAAA,cAC5B;AAAA,cACA,EAAE,MAAM,WAAW,QAAQ;AAAA,YAC7B;AAAA,UACF,SAAS,OAAO;AAGd,iBAAK,OAAO,KAAK,uEAAuE;AAAA,cACtF;AAAA,cACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,YAC9D,CAAC;AAED,mBAAO,KAAK,iCAAiC,SAAS,WAAW,QAAQ;AAAA,UAC3E;AAEA,cAAI,CAAC,iBAAiB,SAAS,iBAAiB,MAAM,WAAW,GAAG;AAElE,mBAAO,KAAK,iCAAiC,SAAS,WAAW,QAAQ;AAAA,UAC3E;AAGA,gBAAM,eAAe,KAAK,qBAAqB,iBAAiB,OAAO,QAAQ;AAC/E,cAAI,CAAC,cAAc;AACjB,kBAAM,qBAAqB,iBAAiB,MAAM,IAAI,CAAC,SAAc,KAAK,QAAQ,QAAQ;AAC1F,kBAAM,IAAI;AAAA,cACR;AAAA,cACA;AAAA,cACA,aAAa,QAAQ;AAAA,cACrB;AAAA,YACF;AAAA,UACF;AAIA,gBAAM,aAA8B;AAAA,YAClC;AAAA,YACA,UAAU,aAAa,QAAQ;AAAA,YAC/B,iBAAiB,aAAa,QAAQ,cAAc;AAAA,YACpD,UAAU,KAAK,0BAA0B,SAAS;AAAA,YAClD,UAAU,KAAK,4BAA4B,WAAW,YAAY;AAAA,YAClE,WAAW;AAAA;AAAA,YACX,sBAAsB;AAAA,UACxB;AAGA,gBAAM,KAAK,cAAc,UAAU,YAAY,KAAK,OAAO,eAAe,EAAE,IAAI,WAAW;AAE3F,eAAK,OAAO,KAAK,8CAA8C;AAAA,YAC7D;AAAA,YACA;AAAA,YACA,iBAAiB,WAAW;AAAA,YAC5B,gBAAgB,aAAa;AAAA,UAC/B,CAAC;AAED,iBAAO;AAAA,QAET,SAAS,OAAO;AACd,eAAK,OAAO,MAAM,kCAAkC;AAAA,YAClD;AAAA,YACA;AAAA,YACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC9D,CAAC;AAED,cAAI,iBAAiB,6BAA6B;AAChD,kBAAM;AAAA,UACR;AAEA,gBAAM,IAAI,MAAM,iCAAiC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,QAC3G;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,gBAAgB,SAAwC;AAC5D,aAAK,OAAO,KAAK,yBAAyB,EAAE,QAAQ,CAAC;AAErD,YAAI;AAEF,gBAAM,WAAW,WAAW,OAAO;AACnC,gBAAM,SAAS,MAAM,KAAK,cAA4B,QAAQ;AAC9D,cAAI,QAAQ;AACV,iBAAK,OAAO,KAAK,qBAAqB,EAAE,QAAQ,CAAC;AACjD,mBAAO;AAAA,UACT;AAEA,gBAAM,WAAW,MAAM,KAAK,sBAAsB,UAAU;AAAA,YAC1D,MAAM;AAAA,YACN,IAAI;AAAA,UACN,CAAC;AAED,cAAI,CAAC,SAAS,SAAS,SAAS,MAAM,WAAW,GAAG;AAClD,kBAAM,IAAI,MAAM,oBAAoB,OAAO,EAAE;AAAA,UAC/C;AAEA,gBAAM,QAAQ,SAAS,MAAM,CAAC;AAC9B,gBAAM,QAAQ,MAAM;AACpB,gBAAM,iBAAiB,MAAM;AAE7B,cAAI,CAAC,OAAO;AACV,kBAAM,IAAI,MAAM,gCAAgC;AAAA,UAClD;AAGA,gBAAM,YAAY,SAAS,MAAM,aAAa,GAAG;AACjD,gBAAM,YAAY,SAAS,MAAM,aAAa,GAAG;AACjD,gBAAM,eAAe,SAAS,MAAM,gBAAgB,GAAG;AACvD,gBAAM,gBAAgB,SAAS,MAAM,iBAAiB,GAAG;AAEzD,gBAAM,YAAY,YAAY,IAAK,YAAY,YAAa,MAAM;AAClE,gBAAM,eAAe,YAAY,IAAK,eAAe,YAAa,MAAM;AACxE,gBAAM,mBAAmB,YAAY,gBAAgB,KAAK,IAAI,WAAW,CAAC,IAAI;AAE9E,gBAAM,UAAwB;AAAA,YAC5B;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,cAAc,MAAM,eAAe,SAAS,MAAM,YAAY,IAAI;AAAA,YAClE,aAAa,MAAM,QAAQ;AAAA,YAC3B,UAAU,gBAAgB,YAAY;AAAA,YACtC,YAAY;AAAA,cACV,WAAW,KAAK,MAAM,YAAY,GAAG,IAAI;AAAA,cACzC,cAAc,KAAK,MAAM,eAAe,GAAG,IAAI;AAAA,cAC/C,iBAAiB,KAAK,MAAM,kBAAkB,GAAG,IAAI;AAAA,YACvD;AAAA,UACF;AAGA,gBAAM,KAAK,cAAc,UAAU,SAAS,KAAK,OAAO,eAAe,EAAE,IAAI,YAAY;AAEzF,eAAK,OAAO,KAAK,wCAAwC;AAAA,YACvD;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,iBAAiB,QAAQ,WAAW;AAAA,UACtC,CAAC;AAED,iBAAO;AAAA,QAET,SAAS,OAAO;AACd,eAAK,OAAO,MAAM,+BAA+B;AAAA,YAC/C;AAAA,YACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC9D,CAAC;AACD,gBAAM,IAAI,MAAM,gCAAgC,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,QAC1G;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,aAAa,SAAqC;AACtD,aAAK,OAAO,KAAK,sBAAsB,EAAE,QAAQ,CAAC;AAElD,YAAI;AACF,gBAAM,WAAW,MAAM,KAAK,sBAAsB,UAAU;AAAA,YAC1D,MAAM;AAAA,YACN,IAAI;AAAA,UACN,CAAC;AAED,cAAI,CAAC,SAAS,SAAS,SAAS,MAAM,WAAW,GAAG;AAClD,kBAAM,IAAI,MAAM,oBAAoB,OAAO,EAAE;AAAA,UAC/C;AAEA,gBAAM,QAAQ,SAAS,MAAM,CAAC;AAC9B,gBAAM,UAAU,MAAM,KAAK,gBAAgB,OAAO;AAElD,gBAAM,YAAuB;AAAA,YAC3B;AAAA,YACA,OAAO,MAAM,QAAQ;AAAA,YACrB,aAAa,MAAM,QAAQ;AAAA,YAC3B,WAAW,MAAM,QAAQ;AAAA,YACzB,cAAc,MAAM,QAAQ;AAAA,YAC5B;AAAA,YACA,MAAM,MAAM,QAAQ,QAAQ,CAAC;AAAA,YAC7B,YAAY,MAAM,QAAQ;AAAA,YAC1B,YAAY;AAAA,cACV,SAAS,MAAM,QAAQ,WAAW,SAAS;AAAA,cAC3C,QAAQ,MAAM,QAAQ,WAAW,QAAQ;AAAA,cACzC,MAAM,MAAM,QAAQ,WAAW,MAAM;AAAA,YACvC;AAAA,YACA,gBAAgB;AAAA,cACd,UAAU,MAAM,gBAAgB,YAAY;AAAA,cAC5C,YAAY,MAAM,gBAAgB,cAAc;AAAA,cAChD,SAAS,MAAM,gBAAgB,YAAY;AAAA,cAC3C,iBAAiB,MAAM,gBAAgB,mBAAmB;AAAA,YAC5D;AAAA,YACA,QAAQ;AAAA,cACN,eAAe,MAAM,QAAQ,iBAAiB;AAAA,cAC9C,YAAY,MAAM,QAAQ,cAAc;AAAA,cACxC,qBAAqB,MAAM,QAAQ,uBAAuB;AAAA,YAC5D;AAAA,UACF;AAEA,eAAK,OAAO,KAAK,qCAAqC;AAAA,YACpD;AAAA,YACA,OAAO,UAAU;AAAA,YACjB,cAAc,UAAU;AAAA,YACxB,UAAU,UAAU,eAAe;AAAA,UACrC,CAAC;AAED,iBAAO;AAAA,QAET,SAAS,OAAO;AACd,eAAK,OAAO,MAAM,4BAA4B;AAAA,YAC5C;AAAA,YACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC9D,CAAC;AACD,gBAAM,IAAI,MAAM,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,QACvG;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,eACJ,UACA,QACc;AACd,eAAO,KAAK,sBAAsB,UAAU,MAAM;AAAA,MACpD;AAAA;AAAA;AAAA;AAAA,MAKA,MAAc,sBACZ,UACA,QACc;AACd,cAAM,MAAM,IAAI,IAAI,GAAG,KAAK,OAAO,IAAI,QAAQ,EAAE;AACjD,YAAI,aAAa,IAAI,OAAO,KAAK,MAAM;AAEvC,eAAO,QAAQ,MAAM,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAC/C,cAAI,aAAa,IAAI,KAAK,KAAK;AAAA,QACjC,CAAC;AAED,aAAK,OAAO,MAAM,8BAA8B;AAAA,UAC9C;AAAA,UACA;AAAA,UACA,KAAK,IAAI,SAAS;AAAA,QACpB,CAAC;AAED,YAAI;AACF,gBAAM,WAAW,MAAM,MAAM,IAAI,SAAS,GAAG;AAAA,YAC3C,QAAQ;AAAA,YACR,SAAS;AAAA,cACP,cAAc;AAAA,cACd,UAAU;AAAA,YACZ;AAAA,UACF,CAAC;AAED,cAAI,CAAC,SAAS,IAAI;AAChB,kBAAM,YAAY,MAAM,SAAS,KAAK;AACtC,kBAAM,IAAI;AAAA,cACR,UAAU,MAAM;AAAA,cAChB,UAAU,MAAM;AAAA,cAChB,UAAU,MAAM;AAAA,YAClB;AAAA,UACF;AAEA,gBAAM,OAAO,MAAM,SAAS,KAAK;AAEjC,eAAK,OAAO,MAAM,kCAAkC;AAAA,YAClD;AAAA,YACA,QAAQ,SAAS;AAAA,YACjB,aAAa,KAAK,OAAO,UAAU;AAAA,UACrC,CAAC;AAED,iBAAO;AAAA,QAET,SAAS,OAAO;AACd,cAAI,iBAAiB,wBAAwB;AAC3C,kBAAM;AAAA,UACR;AAEA,eAAK,OAAO,MAAM,8BAA8B;AAAA,YAC9C;AAAA,YACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC9D,CAAC;AAED,gBAAM,IAAI,MAAM,+BAA+B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,QACzG;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKQ,qBAAqB,eAAsB,UAA8B;AAE/E,YAAI,QAAQ,cAAc,KAAK,CAAAC,WAASA,OAAM,QAAQ,aAAa,QAAQ;AAC3E,YAAI,MAAO,QAAO;AAGlB,cAAM,eAAe,SAAS,MAAM,GAAG,EAAE,CAAC;AAC1C,gBAAQ,cAAc,KAAK,CAAAA,WAASA,OAAM,QAAQ,SAAS,WAAW,YAAY,CAAC;AACnF,YAAI,MAAO,QAAO;AAGlB,gBAAQ,cAAc,KAAK,CAAAA,WAASA,OAAM,QAAQ,SAAS,WAAW,IAAI,CAAC;AAC3E,YAAI,MAAO,QAAO;AAGlB,eAAO,cAAc,CAAC,KAAK;AAAA,MAC7B;AAAA;AAAA;AAAA;AAAA,MAKQ,iCAAiC,SAAiB,WAAsB,UAAmC;AACjH,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA,iBAAiB;AAAA;AAAA,UACjB,UAAU,KAAK,0BAA0B,SAAS;AAAA,UAClD,UAAU,KAAK,4BAA4B,SAAS;AAAA,UACpD,WAAW;AAAA,UACX,sBAAsB;AAAA,QACxB;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKQ,0BAA0B,WAA2C;AAC3E,cAAM,kBAAkB,KAAK,cAAc,UAAU,eAAe,QAAQ;AAC5E,cAAM,WAAgC,CAAC;AAGvC,cAAM,kBAAkB;AACxB,cAAM,cAAc,KAAK,KAAK,kBAAkB,eAAe;AAE/D,iBAAS,IAAI,GAAG,IAAI,KAAK,IAAI,aAAa,EAAE,GAAG,KAAK;AAClD,gBAAM,QAAQ,IAAI;AAClB,gBAAM,MAAM,KAAK,IAAI,QAAQ,iBAAiB,eAAe;AAE7D,mBAAS,KAAK;AAAA,YACZ,MAAM,uBAAuB,IAAI,CAAC,MAAM,KAAK,WAAW,KAAK,CAAC,OAAO,KAAK,WAAW,GAAG,CAAC;AAAA,YACzF;AAAA,YACA,UAAU,MAAM;AAAA,YAChB;AAAA,UACF,CAAC;AAAA,QACH;AAEA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA,MAKQ,4BAA4B,WAAsB,cAA4B;AACpF,cAAM,QAAQ;AAAA,UACZ,UAAU,UAAU,KAAK;AAAA,UACzB,YAAY,UAAU,YAAY;AAAA,UAClC,aAAa,KAAK,eAAe,UAAU,eAAe,QAAQ,CAAC;AAAA,UACnE;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAEA,YAAI,cAAc;AAChB,gBAAM;AAAA,YACJ,qBAAqB,aAAa,QAAQ,QAAQ;AAAA,YAClD,iBAAiB,aAAa,QAAQ,cAAc,QAAQ,mBAAmB,QAAQ;AAAA,YACvF;AAAA,UACF;AAAA,QACF;AAEA,cAAM;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAEA,eAAO,MAAM,KAAK,IAAI;AAAA,MACxB;AAAA;AAAA;AAAA;AAAA,MAKQ,cAAc,UAA0B;AAC9C,cAAM,QAAQ,SAAS,MAAM,qCAAqC;AAClE,YAAI,CAAC,MAAO,QAAO;AAEnB,cAAM,QAAQ,SAAS,MAAM,CAAC,KAAK,GAAG;AACtC,cAAM,UAAU,SAAS,MAAM,CAAC,KAAK,GAAG;AACxC,cAAM,UAAU,SAAS,MAAM,CAAC,KAAK,GAAG;AAExC,eAAO,QAAQ,OAAO,UAAU,KAAK;AAAA,MACvC;AAAA;AAAA;AAAA;AAAA,MAKQ,WAAW,SAAyB;AAC1C,cAAM,QAAQ,KAAK,MAAM,UAAU,IAAI;AACvC,cAAM,UAAU,KAAK,MAAO,UAAU,OAAQ,EAAE;AAChD,cAAM,OAAO,UAAU;AAEvB,YAAI,QAAQ,GAAG;AACb,iBAAO,GAAG,KAAK,IAAI,QAAQ,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC,IAAI,KAAK,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,QAC5F;AACA,eAAO,GAAG,OAAO,IAAI,KAAK,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,MACvD;AAAA;AAAA;AAAA;AAAA,MAKQ,eAAe,UAA0B;AAC/C,cAAM,UAAU,KAAK,cAAc,QAAQ;AAC3C,eAAO,KAAK,WAAW,OAAO;AAAA,MAChC;AAAA;AAAA;AAAA;AAAA,MAKQ,uBAAuB,SAAsC;AAGnE,cAAM,WAAgC,CAAC;AAGvC,cAAM,QAAQ,QAAQ,MAAM,IAAI,EAAE,OAAO,UAAQ,KAAK,KAAK,CAAC;AAE5D,iBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,gBAAM,OAAO,MAAM,CAAC,EAAE,KAAK;AAC3B,cAAI,QAAQ,CAAC,KAAK,SAAS,KAAK,KAAK,CAAC,KAAK,MAAM,OAAO,GAAG;AACzD,qBAAS,KAAK;AAAA,cACZ,MAAM;AAAA,cACN,OAAO,IAAI;AAAA;AAAA,cACX,UAAU;AAAA,cACV,MAAM,IAAI,KAAK;AAAA,YACjB,CAAC;AAAA,UACH;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA,MAKA,MAAc,cAAiB,KAAgC;AAC7D,YAAI;AACF,cAAI,CAAC,KAAK,OAAO,eAAe,EAAE,SAAS;AACzC,mBAAO;AAAA,UACT;AAEA,gBAAM,SAAS,MAAM,KAAK,IAAI,UAAU,IAAI,GAAG;AAC/C,cAAI,QAAQ;AACV,mBAAO,KAAK,MAAM,MAAM;AAAA,UAC1B;AAAA,QACF,SAAS,OAAO;AACd,eAAK,OAAO,KAAK,qBAAqB;AAAA,YACpC;AAAA,YACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC9D,CAAC;AAAA,QACH;AACA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA,MAKA,MAAc,cAAiB,KAAa,MAAS,KAA4B;AAC/E,YAAI;AACF,cAAI,CAAC,KAAK,OAAO,eAAe,EAAE,SAAS;AACzC;AAAA,UACF;AAEA,gBAAM,KAAK,IAAI,UAAU,IAAI,KAAK,KAAK,UAAU,IAAI,GAAG;AAAA,YACtD,eAAe;AAAA,UACjB,CAAC;AAED,eAAK,OAAO,MAAM,4BAA4B,EAAE,KAAK,IAAI,CAAC;AAAA,QAC5D,SAAS,OAAO;AACd,eAAK,OAAO,KAAK,sBAAsB;AAAA,YACrC;AAAA,YACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC9D,CAAC;AAAA,QACH;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKA,OAAO,eAAe,KAA4B;AAChD,cAAM,WAAW;AAAA,UACf;AAAA,UACA;AAAA;AAAA,QACF;AAEA,mBAAW,WAAW,UAAU;AAC9B,gBAAM,QAAQ,IAAI,MAAM,OAAO;AAC/B,cAAI,OAAO;AACT,mBAAO,MAAM,CAAC;AAAA,UAChB;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA,MAKA,OAAO,eAAe,SAA0B;AAC9C,eAAO,sBAAsB,KAAK,OAAO;AAAA,MAC3C;AAAA,IACF;AAKO,IAAM,yBAAN,cAAqC,MAAM;AAAA,MAjmBlD,OAimBkD;AAAA;AAAA;AAAA,MAChC;AAAA,MACA;AAAA,MAEhB,YAAY,MAAc,SAAiB,QAAgB;AACzD,cAAM,OAAO;AACb,aAAK,OAAO;AACZ,aAAK,OAAO;AACZ,aAAK,SAAS;AAAA,MAChB;AAAA,IACF;AAEO,IAAM,8BAAN,cAA0C,MAAiC;AAAA,MA7mBlF,OA6mBkF;AAAA;AAAA;AAAA,MAChE;AAAA,MACA;AAAA,MACA;AAAA,MAEhB,YACE,SACA,OACA,SACA,oBACA;AACA,cAAM,OAAO;AACb,aAAK,OAAO;AACZ,aAAK,UAAU;AACf,aAAK,QAAQ;AACb,aAAK,qBAAqB;AAAA,MAC5B;AAAA,IACF;AAAA;AAAA;;;AC9nBA;AAAA;AAAA;AAAA;AAAA,IAkBa;AAlBb;AAAA;AAAA;AAAA;AAAA;AAkBO,IAAM,aAAN,MAAM,YAAW;AAAA,MAlBxB,OAkBwB;AAAA;AAAA;AAAA,MACd;AAAA,MACA,YAAsC;AAAA,QAC5C,OAAO,EAAE,OAAO,SAAS,UAAU,EAAE;AAAA,QACrC,MAAM,EAAE,OAAO,QAAQ,UAAU,EAAE;AAAA,QACnC,MAAM,EAAE,OAAO,QAAQ,UAAU,EAAE;AAAA,QACnC,OAAO,EAAE,OAAO,SAAS,UAAU,EAAE;AAAA,MACvC;AAAA,MAEA,YAAY,QAA6B;AACvC,aAAK,SAAS;AAAA,MAChB;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,SAAiB,SAA4B;AACjD,aAAK,IAAI,SAAS,SAAS,OAAO;AAAA,MACpC;AAAA;AAAA;AAAA;AAAA,MAKA,KAAK,SAAiB,SAA4B;AAChD,aAAK,IAAI,QAAQ,SAAS,OAAO;AAAA,MACnC;AAAA;AAAA;AAAA;AAAA,MAKA,KAAK,SAAiB,SAA4B;AAChD,aAAK,IAAI,QAAQ,SAAS,OAAO;AAAA,MACnC;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,SAAiB,SAA4B;AACjD,aAAK,IAAI,SAAS,SAAS,OAAO;AAAA,MACpC;AAAA;AAAA;AAAA;AAAA,MAKQ,IAAI,OAA4C,SAAiB,SAA4B;AACnG,cAAM,eAAe,KAAK,UAAU,KAAK,OAAO,WAAW,QAAQ;AACnE,cAAM,cAAc,KAAK,UAAU,KAAK;AAGxC,YAAI,YAAY,WAAW,aAAa,UAAU;AAChD;AAAA,QACF;AAEA,cAAM,WAAW;AAAA,UACf,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UAClC;AAAA,UACA;AAAA,UACA,aAAa,KAAK,OAAO;AAAA,UACzB,GAAG;AAAA,QACL;AAGA,gBAAQ,OAAO;AAAA,UACb,KAAK;AACH,oBAAQ,MAAM,KAAK,UAAU,QAAQ,CAAC;AACtC;AAAA,UACF,KAAK;AACH,oBAAQ,KAAK,KAAK,UAAU,QAAQ,CAAC;AACrC;AAAA,UACF,KAAK;AACH,oBAAQ,KAAK,KAAK,UAAU,QAAQ,CAAC;AACrC;AAAA,UACF,KAAK;AACH,oBAAQ,MAAM,KAAK,UAAU,QAAQ,CAAC;AACtC;AAAA,QACJ;AAAA,MACF;AAAA;AAAA;AAAA;AAAA,MAKA,eAAe,WAAmB,WAAmB,SAA4B;AAC/E,cAAM,WAAW,KAAK,IAAI,IAAI;AAC9B,aAAK,KAAK,gBAAgB,SAAS,IAAI;AAAA,UACrC;AAAA,UACA;AAAA,UACA,qBAAqB,WAAW,MAAM,SAAS,WAAW,MAAM,WAAW;AAAA,UAC3E,GAAG;AAAA,QACL,CAAC;AAAA,MACH;AAAA;AAAA;AAAA;AAAA,MAKA,WACE,QACA,KACA,YACA,UACA,SACM;AACN,cAAM,QAAQ,cAAc,MAAM,SAAS;AAC3C,aAAK,IAAI,OAAO,GAAG,MAAM,IAAI,GAAG,IAAI,UAAU,IAAI;AAAA,UAChD;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,iBAAiB,cAAc,MAAM,iBAAiB,cAAc,MAAM,iBAAiB;AAAA,UAC3F,GAAG;AAAA,QACL,CAAC;AAAA,MACH;AAAA;AAAA;AAAA;AAAA,MAKA,cACE,WACA,WACA,gBACA,SACM;AACN,cAAM,eAAgB,aAAa,YAAY,kBAAmB;AAClE,cAAM,QAAQ,eAAe,KAAK,SAAS,eAAe,KAAK,SAAS;AAExE,aAAK,IAAI,OAAO,gBAAgB,SAAS,IAAI;AAAA,UAC3C;AAAA,UACA;AAAA,UACA;AAAA,UACA,cAAc,KAAK,MAAM,YAAY;AAAA,UACrC,eAAe,eAAe,KAAK,aAAa,eAAe,KAAK,SAAS;AAAA,UAC7E,GAAG;AAAA,QACL,CAAC;AAAA,MACH;AAAA;AAAA;AAAA;AAAA,MAKA,gBACE,WACA,KACA,KACA,KACA,SACM;AACN,aAAK,MAAM,SAAS,MAAM,QAAQ,MAAM,KAAK,SAAS,IAAI;AAAA,UACxD;AAAA,UACA,UAAU;AAAA,UACV,UAAU;AAAA,UACV;AAAA,UACA,GAAG;AAAA,QACL,CAAC;AAAA,MACH;AAAA;AAAA;AAAA;AAAA,MAKA,MAAM,mBAA2C;AAC/C,cAAM,cAAc,IAAI,YAAW,KAAK,MAAM;AAG9C,cAAM,cAAc,YAAY,IAAI,KAAK,WAAW;AACpD,oBAAY,MAAM,CAChB,OACA,SACA,YACG;AACH,sBAAY,OAAO,SAAS,EAAE,GAAG,mBAAmB,GAAG,QAAQ,CAAC;AAAA,QAClE;AAEA,eAAO;AAAA,MACT;AAAA;AAAA;AAAA;AAAA,MAKA,cAAsB;AACpB,eAAO,KAAK,OAAO,WAAW;AAAA,MAChC;AAAA;AAAA;AAAA;AAAA,MAKA,UAAU,OAAqD;AAC7D,cAAM,eAAe,KAAK,UAAU,KAAK,OAAO,WAAW,QAAQ;AACnE,cAAM,cAAc,KAAK,UAAU,KAAK;AACxC,eAAO,YAAY,YAAY,aAAa;AAAA,MAC9C;AAAA,IACF;AAAA;AAAA;;;AC7MA;AAAA;;;ACAA;AAAA;;;ACAA;AAAA;;;ACAA;AAAA;AAWA;AACA;;;ACZA;AAAA;AAUO,IAAM,wBAAN,MAA4B;AAAA;AAAA,EAKjC,YACU,KACAC,SACAC,eACR;AAHQ;AACA,kBAAAD;AACA,wBAAAC;AAAA,EACP;AAAA,EAnBL,OAUmC;AAAA;AAAA;AAAA,EACzB,eAAyC,oBAAI,IAAI;AAAA,EACjD,cAAwC,oBAAI,IAAI;AAAA,EAChD,eAAuB;AAAA;AAAA;AAAA;AAAA,EAW/B,MAAM,eAAe,QAA6C;AAChE,QAAI;AAEF,YAAM,gBAAgB,KAAK,YAAY,IAAI,MAAM;AACjD,UAAI,iBAAiB,KAAK,eAAe,aAAa,GAAG;AACvD,eAAO;AAAA,MACT;AAGA,UAAI,CAAC,KAAK,oBAAoB,MAAM,GAAG;AACrC,aAAK,OAAO,KAAK,0BAA0B,EAAE,QAAQ,OAAO,UAAU,GAAG,CAAC,IAAI,MAAM,CAAC;AACrF,eAAO;AAAA,MACT;AAGA,YAAM,cAAc,MAAM,KAAK,IAAI,eAAe,IAAI,UAAU,MAAM,IAAI,MAAM;AAEhF,UAAI,CAAC,aAAa;AAChB,aAAK,OAAO,KAAK,qBAAqB,EAAE,QAAQ,OAAO,UAAU,GAAG,CAAC,IAAI,MAAM,CAAC;AAChF,eAAO;AAAA,MACT;AAGA,YAAM,UAAuB;AAAA,QAC3B,GAAG;AAAA,QACH,eAAc,oBAAI,KAAK,GAAE,YAAY;AAAA,MACvC;AAGA,YAAM,KAAK,kBAAkB,OAAO;AAGpC,WAAK,aAAa,IAAI,QAAQ,IAAI,OAAO;AACzC,WAAK,YAAY,IAAI,QAAQ,OAAO;AAEpC,WAAK,OAAO,KAAK,kCAAkC;AAAA,QACjD,QAAQ,QAAQ;AAAA,QAChB,WAAW,QAAQ;AAAA,QACnB,YAAY,QAAQ;AAAA,MACtB,CAAC;AAED,aAAO;AAAA,IAET,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,6BAA6B;AAAA,QAC7C,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAChD,QAAQ,OAAO,UAAU,GAAG,CAAC,IAAI;AAAA,MACnC,CAAC;AACD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBACJ,QACA,cAA+B,KAAK,sBAAsB,GACpC;AACtB,QAAI;AACF,YAAM,SAAS,OAAO,WAAW;AACjC,YAAM,OAAM,oBAAI,KAAK,GAAE,YAAY;AAEnC,YAAM,UAAuB;AAAA,QAC3B,IAAI;AAAA,QACJ;AAAA,QACA,WAAW;AAAA,QACX,YAAY,MAAQ,YAAY;AAAA;AAAA,QAChC,WAAW;AAAA,QACX,cAAc;AAAA,QACd;AAAA,MACF;AAGA,YAAM,QAAQ,IAAI;AAAA,QAChB,KAAK,IAAI,eAAe,IAAI,WAAW,MAAM,IAAI,KAAK,UAAU,OAAO,CAAC;AAAA,QACxE,KAAK,IAAI,eAAe,IAAI,UAAU,MAAM,IAAI,KAAK,UAAU,OAAO,CAAC;AAAA,QACvE,KAAK,IAAI,eAAe,IAAI,SAAS,MAAM,IAAI,KAAK,UAAU;AAAA,UAC5D,MAAM;AAAA,UACN,OAAO,QAAQ;AAAA,UACf,SAAS,KAAK,kBAAkB;AAAA,UAChC,aAAa;AAAA,QACf,CAAC,CAAC;AAAA,MACJ,CAAC;AAGD,WAAK,aAAa,IAAI,QAAQ,OAAO;AACrC,WAAK,YAAY,IAAI,QAAQ,OAAO;AAEpC,WAAK,OAAO,KAAK,wBAAwB;AAAA,QACvC;AAAA,QACA,YAAY,QAAQ;AAAA,QACpB;AAAA,MACF,CAAC;AAED,aAAO;AAAA,IAET,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,iCAAiC;AAAA,QACjD,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,QAAoC;AAC1D,QAAI;AAEF,YAAM,UAAU,KAAK,aAAa,IAAI,MAAM;AAC5C,UAAI,SAAS;AACX,eAAO;AAAA,UACL,MAAM,QAAQ;AAAA,UACd,OAAO,QAAQ;AAAA,UACf,SAAS,KAAK,kBAAkB;AAAA,UAChC,kBAAkB;AAAA,QACpB;AAAA,MACF;AAGA,YAAM,YAAY,MAAM,KAAK,IAAI,eAAe,IAAI,SAAS,MAAM,IAAI,MAAM;AAE7E,UAAI,CAAC,WAAW;AAEd,eAAO;AAAA,UACL,MAAM;AAAA,UACN,OAAO;AAAA,UACP,SAAS,KAAK,kBAAkB;AAAA,UAChC,kBAAkB;AAAA,QACpB;AAAA,MACF;AAEA,aAAO;AAAA,IAET,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,4BAA4B;AAAA,QAC5C;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AAGD,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO;AAAA,QACP,SAAS,KAAK,kBAAkB;AAAA,QAChC,kBAAkB;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,QAAgB,WAAuC;AAC5E,QAAI;AACF,YAAM,eAAe,MAAM,KAAK,kBAAkB,MAAM;AACxD,YAAM,WAAW,aAAa,OAAO;AAErC,YAAM,eAA0B;AAAA,QAC9B,GAAG;AAAA,QACH,MAAM;AAAA,QACN,cAAa,oBAAI,KAAK,GAAE,YAAY;AAAA,MACtC;AAGA,YAAM,KAAK,IAAI,eAAe,IAAI,SAAS,MAAM,IAAI,KAAK,UAAU,YAAY,CAAC;AAGjF,YAAM,UAAU,KAAK,aAAa,IAAI,MAAM;AAC5C,UAAI,SAAS;AACX,gBAAQ,YAAY;AACpB,gBAAQ,gBAAe,oBAAI,KAAK,GAAE,YAAY;AAAA,MAChD;AAGA,YAAM,kBAAmB,WAAW,aAAa,QAAS;AAC1D,UAAI,mBAAmB,aAAa,kBAAkB;AACpD,aAAK,OAAO,KAAK,uBAAuB;AAAA,UACtC;AAAA,UACA,MAAM;AAAA,UACN,OAAO,aAAa;AAAA,UACpB,YAAY,KAAK,MAAM,eAAe;AAAA,QACxC,CAAC;AAAA,MACH;AAEA,aAAO;AAAA,IAET,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,gCAAgC;AAAA,QAChD;AAAA,QACA;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,QAAgB,gBAAwB,GAAqB;AACnF,QAAI;AACF,YAAM,YAAY,MAAM,KAAK,kBAAkB,MAAM;AACrD,aAAQ,UAAU,OAAO,iBAAkB,UAAU;AAAA,IACvD,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,sCAAsC;AAAA,QACtD;AAAA,QACA;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,QAA+B;AAClD,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,eAAe,MAAM;AAChD,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC1C;AAEA,YAAM,aAAwB;AAAA,QAC5B,MAAM;AAAA,QACN,OAAO,QAAQ;AAAA,QACf,SAAS,KAAK,kBAAkB;AAAA,QAChC,cAAa,oBAAI,KAAK,GAAE,YAAY;AAAA,QACpC,kBAAkB;AAAA,MACpB;AAGA,YAAM,KAAK,IAAI,eAAe,IAAI,SAAS,MAAM,IAAI,KAAK,UAAU,UAAU,CAAC;AAG/E,UAAI,KAAK,aAAa,IAAI,MAAM,GAAG;AACjC,cAAM,gBAAgB,KAAK,aAAa,IAAI,MAAM;AAClD,sBAAc,YAAY;AAC1B,sBAAc,gBAAe,oBAAI,KAAK,GAAE,YAAY;AAAA,MACtD;AAEA,WAAK,OAAO,KAAK,oBAAoB;AAAA,QACnC;AAAA,QACA,UAAU,WAAW;AAAA,QACrB,WAAW,WAAW;AAAA,MACxB,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,8BAA8B;AAAA,QAC9C;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,QAA6C;AAChE,QAAI;AAEF,YAAM,gBAAgB,KAAK,aAAa,IAAI,MAAM;AAClD,UAAI,iBAAiB,KAAK,eAAe,aAAa,GAAG;AACvD,eAAO;AAAA,MACT;AAGA,YAAM,cAAc,MAAM,KAAK,IAAI,eAAe,IAAI,WAAW,MAAM,IAAI,MAAM;AAEjF,UAAI,aAAa;AAEf,aAAK,aAAa,IAAI,QAAQ,WAAW;AACzC,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,IAET,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,8BAA8B;AAAA,QAC9C;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,SAAqC;AAC3D,QAAI;AACF,cAAQ,gBAAe,oBAAI,KAAK,GAAE,YAAY;AAG9C,YAAM,QAAQ,IAAI;AAAA,QAChB,KAAK,IAAI,eAAe,IAAI,WAAW,QAAQ,EAAE,IAAI,KAAK,UAAU,OAAO,CAAC;AAAA,QAC5E,KAAK,IAAI,eAAe,IAAI,UAAU,QAAQ,MAAM,IAAI,KAAK,UAAU,OAAO,CAAC;AAAA,MACjF,CAAC;AAGD,WAAK,aAAa,IAAI,QAAQ,IAAI,OAAO;AACzC,WAAK,YAAY,IAAI,QAAQ,QAAQ,OAAO;AAAA,IAE9C,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,iCAAiC;AAAA,QACjD,QAAQ,QAAQ;AAAA,QAChB,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAkB,QAA+B;AACrD,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,eAAe,MAAM;AAChD,UAAI,CAAC,SAAS;AACZ;AAAA,MACF;AAGA,YAAM,QAAQ,IAAI;AAAA,QAChB,KAAK,IAAI,eAAe,OAAO,WAAW,MAAM,EAAE;AAAA,QAClD,KAAK,IAAI,eAAe,OAAO,UAAU,QAAQ,MAAM,EAAE;AAAA,QACzD,KAAK,IAAI,eAAe,OAAO,SAAS,MAAM,EAAE;AAAA,MAClD,CAAC;AAGD,WAAK,aAAa,OAAO,MAAM;AAC/B,WAAK,YAAY,OAAO,QAAQ,MAAM;AAEtC,WAAK,OAAO,KAAK,4BAA4B,EAAE,OAAO,CAAC;AAAA,IAEzD,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,gCAAgC;AAAA,QAChD;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,QAAyB;AAEnD,WAAO,uBAAuB,KAAK,MAAM;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,SAA+B;AACpD,UAAM,eAAe,IAAI,KAAK,QAAQ,YAAY;AAClD,UAAM,MAAM,oBAAI,KAAK;AACrB,UAAM,WAAW,IAAI,QAAQ,IAAI,aAAa,QAAQ;AAGtD,WAAO,WAAW,KAAK;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKQ,wBAAyC;AAC/C,WAAO;AAAA,MACL,aAAa;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA,sBAAsB;AAAA,MACtB,yBAAyB;AAAA,MACzB,iBAAiB;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAA4B;AAClC,UAAM,WAAW,oBAAI,KAAK;AAC1B,aAAS,WAAW,SAAS,WAAW,IAAI,CAAC;AAC7C,aAAS,YAAY,GAAG,GAAG,GAAG,CAAC;AAC/B,WAAO,SAAS,YAAY;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKQ,sBAA4B;AAClC,UAAM,MAAM,oBAAI,KAAK;AAErB,eAAW,CAAC,QAAQ,OAAO,KAAK,KAAK,aAAa,QAAQ,GAAG;AAC3D,UAAI,CAAC,KAAK,eAAe,OAAO,GAAG;AACjC,aAAK,aAAa,OAAO,MAAM;AAC/B,aAAK,YAAY,OAAO,QAAQ,MAAM;AAAA,MACxC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,eAKE;AACA,SAAK,oBAAoB;AAEzB,UAAM,WAAW,MAAM,KAAK,KAAK,aAAa,OAAO,CAAC;AACtD,UAAM,iBAAiB,SAAS,OAAO,CAAC,KAAK,YAAY,MAAM,QAAQ,WAAW,CAAC;AACnF,UAAM,oBAAoB,SAAS,SAAS,IAAI,iBAAiB,SAAS,SAAS;AAEnF,WAAO;AAAA,MACL,gBAAgB,SAAS,OAAO,OAAK,KAAK,eAAe,CAAC,CAAC,EAAE;AAAA,MAC7D,gBAAgB,SAAS;AAAA,MACzB;AAAA,MACA,mBAAmB,KAAK,MAAM,iBAAiB;AAAA,IACjD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAyB;AAE7B,SAAK,aAAa,MAAM;AACxB,SAAK,YAAY,MAAM;AAEvB,SAAK,OAAO,KAAK,mCAAmC;AAAA,EACtD;AACF;;;ACpdA;AAAA;AAUO,IAAM,8BAAN,MAAkC;AAAA,EAKvC,YACU,KACAC,SACAC,eACR;AAHQ;AACA,kBAAAD;AACA,wBAAAC;AAGR,SAAK,qBAAqB;AAAA,EAC5B;AAAA,EAtBF,OAUyC;AAAA;AAAA;AAAA,EAC/B,cAA6C,oBAAI,IAAI;AAAA,EACrD,oBAAkD,oBAAI,IAAI;AAAA,EAC1D,kBAAiC;AAAA;AAAA;AAAA;AAAA,EAczC,MAAM,mBAAmB,WAAmB,YAA6C;AACvF,QAAI;AAEF,WAAK,YAAY,IAAI,WAAW,UAAU;AAG1C,WAAK,kBAAkB,IAAI,WAAW;AAAA,QACpC;AAAA,QACA,aAAa,WAAW;AAAA,QACxB,cAAc,WAAW;AAAA,QACzB,cAAc;AAAA,QACd,kBAAkB;AAAA,QAClB,kBAAkB;AAAA,QAClB,QAAQ;AAAA,MACV,CAAC;AAGD,YAAM,KAAK,IAAI,eAAe;AAAA,QAC5B,cAAc,SAAS;AAAA,QACvB,KAAK,UAAU;AAAA,UACb;AAAA,UACA,aAAa,WAAW,YAAY,YAAY;AAAA,UAChD,UAAU,WAAW;AAAA,QACvB,CAAC;AAAA,QACD,EAAE,eAAe,MAAM;AAAA;AAAA,MACzB;AAEA,WAAK,OAAO,KAAK,yBAAyB;AAAA,QACxC;AAAA,QACA,kBAAkB,KAAK,YAAY;AAAA,QACnC,UAAU,WAAW;AAAA,MACvB,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,iCAAiC;AAAA,QACjD;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBAAqB,WAAkC;AAC3D,QAAI;AACF,YAAM,aAAa,KAAK,YAAY,IAAI,SAAS;AACjD,UAAI,CAAC,YAAY;AACf;AAAA,MACF;AAGA,YAAM,WAAW,KAAK,IAAI,IAAI,WAAW,YAAY,QAAQ;AAG7D,YAAM,UAAU,KAAK,kBAAkB,IAAI,SAAS;AAGpD,WAAK,YAAY,OAAO,SAAS;AACjC,WAAK,kBAAkB,OAAO,SAAS;AAGvC,YAAM,KAAK,IAAI,eAAe,OAAO,cAAc,SAAS,EAAE;AAE9D,WAAK,OAAO,KAAK,2BAA2B;AAAA,QAC1C;AAAA,QACA;AAAA,QACA,kBAAkB,KAAK,YAAY;AAAA,QACnC,cAAc;AAAA,MAChB,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,mCAAmC;AAAA,QACnD;AAAA,QACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,WAA4C;AACxD,WAAO,KAAK,YAAY,IAAI,SAAS,KAAK;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAwC;AACtC,WAAO,MAAM,KAAK,KAAK,YAAY,OAAO,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB,WAAyB;AAChD,UAAM,aAAa,KAAK,YAAY,IAAI,SAAS;AACjD,UAAM,UAAU,KAAK,kBAAkB,IAAI,SAAS;AAEpD,QAAI,YAAY;AACd,iBAAW,WAAW,oBAAI,KAAK;AAAA,IACjC;AAEA,QAAI,SAAS;AACX,cAAQ,eAAe,oBAAI,KAAK;AAAA,IAClC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,WAAmB,cAAsB,GAAS;AACjE,UAAM,UAAU,KAAK,kBAAkB,IAAI,SAAS;AACpD,QAAI,SAAS;AACX,cAAQ;AACR,cAAQ,oBAAoB;AAC5B,cAAQ,eAAe,oBAAI,KAAK;AAAA,IAClC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB,WAAmB,cAAsB,GAAS;AACrE,UAAM,UAAU,KAAK,kBAAkB,IAAI,SAAS;AACpD,QAAI,SAAS;AACX,cAAQ;AACR,cAAQ,oBAAoB;AAC5B,cAAQ,eAAe,oBAAI,KAAK;AAAA,IAClC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB,WAAmB,OAAoB;AAC1D,UAAM,UAAU,KAAK,kBAAkB,IAAI,SAAS;AACpD,QAAI,SAAS;AACX,cAAQ;AAAA,IACV;AAEA,SAAK,OAAO,KAAK,4BAA4B;AAAA,MAC3C;AAAA,MACA,OAAO,MAAM;AAAA,MACb,aAAa,SAAS,UAAU;AAAA,IAClC,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,qBAOE;AACA,UAAM,MAAM,oBAAI,KAAK;AACrB,UAAM,UAAU,MAAM,KAAK,KAAK,kBAAkB,OAAO,CAAC;AAE1D,UAAM,oBAAoB,QAAQ;AAAA,MAAO,OACvC,IAAI,QAAQ,IAAI,EAAE,aAAa,QAAQ,IAAI;AAAA;AAAA,IAC7C,EAAE;AAEF,UAAM,gBAAgB,QAAQ,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,eAAe,EAAE,kBAAkB,CAAC;AAC7F,UAAM,aAAa,QAAQ,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,kBAAkB,CAAC;AACzE,UAAM,cAAc,QAAQ,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,QAAQ,CAAC;AAEhE,UAAM,kBAAkB,QAAQ,IAAI,OAAK,IAAI,QAAQ,IAAI,EAAE,YAAY,QAAQ,CAAC;AAChF,UAAM,wBAAwB,gBAAgB,SAAS,IACnD,gBAAgB,OAAO,CAAC,KAAK,SAAS,MAAM,MAAM,CAAC,IAAI,gBAAgB,SACvE;AAEJ,UAAM,YAAY,gBAAgB,IAAK,cAAc,gBAAiB,MAAM;AAE5E,WAAO;AAAA,MACL,kBAAkB,KAAK,YAAY;AAAA,MACnC;AAAA,MACA,uBAAuB,KAAK,MAAM,qBAAqB;AAAA,MACvD;AAAA,MACA;AAAA,MACA,WAAW,KAAK,MAAM,YAAY,GAAG,IAAI;AAAA,IAC3C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB,UAKF;AACrB,UAAM,MAAM,oBAAI,KAAK;AAErB,WAAO,KAAK,kBAAkB,EAAE,OAAO,gBAAc;AAEnD,UAAI,SAAS,YAAY,WAAW,SAAS,aAAa,SAAS,UAAU;AAC3E,eAAO;AAAA,MACT;AAGA,UAAI,SAAS,aAAa,CAAC,WAAW,SAAS,WAAW,SAAS,SAAS,SAAS,GAAG;AACtF,eAAO;AAAA,MACT;AAGA,UAAI,SAAS,kBAAkB;AAC7B,cAAM,gBAAgB,IAAI,QAAQ,IAAI,WAAW,YAAY,QAAQ;AACrE,YAAI,gBAAgB,SAAS,kBAAkB;AAC7C,iBAAO;AAAA,QACT;AAAA,MACF;AAGA,UAAI,SAAS,aAAa;AACxB,cAAM,WAAW,IAAI,QAAQ,IAAI,WAAW,SAAS,QAAQ;AAC7D,YAAI,WAAW,SAAS,aAAa;AACnC,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,UAKH;AAClB,QAAI,cAAc;AAClB,UAAM,SAAS,SAAS,UAAU;AAElC,QAAI;AACF,UAAI,qBAAyC,CAAC;AAE9C,UAAI,SAAS,YAAY;AAEvB,6BAAqB,SAAS,WAC3B,IAAI,QAAM,KAAK,YAAY,IAAI,EAAE,CAAC,EAClC,OAAO,OAAO;AAAA,MACnB,OAAO;AAEL,6BAAqB,KAAK,yBAAyB,QAAQ;AAAA,MAC7D;AAEA,iBAAW,cAAc,oBAAoB;AAC3C,YAAI;AACF,qBAAW,UAAU,MAAM,KAAM,MAAM;AACvC,gBAAM,KAAK,qBAAqB,WAAW,SAAS;AACpD;AAAA,QACF,SAAS,OAAO;AACd,eAAK,OAAO,KAAK,8BAA8B;AAAA,YAC7C,WAAW,WAAW;AAAA,YACtB,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,UAClD,CAAC;AAAA,QACH;AAAA,MACF;AAEA,WAAK,OAAO,KAAK,mCAAmC;AAAA,QAClD;AAAA,QACA,kBAAkB,KAAK,YAAY;AAAA,QACnC;AAAA,MACF,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,+BAA+B;AAAA,QAC/C,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAChD;AAAA,MACF,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAA6B;AAEnC,SAAK,kBAAkB,YAAY,MAAM;AACvC,WAAK,wBAAwB;AAAA,IAC/B,GAAG,GAAM;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,0BAAyC;AACrD,UAAM,cAAc;AACpB,UAAM,mBAAmB,KAAK,yBAAyB,EAAE,YAAY,CAAC;AAEtE,QAAI,iBAAiB,SAAS,GAAG;AAC/B,WAAK,OAAO,KAAK,iCAAiC;AAAA,QAChD,YAAY,iBAAiB;AAAA,QAC7B;AAAA,MACF,CAAC;AAED,YAAM,KAAK,iBAAiB;AAAA,QAC1B,YAAY,iBAAiB,IAAI,OAAK,EAAE,SAAS;AAAA,QACjD,QAAQ;AAAA,MACV,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,sBAA4B;AAClC,QAAI,KAAK,iBAAiB;AACxB,oBAAc,KAAK,eAAe;AAClC,WAAK,kBAAkB;AAAA,IACzB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAyB;AAC7B,SAAK,OAAO,KAAK,uCAAuC;AAGxD,SAAK,oBAAoB;AAGzB,UAAM,KAAK,iBAAiB;AAAA,MAC1B,YAAY,MAAM,KAAK,KAAK,YAAY,KAAK,CAAC;AAAA,MAC9C,QAAQ;AAAA,IACV,CAAC;AAGD,SAAK,YAAY,MAAM;AACvB,SAAK,kBAAkB,MAAM;AAE7B,SAAK,OAAO,KAAK,yCAAyC;AAAA,EAC5D;AACF;;;ACrXA;AAAA;AA6BO,IAAM,4BAAN,MAAgC;AAAA,EAIrC,YACU,KACAC,SACAC,eACA,aACA,mBACR;AALQ;AACA,kBAAAD;AACA,wBAAAC;AACA;AACA;AAER,SAAK,qBAAqB;AAAA,EAC5B;AAAA,EAzCF,OA6BuC;AAAA;AAAA;AAAA,EAC7B,cAA6C,oBAAI,IAAI;AAAA,EACrD,kBAA2G,oBAAI,IAAI;AAAA;AAAA;AAAA;AAAA,EAe3H,MAAM,cAAc,SAAqC;AACvD,QAAI;AAEF,YAAM,gBAAgB,QAAQ,QAAQ,IAAI,SAAS;AACnD,UAAI,kBAAkB,aAAa;AACjC,eAAO,IAAI,SAAS,8BAA8B,EAAE,QAAQ,IAAI,CAAC;AAAA,MACnE;AAGA,YAAM,gBAAgB,IAAI,cAAc;AACxC,YAAM,CAAC,QAAQ,MAAM,IAAI,OAAO,OAAO,aAAa;AAGpD,YAAM,KAAK,gBAAgB,QAAQ,OAAO;AAG1C,aAAO,IAAI,SAAS,MAAM;AAAA,QACxB,QAAQ;AAAA,QACR,WAAW;AAAA,MACb,CAAQ;AAAA,IAEV,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,4BAA4B;AAAA,QAC5C,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,aAAO,KAAK,aAAa,oBAAoB,KAAK,4BAA4B,YAAY;AAAA,IAC5F;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,WAAgC,SAAiC;AAE7F,UAAM,WAAW;AAAA,MACf,WAAW,QAAQ,QAAQ,IAAI,YAAY,KAAK;AAAA,MAChD,WAAW,QAAQ,QAAQ,IAAI,kBAAkB,KAAK;AAAA,MACtD,eAAe,QAAQ,QAAQ,IAAI,kBAAkB,KAAK;AAAA,MAC1D,UAAU,QAAQ,QAAQ,IAAI,mBAAmB,KAAK;AAAA,IACxD;AAGA,UAAM,iBAA4C;AAAA,MAChD;AAAA,MACA,aAAa,oBAAI,KAAK;AAAA,MACtB,UAAU,oBAAI,KAAK;AAAA,MACnB,eAAe,oBAAI,IAAI;AAAA,MACvB;AAAA,IACF;AAGA,cAAU,iBAAiB,WAAW,OAAO,UAAwB;AACnE,YAAM,KAAK,cAAc,OAAO,cAAkC;AAAA,IACpE,CAAC;AAED,cAAU,iBAAiB,SAAS,OAAO,UAAsB;AAC/D,YAAM,KAAK,oBAAoB,gBAAoC,MAAM,MAAM,MAAM,MAAM;AAAA,IAC7F,CAAC;AAED,cAAU,iBAAiB,SAAS,OAAO,UAAiB;AAC1D,WAAK,OAAO,MAAM,mBAAmB;AAAA,QACnC,WAAW,eAAe;AAAA,QAC1B,OAAO;AAAA,MACT,CAAC;AAAA,IACH,CAAC;AAGD,UAAM,KAAK,cAAc,SAAS;AAElC,SAAK,OAAO,KAAK,iCAAiC,EAAE,SAAS,CAAC;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,cAAc,WAA+C;AACzE,UAAM,YAA8B;AAAA,MAClC,IAAI,OAAO,WAAW;AAAA,MACtB,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,QACN,eAAe;AAAA,QACf,iBAAiB;AAAA,QACjB,cAAc,CAAC,SAAS,aAAa,iBAAiB,WAAW;AAAA,QACjE,cAAc;AAAA,MAChB;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,cAAU,KAAK,KAAK,UAAU,SAAS,CAAC;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,cAAc,OAAqB,YAA6C;AAC5F,QAAI;AACF,YAAM,OAAO,KAAK,MAAM,MAAM,IAAc;AAG5C,iBAAW,WAAW,oBAAI,KAAK;AAG/B,YAAM,UAAU,KAAK,gBAAgB,IAAI,KAAK,UAAU,KAAK,IAAI;AACjE,UAAI,SAAS;AACX,cAAM,QAAQ,MAAM,UAAU;AAAA,MAChC,OAAO;AACL,cAAM,KAAK,qBAAqB,MAAM,UAAU;AAAA,MAClD;AAAA,IAEF,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,sCAAsC;AAAA,QACtD,WAAW,WAAW;AAAA,QACtB,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AAED,YAAM,KAAK,UAAU,WAAW,WAAW,mBAAmB,2BAA2B,EAAE;AAAA,IAC7F;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAA6B;AACnC,SAAK,gBAAgB,IAAI,gBAAgB,KAAK,qBAAqB,KAAK,IAAI,CAAC;AAC7E,SAAK,gBAAgB,IAAI,QAAQ,KAAK,WAAW,KAAK,IAAI,CAAC;AAC3D,SAAK,gBAAgB,IAAI,QAAQ,KAAK,WAAW,KAAK,IAAI,CAAC;AAC3D,SAAK,gBAAgB,IAAI,cAAc,KAAK,gBAAgB,KAAK,IAAI,CAAC;AACtE,SAAK,gBAAgB,IAAI,cAAc,KAAK,eAAe,KAAK,IAAI,CAAC;AACrE,SAAK,gBAAgB,IAAI,aAAa,KAAK,gBAAgB,KAAK,IAAI,CAAC;AACrE,SAAK,gBAAgB,IAAI,eAAe,KAAK,kBAAkB,KAAK,IAAI,CAAC;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,qBAAqB,SAA2B,YAA6C;AACzG,QAAI;AACF,YAAM,cAAc,QAAQ;AAG5B,YAAM,UAAU,MAAM,KAAK,YAAY,eAAe,YAAY,MAAM;AACxE,UAAI,CAAC,SAAS;AACZ,cAAM,KAAK,iBAAiB,WAAW,WAAW;AAAA,UAChD,SAAS;AAAA,UACT,OAAO;AAAA,UACP,YAAY;AAAA,YACV,SAAS;AAAA,YACT,cAAc,CAAC;AAAA,YACf,aAAa,EAAE,MAAM,GAAG,OAAO,GAAG,SAAS,IAAI,kBAAkB,GAAG;AAAA,UACtE;AAAA,QACF,GAAG,QAAQ,EAAE;AACb;AAAA,MACF;AAGA,iBAAW,YAAY,QAAQ;AAG/B,YAAM,KAAK,kBAAkB,mBAAmB,QAAQ,IAAI,UAAU;AACtE,WAAK,YAAY,IAAI,QAAQ,IAAI,UAAU;AAG3C,YAAM,YAAY,MAAM,KAAK,YAAY,kBAAkB,QAAQ,EAAE;AACrE,YAAM,KAAK,iBAAiB,WAAW,WAAW;AAAA,QAChD,SAAS;AAAA,QACT;AAAA,QACA,YAAY;AAAA,UACV,SAAS;AAAA,UACT,cAAc,CAAC,SAAS,aAAa,iBAAiB,WAAW;AAAA,UACjE,aAAa;AAAA,QACf;AAAA,MACF,GAAG,QAAQ,EAAE;AAEb,WAAK,OAAO,KAAK,qCAAqC;AAAA,QACpD,WAAW,QAAQ;AAAA,QACnB,YAAY,YAAY;AAAA,MAC1B,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,yBAAyB;AAAA,QACzC,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,YAAM,KAAK,UAAU,WAAW,WAAW,eAAe,yBAAyB,QAAQ,EAAE;AAAA,IAC/F;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,WAAW,SAA2B,YAA6C;AAC/F,UAAM,OAAyB;AAAA,MAC7B,IAAI,OAAO,WAAW;AAAA,MACtB,MAAM;AAAA,MACN,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,eAAW,UAAU,KAAK,KAAK,UAAU,IAAI,CAAC;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,WAAW,SAA2B,YAA6C;AAE/F,eAAW,WAAW,oBAAI,KAAK;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,SAA2B,YAA6C;AACpG,QAAI;AACF,UAAI,CAAC,WAAW,WAAW;AACzB,cAAM,KAAK,UAAU,WAAW,WAAW,qBAAqB,2BAA2B,QAAQ,EAAE;AACrG;AAAA,MACF;AAGA,YAAM,QAAyB,CAAC;AAEhC,YAAM,WAA6B;AAAA,QACjC,IAAI,QAAQ;AAAA,QACZ,MAAM;AAAA,QACN,QAAQ,EAAE,MAAM;AAAA,QAChB,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAEA,iBAAW,UAAU,KAAK,KAAK,UAAU,QAAQ,CAAC;AAAA,IAEpD,SAAS,OAAO;AACd,YAAM,KAAK;AAAA,QACT,WAAW;AAAA,QACX;AAAA,QACA,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,QAAQ;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,eAAe,SAA2B,YAA6C;AACnG,QAAI;AACF,UAAI,CAAC,WAAW,WAAW;AACzB,cAAM,KAAK,UAAU,WAAW,WAAW,qBAAqB,2BAA2B,QAAQ,EAAE;AACrG;AAAA,MACF;AAGA,YAAM,SAAS,EAAE,SAAS,qCAAqC;AAE/D,YAAM,WAA6B;AAAA,QACjC,IAAI,QAAQ;AAAA,QACZ,MAAM;AAAA,QACN;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAEA,iBAAW,UAAU,KAAK,KAAK,UAAU,QAAQ,CAAC;AAAA,IAEpD,SAAS,OAAO;AACd,YAAM,KAAK;AAAA,QACT,WAAW;AAAA,QACX;AAAA,QACA,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,QAAQ;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,SAA2B,YAA6C;AACpG,QAAI;AACF,YAAM,EAAE,SAAS,IAAI,QAAQ;AAE7B,UAAI,CAAC,WAAW,WAAW;AACzB,cAAM,KAAK,UAAU,WAAW,WAAW,qBAAqB,2BAA2B,QAAQ,EAAE;AACrG;AAAA,MACF;AAEA,iBAAW,cAAc,IAAI,QAAQ;AAErC,YAAM,WAA6B;AAAA,QACjC,IAAI,QAAQ;AAAA,QACZ,MAAM;AAAA,QACN,QAAQ,EAAE,YAAY,SAAS;AAAA,QAC/B,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAEA,iBAAW,UAAU,KAAK,KAAK,UAAU,QAAQ,CAAC;AAElD,WAAK,OAAO,KAAK,sCAAsC;AAAA,QACrD,WAAW,WAAW;AAAA,QACtB;AAAA,MACF,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,YAAM,KAAK;AAAA,QACT,WAAW;AAAA,QACX;AAAA,QACA,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,QAAQ;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,kBAAkB,SAA2B,YAA6C;AACtG,QAAI;AACF,YAAM,EAAE,SAAS,IAAI,QAAQ;AAE7B,UAAI,CAAC,WAAW,WAAW;AACzB,cAAM,KAAK,UAAU,WAAW,WAAW,qBAAqB,2BAA2B,QAAQ,EAAE;AACrG;AAAA,MACF;AAEA,iBAAW,cAAc,OAAO,QAAQ;AAExC,YAAM,WAA6B;AAAA,QACjC,IAAI,QAAQ;AAAA,QACZ,MAAM;AAAA,QACN,QAAQ,EAAE,cAAc,SAAS;AAAA,QACjC,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MACpC;AAEA,iBAAW,UAAU,KAAK,KAAK,UAAU,QAAQ,CAAC;AAAA,IAEpD,SAAS,OAAO;AACd,YAAM,KAAK;AAAA,QACT,WAAW;AAAA,QACX;AAAA,QACA,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACzC,QAAQ;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,qBAAqB,SAA2B,YAA6C;AACzG,UAAM,KAAK;AAAA,MACT,WAAW;AAAA,MACX;AAAA,MACA,mBAAmB,QAAQ,MAAM;AAAA,MACjC,QAAQ;AAAA,IACV;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,oBAAoB,YAA8B,MAAc,QAA+B;AAC3G,QAAI,WAAW,WAAW;AACxB,WAAK,YAAY,OAAO,WAAW,SAAS;AAC5C,YAAM,KAAK,kBAAkB,qBAAqB,WAAW,SAAS;AAEtE,WAAK,OAAO,KAAK,uBAAuB;AAAA,QACtC,WAAW,WAAW;AAAA,QACtB;AAAA,QACA;AAAA,QACA,UAAU,KAAK,IAAI,IAAI,WAAW,YAAY,QAAQ;AAAA,MACxD,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAiB,WAAgC,UAAwB,WAAkC;AACvH,UAAM,UAA4B;AAAA,MAChC,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,cAAU,KAAK,KAAK,UAAU,OAAO,CAAC;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,UAAU,WAAgC,MAAc,SAAiB,WAAkC;AACvH,UAAM,eAAiC;AAAA,MACrC,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,OAAO;AAAA,QACL;AAAA,QACA;AAAA,MACF;AAAA,MACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,cAAU,KAAK,KAAK,UAAU,YAAY,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,OAAgC;AACnD,UAAM,oBAAoB,MAAM,KAAK,cACjC,MAAM,KAAK,YAAY,IAAI,YAAU,KAAK,YAAY,IAAI,MAAM,CAAC,EAAE,OAAO,OAAO,IACjF,MAAM,KAAK,KAAK,YAAY,OAAO,CAAC;AAExC,UAAM,UAA4B;AAAA,MAChC,IAAI,OAAO,WAAW;AAAA,MACtB,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,IACpC;AAEA,UAAM,aAAa,KAAK,UAAU,OAAO;AAEzC,eAAW,cAAc,mBAAmB;AAC1C,UAAI,YAAY;AACd,YAAI;AACF,qBAAW,UAAU,KAAK,UAAU;AAAA,QACtC,SAAS,OAAO;AACd,eAAK,OAAO,KAAK,kCAAkC;AAAA,YACjD,WAAW,WAAW;AAAA,YACtB,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,UAClD,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,qBAIE;AACA,UAAM,gBAAgB,MAAM,KAAK,KAAK,YAAY,OAAO,CAAC,EAAE,OAAO,OAAK,EAAE,SAAS;AACnF,UAAM,gBAAwC,CAAC;AAE/C,eAAW,cAAc,eAAe;AACtC,iBAAW,OAAO,WAAW,eAAe;AAC1C,sBAAc,GAAG,KAAK,cAAc,GAAG,KAAK,KAAK;AAAA,MACnD;AAAA,IACF;AAEA,WAAO;AAAA,MACL,kBAAkB,KAAK,YAAY;AAAA,MACnC,0BAA0B,cAAc;AAAA,MACxC;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,sBAAqC;AACzC,eAAW,cAAc,KAAK,YAAY,OAAO,GAAG;AAClD,UAAI;AACF,mBAAW,UAAU,MAAM,MAAM,sBAAsB;AAAA,MACzD,SAAS,OAAO;AAAA,MAEhB;AAAA,IACF;AACA,SAAK,YAAY,MAAM;AAAA,EACzB;AACF;;;AHlfA;;;AIpBA;AAAA;;;ACAA;AAAA;AAwCO,IAAM,gBAAgB;AAAA,EAC3B,aAAa;AAAA,EACb,iBAAiB;AAAA,EACjB,kBAAkB;AAAA,EAClB,gBAAgB;AAAA,EAChB,gBAAgB;AAAA,EAChB,cAAc;AAAA,EACd,gBAAgB;AAAA,EAChB,uBAAuB;AAAA,EACvB,sBAAsB;AAAA,EACtB,gBAAgB;AAAA,EAChB,cAAc;AAAA,EACd,mBAAmB;AAAA,EACnB,oBAAoB;AAAA,EACpB,aAAa;AAAA,EACb,qBAAqB;AACvB;;;AD9BO,IAAM,mBAAN,MAAuB;AAAA,EA1B9B,OA0B8B;AAAA;AAAA;AAAA,EACpB;AAAA,EAER,YAAYC,SAAoB;AAC9B,SAAK,SAASA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,oBACE,MACA,SACA,KAAoB,MACpB,SACU;AACV,UAAM,gBAAgB;AAAA,MACpB,SAAS;AAAA,MACT;AAAA,MACA,OAAO;AAAA,QACL,MAAM,KAAK,sBAAsB,IAAI;AAAA,QACrC;AAAA,QACA,MAAM,UAAU,EAAE,QAAQ,IAAI;AAAA,MAChC;AAAA,IACF;AAEA,SAAK,OAAO,MAAM,+BAA+B;AAAA,MAC/C,UAAU;AAAA,MACV,SAAS,cAAc,MAAM;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAED,WAAO,IAAI,SAAS,KAAK,UAAU,aAAa,GAAG;AAAA,MACjD,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,+BAA+B;AAAA,QAC/B,gCAAgC;AAAA,QAChC,gCAAgC;AAAA,MAClC;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,uBACE,MACA,SACA,KAA6B,MAC7B,MACA;AACA,UAAM,gBAAgB;AAAA,MACpB,SAAS;AAAA,MACT;AAAA,MACA,OAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,SAAK,OAAO,MAAM,8BAA8B;AAAA,MAC9C;AAAA,MACA;AAAA,MACA;AAAA,MACA,WAAW;AAAA,IACb,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UACJ,IACA,SACY;AACZ,QAAI;AACF,aAAO,MAAM,GAAG;AAAA,IAClB,SAAS,OAAO;AACd,WAAK,YAAY,OAAO,OAAO;AAC/B,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,SACE,IACA,SACG;AACH,QAAI;AACF,aAAO,GAAG;AAAA,IACZ,SAAS,OAAO;AACd,WAAK,YAAY,OAAO,OAAO;AAC/B,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,OAAgB,SAAsC;AAChE,UAAM,eAAe,KAAK,oBAAoB,OAAO,OAAO;AAE5D,SAAK,OAAO,MAAM,iBAAiB;AAAA,MACjC,MAAM,aAAa;AAAA,MACnB,SAAS,aAAa;AAAA,MACtB,SAAS,aAAa;AAAA,MACtB,SAAS,aAAa;AAAA,MACtB,OAAO,aAAa;AAAA,IACtB,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,OAAgB,SAAsC;AAChF,QAAI,OAAO;AACX,QAAI,UAAU;AACd,QAAI;AACJ,QAAI;AAEJ,QAAI,iBAAiB,OAAO;AAC1B,gBAAU,MAAM;AAChB,cAAQ,MAAM;AAGd,UAAI,MAAM,SAAS,mBAAmB;AACpC,eAAO;AAAA,MACT,WAAW,MAAM,SAAS,mBAAmB,MAAM,SAAS,qBAAqB;AAC/E,eAAO;AAAA,MACT,WAAW,MAAM,SAAS,uBAAuB;AAC/C,eAAO;AAAA,MACT,WAAW,MAAM,SAAS,sBAAsB;AAC9C,eAAO;AAAA,MACT,WAAW,MAAM,SAAS,kBAAkB;AAC1C,eAAO;AAAA,MACT,WAAW,MAAM,SAAS,0BAA0B;AAElD,cAAM,eAAe;AACrB,eAAO,aAAa,QAAQ;AAC5B,kBAAU,aAAa;AAAA,MACzB,WAAW,MAAM,SAAS,+BAA+B;AACvD,eAAO;AACP,kBAAU;AAAA,MACZ;AAAA,IACF,WAAW,OAAO,UAAU,UAAU;AACpC,gBAAU;AAAA,IACZ,WAAW,SAAS,OAAO,UAAU,UAAU;AAC7C,YAAM,WAAW;AACjB,gBAAU,SAAS,WAAW,SAAS,SAAS;AAChD,aAAO,SAAS,QAAQ,SAAS,UAAU;AAC3C,gBAAU,SAAS;AAAA,IACrB;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,sBAAsB,UAAgC;AAC5D,YAAQ,UAAU;AAAA,MAChB,KAAK;AACH,eAAO,cAAc;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA;AAAA,MACvB,KAAK;AACH,eAAO,cAAc;AAAA;AAAA,MACvB;AACE,eAAO,cAAc;AAAA,IACzB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,OAAyB;AACxC,UAAM,UAAU,KAAK,oBAAoB,KAAK;AAG9C,UAAM,iBAAiB,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG;AAEpD,WAAO,eAAe,SAAS,QAAQ,IAAI;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,SAAiB,YAAoB,KAAM,WAAmB,KAAe;AACzF,UAAM,QAAQ,KAAK,IAAI,YAAY,KAAK,IAAI,GAAG,OAAO,GAAG,QAAQ;AAEjE,UAAM,SAAS,KAAK,OAAO,IAAI,MAAM;AACrC,WAAO,KAAK,MAAM,QAAQ,MAAM;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UACJ,IACA,aAAqB,GACrB,YAAoB,KACpB,SACY;AACZ,QAAI;AAEJ,aAAS,UAAU,GAAG,WAAW,YAAY,WAAW;AACtD,UAAI;AACF,eAAO,MAAM,GAAG;AAAA,MAClB,SAAS,OAAO;AACd,oBAAY;AAEZ,YAAI,YAAY,cAAc,CAAC,KAAK,iBAAiB,KAAK,GAAG;AAC3D,eAAK,YAAY,OAAO,EAAE,GAAG,SAAS,UAAU,EAAE,SAAS,WAAW,EAAE,CAAC;AACzE,gBAAM;AAAA,QACR;AAEA,cAAM,QAAQ,KAAK,cAAc,SAAS,SAAS;AAEnD,aAAK,OAAO,KAAK,wBAAwB;AAAA,UACvC,SAAS,UAAU;AAAA,UACnB;AAAA,UACA;AAAA,UACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,UAC5D;AAAA,QACF,CAAC;AAED,cAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,KAAK,CAAC;AAAA,MACzD;AAAA,IACF;AAEA,UAAM;AAAA,EACR;AAAA;AAAA;AAAA;AAAA,EAKA,0BAA0B,OAAwB;AAChD,UAAM,UAAU,KAAK,oBAAoB,KAAK;AAE9C,YAAQ,QAAQ,MAAM;AAAA,MACpB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,OAAgB,eAAwB,OAA8B;AAClF,UAAM,UAAU,KAAK,oBAAoB,KAAK;AAE9C,WAAO;AAAA,MACL,MAAM,QAAQ;AAAA,MACd,SAAS,QAAQ;AAAA,MACjB,SAAS,QAAQ;AAAA,MACjB,GAAI,gBAAgB,EAAE,OAAO,QAAQ,MAAM;AAAA,IAC7C;AAAA,EACF;AACF;;;AE5UA;AAAA;AAqBO,IAAM,mBAAN,MAAkD;AAAA,EArBzD,OAqByD;AAAA;AAAA;AAAA,EAC/C,QAA8B,oBAAI,IAAI;AAAA,EACtC;AAAA,EACA;AAAA,EACA,cAAuB;AAAA,EAE/B,YAAY,QAA8BC,SAAoB;AAC5D,SAAK,SAAS;AACd,SAAK,SAASA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAA4B;AAChC,QAAI;AAEF,YAAM,KAAK,qBAAqB;AAEhC,WAAK,cAAc;AACnB,WAAK,OAAO,KAAK,6BAA6B;AAAA,QAC5C,WAAW,KAAK,MAAM;AAAA,QACtB,OAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AAAA,MACrC,CAAC;AAAA,IACH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,sCAAsC;AAAA,QACtD,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC9D,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,MAAqB;AAE5B,UAAM,aAAa,KAAK,aAAa,IAAI;AACzC,QAAI,CAAC,WAAW,OAAO;AACrB,YAAM,eAAe,WAAW,OAAO,IAAI,OAAK,EAAE,OAAO,EAAE,KAAK,IAAI;AACpE,YAAM,IAAI,MAAM,4BAA4B,YAAY,EAAE;AAAA,IAC5D;AAGA,QAAI,KAAK,MAAM,IAAI,KAAK,IAAI,GAAG;AAC7B,WAAK,OAAO,KAAK,6BAA6B,EAAE,UAAU,KAAK,KAAK,CAAC;AAAA,IACvE;AAEA,SAAK,MAAM,IAAI,KAAK,MAAM,IAAI;AAC9B,SAAK,OAAO,KAAK,mBAAmB;AAAA,MAClC,UAAU,KAAK;AAAA,MACf,aAAa,KAAK;AAAA,IACpB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,UAA2B;AACpC,UAAM,UAAU,KAAK,MAAM,IAAI,QAAQ;AACvC,SAAK,MAAM,OAAO,QAAQ;AAE1B,QAAI,SAAS;AACX,WAAK,OAAO,KAAK,qBAAqB,EAAE,SAAS,CAAC;AAAA,IACpD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAuC;AACzC,WAAO,KAAK,MAAM,IAAI,QAAQ;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAkB;AAChB,WAAO,MAAM,KAAK,KAAK,MAAM,OAAO,CAAC;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAA2B;AAC7B,WAAO,KAAK,MAAM,IAAI,QAAQ;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACZ,UAAM,YAAY,KAAK,MAAM;AAC7B,SAAK,MAAM,MAAM;AACjB,SAAK,OAAO,KAAK,qBAAqB,EAAE,cAAc,UAAU,CAAC;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKA,QAAgB;AACd,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAiC;AAC/B,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,YAAmF;AACjF,WAAO,KAAK,KAAK,EAAE,IAAI,WAAS;AAAA,MAC9B,MAAM,KAAK;AAAA,MACX,aAAa,KAAK;AAAA,MAClB,aAAa,KAAK;AAAA,IACpB,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YACJ,UACA,OACA,SAC0B;AAC1B,UAAM,YAAY,KAAK,IAAI;AAE3B,SAAK,OAAO,KAAK,kBAAkB;AAAA,MACjC;AAAA,MACA,WAAW,QAAQ;AAAA,MACnB,QAAQ,QAAQ,MAAM;AAAA,IACxB,CAAC;AAED,QAAI;AAEF,YAAM,OAAO,KAAK,MAAM,IAAI,QAAQ;AACpC,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,kBAAkB,SAAS,QAAQ,aAAa;AAAA,MAC5D;AAGA,YAAM,aAAa,KAAK,cAAc,KAAK,aAAa,KAAK;AAC7D,UAAI,CAAC,WAAW,OAAO;AACrB,cAAM,eAAe,WAAW,OAAO,IAAI,OAAK,GAAG,EAAE,IAAI,KAAK,EAAE,OAAO,EAAE,EAAE,KAAK,IAAI;AACpF,cAAM,IAAI,gBAAgB,4BAA4B,YAAY,EAAE;AAAA,MACtE;AAGA,YAAM,SAAS,MAAM,KAAK,QAAQ,OAAO,OAAO;AAEhD,YAAM,gBAAgB,KAAK,IAAI,IAAI;AACnC,WAAK,OAAO,KAAK,8BAA8B;AAAA,QAC7C;AAAA,QACA;AAAA,QACA,WAAW,QAAQ;AAAA,MACrB,CAAC;AAED,aAAO;AAAA,IAET,SAAS,OAAO;AACd,YAAM,gBAAgB,KAAK,IAAI,IAAI;AAEnC,WAAK,OAAO,MAAM,yBAAyB;AAAA,QACzC;AAAA,QACA;AAAA,QACA,WAAW,QAAQ;AAAA,QACnB,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC9D,CAAC;AAGD,UAAI,iBAAiB,mBAAmB;AACtC,cAAM,IAAI,aAAa,cAAc,gBAAgB,MAAM,OAAO;AAAA,MACpE;AAEA,UAAI,iBAAiB,iBAAiB;AACpC,cAAM,IAAI,aAAa,cAAc,mBAAmB,MAAM,OAAO;AAAA,MACvE;AAEA,UAAI,iBAAiB,cAAc;AACjC,cAAM;AAAA,MACR;AAGA,YAAM,IAAI;AAAA,QACR,cAAc;AAAA,QACd,0BAA0B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,MAClF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,MAAoC;AACvD,UAAM,SAAiE,CAAC;AAGxE,QAAI,CAAC,KAAK,QAAQ,OAAO,KAAK,SAAS,UAAU;AAC/C,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,MACR,CAAC;AAAA,IACH,WAAW,CAAC,0BAA0B,KAAK,KAAK,IAAI,GAAG;AACrD,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAGA,QAAI,CAAC,KAAK,eAAe,OAAO,KAAK,gBAAgB,UAAU;AAC7D,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAGA,QAAI,CAAC,KAAK,eAAe,OAAO,KAAK,gBAAgB,UAAU;AAC7D,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAGA,QAAI,CAAC,KAAK,WAAW,OAAO,KAAK,YAAY,YAAY;AACvD,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,MACL,OAAO,OAAO,WAAW;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,cAAc,QAAoB,OAAqC;AAC7E,UAAM,SAAiE,CAAC;AAExE,QAAI;AAEF,UAAI,OAAO,MAAM;AACf,cAAM,aAAa,KAAK,YAAY,KAAK;AACzC,YAAI,OAAO,SAAS,YAAY;AAC9B,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,SAAS,kBAAkB,OAAO,IAAI,WAAW,UAAU;AAAA,YAC3D,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAAA,MACF;AAGA,UAAI,OAAO,SAAS,YAAY,OAAO,YAAY,OAAO,UAAU,YAAY,UAAU,MAAM;AAC9F,cAAM,MAAM;AACZ,mBAAW,gBAAgB,OAAO,UAAU;AAC1C,cAAI,EAAE,gBAAgB,MAAM;AAC1B,mBAAO,KAAK;AAAA,cACV,MAAM;AAAA,cACN,SAAS,sBAAsB,YAAY;AAAA,cAC3C,MAAM;AAAA,YACR,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAGA,UAAI,OAAO,QAAQ,CAAC,OAAO,KAAK,SAAS,KAAK,GAAG;AAC/C,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,SAAS,yBAAyB,OAAO,KAAK,IAAI,OAAK,KAAK,UAAU,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC;AAAA,UACpF,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAGA,UAAI,OAAO,SAAS,YAAY,OAAO,UAAU,UAAU;AACzD,YAAI,OAAO,cAAc,UAAa,MAAM,SAAS,OAAO,WAAW;AACrE,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,SAAS,kCAAkC,OAAO,SAAS;AAAA,YAC3D,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AACA,YAAI,OAAO,cAAc,UAAa,MAAM,SAAS,OAAO,WAAW;AACrE,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,SAAS,iCAAiC,OAAO,SAAS;AAAA,YAC1D,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAAA,MACF;AAGA,UAAI,OAAO,SAAS,YAAY,OAAO,UAAU,UAAU;AACzD,YAAI,OAAO,YAAY,UAAa,QAAQ,OAAO,SAAS;AAC1D,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,SAAS,2BAA2B,OAAO,OAAO;AAAA,YAClD,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AACA,YAAI,OAAO,YAAY,UAAa,QAAQ,OAAO,SAAS;AAC1D,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,SAAS,0BAA0B,OAAO,OAAO;AAAA,YACjD,MAAM;AAAA,UACR,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IAEF,SAAS,OAAO;AACd,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS,qBAAqB,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QACpF,MAAM;AAAA,MACR,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,MACL,OAAO,OAAO,WAAW;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,OAAwB;AAC1C,QAAI,UAAU,KAAM,QAAO;AAC3B,QAAI,MAAM,QAAQ,KAAK,EAAG,QAAO;AACjC,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAA0B,QAAqD;AACrF,QAAI,OAAO,SAAS,EAAG,QAAO;AAE9B,UAAM,SAAS,OAAO,IAAI,OAAK,EAAE,gBAAgB;AACjD,UAAM,OAAO,OAAO,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC,IAAI,OAAO;AACpE,UAAM,WAAW,OAAO,OAAO,CAAC,KAAK,UAAU,MAAM,KAAK,IAAI,QAAQ,MAAM,CAAC,GAAG,CAAC,IAAI,OAAO;AAC5F,UAAM,oBAAoB,KAAK,KAAK,QAAQ;AAI5C,UAAM,yBAAyB,OAAO,IAAI,oBAAoB,OAAO;AACrE,UAAM,mBAAmB,KAAK,IAAI,GAAG,MAAO,yBAAyB,GAAI;AAEzE,WAAO,KAAK,MAAM,mBAAmB,GAAG,IAAI;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAAuB,UAA0B;AACvD,UAAM,QAAQ,SAAS,MAAM,qCAAqC;AAClE,QAAI,CAAC,MAAO,QAAO;AAEnB,UAAM,QAAQ,SAAS,MAAM,CAAC,KAAK,GAAG;AACtC,UAAM,UAAU,SAAS,MAAM,CAAC,KAAK,GAAG;AACxC,UAAM,UAAU,SAAS,MAAM,CAAC,KAAK,GAAG;AAExC,WAAO,QAAQ,OAAO,UAAU,KAAK;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKQ,yBACN,UACA,eACA,0BACA,eACU;AACV,UAAM,YAAsB,CAAC;AAE7B,QAAI,WAAW,IAAQ,WAAU,KAAK,iBAAiB;AACvD,QAAI,gBAAgB,EAAG,WAAU,KAAK,sBAAsB;AAAA,aACnD,gBAAgB,EAAG,WAAU,KAAK,iBAAiB;AAE5D,QAAI,2BAA2B,GAAI,WAAU,KAAK,2BAA2B;AAAA,aACpE,2BAA2B,GAAI,WAAU,KAAK,4BAA4B;AAEnF,QAAI,gBAAgB,EAAG,WAAU,KAAK,wBAAwB;AAAA,aACrD,gBAAgB,EAAG,WAAU,KAAK,6BAA6B;AAExE,QAAI,UAAU,WAAW,EAAG,WAAU,KAAK,oBAAoB;AAE/D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,8BAA8B,cAKpC;AACA,QAAI,OAAO,GAAG,SAAS,GAAG,MAAM;AAChC,UAAM,kBAAkB,aAAa,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,iBAAiB,CAAC;AAElF,iBAAa,QAAQ,WAAS;AAC5B,UAAI,MAAM,kBAAkB,EAAG;AAAA,eACtB,MAAM,kBAAkB,EAAG;AAAA,UAC/B;AAAA,IACP,CAAC;AAED,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,mBAAmB,aAAa,SAAS,IACvC,KAAK,MAAO,kBAAkB,aAAa,SAAU,GAAK,IAAI,MAAQ;AAAA,IAC1E;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,6BAA6B,iBAInC;AACA,UAAM,gBAAgB,gBAAgB,OAAO,OAAK,CAAC,EAAE,SAAS,EAAE,WAAW;AAE3E,QAAI,cAAc,WAAW,GAAG;AAC9B,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,UAAU,CAAC;AAAA,QACX,UAAU,CAAC,8BAA8B;AAAA,MAC3C;AAAA,IACF;AAGA,UAAM,iBAAiB,cAAc,IAAI,aAAW;AAClD,YAAM,OAAO,QAAQ;AAGrB,YAAM,YAAY,KAAK,IAAI,KAAK,eAAe,MAAS,IAAI,EAAE;AAC9D,YAAM,kBAAkB,KAAK,IAAI,KAAK,wBAAwB,GAAG,EAAE;AACnE,YAAM,mBAAmB,QAAQ,qBAC9B,QAAQ,mBAAmB,cAAc,MAAO,KAAK;AACxD,YAAM,iBAAiB,KAAK,IAAI,KAAK,gBAAgB,GAAG,EAAE;AAE1D,YAAM,aAAa,YAAY,kBAAkB,mBAAmB;AAEpE,aAAO;AAAA,QACL;AAAA,QACA,OAAO,KAAK,MAAM,aAAa,GAAG,IAAI;AAAA,MACxC;AAAA,IACF,CAAC;AAGD,mBAAe,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK;AAE/C,UAAM,WAAW,eAAe,IAAI,CAAC,MAAM,WAAW;AAAA,MACpD,MAAM,QAAQ;AAAA,MACd,SAAS,KAAK;AAAA,MACd,OAAO,KAAK;AAAA,IACd,EAAE;AAEF,UAAM,SAAS,SAAS,CAAC;AAGzB,UAAM,WAAqB,CAAC;AAE5B,QAAI,QAAQ;AACV,eAAS,KAAK,GAAG,OAAO,QAAQ,QAAQ,KAAK,0BAA0B,OAAO,KAAK,EAAE;AAErF,YAAM,eAAe,cAAc;AAAA,QAAO,CAAC,MAAM,SAC/C,KAAK,YAAY,eAAe,KAAK,YAAY,eAAe,OAAO;AAAA,MACzE;AACA,eAAS,KAAK,0BAA0B,aAAa,QAAQ,KAAK,KAAK,aAAa,YAAY,aAAa,eAAe,CAAC,GAAG;AAEhI,YAAM,cAAc,cAAc;AAAA,QAAO,CAAC,MAAM,SAC9C,KAAK,YAAY,wBAAwB,KAAK,YAAY,wBAAwB,OAAO;AAAA,MAC3F;AACA,eAAS,KAAK,yBAAyB,YAAY,QAAQ,KAAK,KAAK,YAAY,YAAY,qBAAqB,IAAI;AAEtH,YAAM,iBAAiB,cAAc;AAAA,QAAO,CAAC,MAAM,SACjD,KAAK,YAAY,gBAAgB,KAAK,YAAY,gBAAgB,OAAO;AAAA,MAC3E;AACA,eAAS,KAAK,8BAA8B,eAAe,QAAQ,KAAK,KAAK,eAAe,YAAY,aAAa,eAAe;AAAA,IACtI;AAEA,WAAO;AAAA,MACL,QAAQ,SAAS,OAAO,UAAU;AAAA,MAClC;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,SAAyB;AACnD,UAAM,QAAQ,KAAK,MAAM,UAAU,IAAI;AACvC,UAAM,UAAU,KAAK,MAAO,UAAU,OAAQ,EAAE;AAChD,UAAM,OAAO,UAAU;AAEvB,QAAI,QAAQ,GAAG;AACb,aAAO,GAAG,KAAK,IAAI,QAAQ,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC,IAAI,KAAK,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,IAC5F;AACA,WAAO,GAAG,OAAO,IAAI,KAAK,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAKQ,sBACN,UACA,OACA,aACA,MAOA;AACA,UAAM,gBAA0B,CAAC;AACjC,QAAI,eAAe;AACnB,QAAI,qBAAqB;AACzB,QAAI,aAAa;AAEjB,UAAM,aAAa,MAAM,YAAY;AACrC,UAAM,mBAAmB,YAAY,YAAY;AACjD,UAAM,YAAY,KAAK,IAAI,SAAO,IAAI,YAAY,CAAC;AAEnD,aAAS,QAAQ,CAAC,YAAoB;AACpC,YAAM,eAAe,QAAQ,YAAY;AACzC,UAAI,QAAQ;AAGZ,UAAI,WAAW,SAAS,YAAY,GAAG;AACrC;AACA,gBAAQ;AAAA,MACV;AAGA,UAAI,iBAAiB,SAAS,YAAY,GAAG;AAC3C;AACA,gBAAQ;AAAA,MACV;AAGA,UAAI,UAAU,KAAK,SAAO,IAAI,SAAS,YAAY,CAAC,GAAG;AACrD;AACA,gBAAQ;AAAA,MACV;AAEA,UAAI,OAAO;AACT,sBAAc,KAAK,OAAO;AAAA,MAC5B;AAAA,IACF,CAAC;AAGD,UAAM,qBAAqB,SAAS;AACpC,UAAM,aAAa,qBAAqB,IAAK,eAAe,qBAAsB,KAAK;AACvF,UAAM,mBAAmB,qBAAqB,IAAK,qBAAqB,qBAAsB,KAAK;AACnG,UAAM,WAAW,qBAAqB,IAAK,aAAa,qBAAsB,KAAK;AAEnF,UAAM,iBAAiB,aAAa,mBAAmB;AAEvD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,gBAAgB,KAAK,MAAM,iBAAiB,GAAG,IAAI;AAAA,IACrD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,8BACN,UACA,cACA,SAKA;AACA,UAAM,kBAA4B,CAAC;AAGnC,QAAI,aAA4B;AAChC,QAAI,WAAW;AAEf,WAAO,QAAQ,YAAY,EAAE,QAAQ,CAAC,CAAC,SAAS,KAAK,MAAM;AACzD,UAAI,MAAM,QAAQ,UAAU;AAC1B,mBAAW,MAAM;AACjB,qBAAa;AAAA,MACf;AAAA,IACF,CAAC;AAGD,UAAM,iBAAiB,QAAQ,OAAO,CAAC,KAAK,WAAW,MAAM,OAAO,gBAAgB,gBAAgB,CAAC;AACrG,UAAM,wBAAwB,QAAQ,SAAS,IAC7C,KAAK,MAAO,iBAAiB,QAAQ,SAAU,GAAG,IAAI,MAAM;AAG9D,QAAI,QAAQ,WAAW,GAAG;AACxB,sBAAgB,KAAK,mEAAmE;AAAA,IAC1F,OAAO;AACL,UAAI,wBAAwB,IAAI;AAC9B,wBAAgB,KAAK,oFAAoF;AAAA,MAC3G;AAEA,UAAI,YAAY;AACd,wBAAgB,KAAK,IAAI,UAAU,gDAAgD,QAAQ,WAAW;AAAA,MACxG;AAEA,YAAM,sBAAsB,QAAQ,OAAO,OAAK,EAAE,gBAAgB,iBAAiB,EAAE,EAAE;AACvF,UAAI,sBAAsB,GAAG;AAC3B,wBAAgB,KAAK,GAAG,mBAAmB,+CAA+C;AAAA,MAC5F;AAGA,YAAM,2BAA2B,SAAS,OAAO,OAAK,aAAa,EAAE,YAAY,CAAC,EAAE,QAAQ,CAAC;AAC7F,UAAI,yBAAyB,SAAS,GAAG;AACvC,wBAAgB,KAAK,kCAAkC,yBAAyB,KAAK,MAAM,CAAC,0BAA0B;AAAA,MACxH;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,sBAAsB,MAAwB;AACpD,UAAM,SAAmB,CAAC;AAC1B,UAAM,YAAY,KAAK,YAAY;AAGnC,UAAM,gBAAgB;AAAA,MACpB;AAAA,MAAU;AAAA,MAAS;AAAA,MAAQ;AAAA,MAAc;AAAA,MAAM;AAAA,MAAY;AAAA,MAAU;AAAA,MACrE;AAAA,MAAW;AAAA,MAAW;AAAA,MAAW;AAAA,MAAU;AAAA,MAAQ;AAAA,MAAU;AAAA,MAAQ;AAAA,MACrE;AAAA,MAAU;AAAA,MAAa;AAAA,MAAW;AAAA,MAAU;AAAA,MAAU;AAAA,MAAW;AAAA,MAAO;AAAA,MACxE;AAAA,MAAU;AAAA,MAAc;AAAA,MAAa;AAAA,MAAY;AAAA,MAAW;AAAA,MAC5D;AAAA,MAAc;AAAA,MAAa;AAAA,MAAQ;AAAA,MAAU;AAAA,MAAS;AAAA,MAAQ;AAAA,MAAM;AAAA,MACpE;AAAA,MAAa;AAAA,MAAY;AAAA,MAAY;AAAA,MAAU;AAAA,MAAW;AAAA,MAAS;AAAA,MACnE;AAAA,MAAU;AAAA,MAAU;AAAA,MAAe;AAAA,MAAO;AAAA,MAAU;AAAA,MAAO;AAAA,MAAO;AAAA,IACpE;AAEA,kBAAc,QAAQ,aAAW;AAC/B,UAAI,UAAU,SAAS,OAAO,GAAG;AAC/B,eAAO,KAAK,OAAO;AAAA,MACrB;AAAA,IACF,CAAC;AAED,WAAO,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKQ,yBACN,WACA,kBACA,kBACA,gBACU;AACV,UAAM,cAAwB,CAAC;AAG/B,QAAI,UAAU,SAAS,GAAG;AACxB,YAAM,gBAAgB,UAAU,CAAC;AACjC,kBAAY,KAAK,IAAI,cAAc,KAAK,gCAAgC,cAAc,SAAS,yBAAyB;AAExH,UAAI,UAAU,SAAS,GAAG;AACxB,oBAAY,KAAK,oBAAoB,UAAU,MAAM,GAAG,CAAC,EAAE,IAAI,OAAK,EAAE,KAAK,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,MAC3F;AAAA,IACF;AAGA,UAAM,cAAc,iBAAiB,QAAQ,iBAAiB,SAAS,iBAAiB;AACxF,QAAI,cAAc,GAAG;AACnB,YAAM,kBAAmB,iBAAiB,QAAQ,cAAe;AACjE,YAAM,mBAAoB,iBAAiB,SAAS,cAAe;AAEnE,UAAI,kBAAkB,IAAI;AACxB,oBAAY,KAAK,iGAAiG;AAAA,MACpH,WAAW,mBAAmB,IAAI;AAChC,oBAAY,KAAK,sGAAsG;AAAA,MACzH,OAAO;AACL,oBAAY,KAAK,uGAAuG;AAAA,MAC1H;AAAA,IACF;AAGA,QAAI,iBAAiB,SAAS,GAAG;AAC/B,YAAM,UAAU,iBAAiB,CAAC;AAClC,kBAAY,KAAK,yBAAyB,QAAQ,IAAI,YAAY,QAAQ,UAAU,2CAA2C;AAAA,IACjI;AAGA,UAAM,uBAAuB,eAAe,OAAO,OAAK,EAAE,WAAW,iBAAiB,CAAC,EAAE;AACzF,QAAI,uBAAuB,eAAe,SAAS,KAAK;AACtD,kBAAY,KAAK,6FAA6F;AAAA,IAChH;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,2BACN,WACA,kBACQ;AACR,QAAI,UAAU,WAAW,GAAG;AAC1B,aAAO;AAAA,IACT;AAEA,UAAM,gBAAgB,iBAAiB,QAAQ,iBAAiB,SAAS,iBAAiB;AAC1F,UAAM,iBAAiB,gBAAgB,IACpC,iBAAiB,QAAQ,KAAK,IAAI,iBAAiB,QAAQ,iBAAiB,IAAI,IAAI,UACpF,iBAAiB,SAAS,iBAAiB,OAAO,WAAW,SAAU;AAE1E,UAAM,gBAAgB,UAAU,CAAC,EAAE;AAEnC,WAAO,GAAG,cAAc,SAAS,aAAa;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKQ,sBACN,cACA,kBACA,UACA,WACU;AACV,UAAM,WAAqB,CAAC;AAE5B,QAAI,aAAa,WAAW,GAAG;AAC7B,eAAS,KAAK,0DAA0D;AACxE,aAAO;AAAA,IACT;AAGA,UAAM,WAAW,aAAa,CAAC;AAC/B,aAAS,KAAK,4BAA4B,SAAS,MAAM,KAAK,mBAAmB,SAAS,QAAQ,UAAU,GAAG;AAG/G,QAAI,iBAAiB,SAAS,GAAG;AAC/B,YAAM,aAAa,iBAAiB,CAAC;AACrC,eAAS,KAAK,oCAAoC,WAAW,OAAO,iBAAiB,WAAW,SAAS,UAAU;AAAA,IACrH;AAGA,UAAM,uBAAuB,aAAa,OAAO,OAAK,EAAE,QAAQ,iBAAiB,CAAC;AAClF,QAAI,qBAAqB,SAAS,GAAG;AACnC,eAAS,KAAK,GAAG,qBAAqB,MAAM,6CAA6C;AAAA,IAC3F;AAGA,UAAM,eAAe,aAAa,OAAO,OAAK,EAAE,QAAQ,sBAAsB,CAAC;AAC/E,QAAI,aAAa,SAAS,aAAa,SAAS,KAAK;AACnD,eAAS,KAAK,6EAA6E;AAAA,IAC7F;AAGA,QAAI,UAAU;AACZ,eAAS,KAAK,GAAG,QAAQ,mDAAmD,SAAS,YAAY;AAAA,IACnG;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,6BACN,kBACA,gBACA,WACU;AACV,UAAM,kBAA4B,CAAC;AAEnC,QAAI,iBAAiB,SAAS,GAAG;AAC/B,YAAM,cAAc,iBAAiB,MAAM,GAAG,CAAC,EAAE,IAAI,OAAK,EAAE,OAAO,EAAE,KAAK,IAAI;AAC9E,sBAAgB,KAAK,qDAAqD,WAAW,EAAE;AAAA,IACzF;AAEA,QAAI,eAAe,SAAS,GAAG;AAC7B,YAAM,iBAAiB,eAAe,MAAM,GAAG,CAAC,EAAE,IAAI,OAAK,EAAE,OAAO,EAAE,KAAK,IAAI;AAC/E,sBAAgB,KAAK,uBAAuB,cAAc,6CAA6C;AAAA,IACzG;AAEA,QAAI,cAAc,OAAO;AACvB,sBAAgB,KAAK,+EAA+E;AAAA,IACtG,WAAW,cAAc,OAAO;AAC9B,sBAAgB,KAAK,sFAAsF;AAAA,IAC7G;AAEA,QAAI,gBAAgB,WAAW,GAAG;AAChC,sBAAgB,KAAK,+EAA+E;AAAA,IACtG;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAA0B,SAAc,cAA0B;AACxE,UAAM,QAAQ,QAAQ;AACtB,UAAM,kBAAkB,SAAS,OAAO,mBAAmB,GAAG;AAC9D,UAAM,YAAY,SAAS,OAAO,aAAa,GAAG;AAClD,UAAM,aAAa,SAAS,OAAO,cAAc,GAAG;AAGpD,UAAM,mBAAmB,aAAa,IAAI,KAAK,MAAM,YAAY,UAAU,IAAI;AAC/E,UAAM,wBAAwB,kBAAkB,IAAI,KAAK,MAAM,YAAY,eAAe,IAAI;AAG9F,QAAI,oBAAoB;AACxB,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,mBAAmB,aAAa,OAAO,CAAC,KAAK,UAAU,MAAM,SAAS,MAAM,YAAY,aAAa,GAAG,GAAG,CAAC;AAClH,YAAM,iBAAiB,KAAK,MAAM,mBAAmB,aAAa,MAAM;AACxE,YAAM,mBAAmB,aAAa,OAAO,CAAC,KAAK,UAAU,MAAM,SAAS,MAAM,YAAY,aAAa,GAAG,GAAG,CAAC;AAClH,YAAM,gBAAgB,mBAAmB,IAAI,KAAK,MAAO,mBAAmB,mBAAoB,GAAK,IAAI,MAAM;AAE/G,0BAAoB;AAAA,QAClB,sBAAsB;AAAA,QACtB,mBAAmB;AAAA,QACnB,sBAAsB,mBAAmB,IAAI,KAAK,MAAO,iBAAiB,mBAAoB,GAAG,IAAI;AAAA,MACvG;AAAA,IACF;AAGA,UAAM,mBAAmB;AAAA,MACvB,wBAAwB,aAAa,IAAI,KAAK,MAAM,kBAAkB,UAAU,IAAI;AAAA,MACpF,uBAAuB;AAAA,MACvB,kBAAkB,KAAK,yBAAyB,YAAY;AAAA,IAC9D;AAEA,WAAO;AAAA,MACL,gBAAgB;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU,KAAK,wBAAwB,OAAO,mBAAmB,gBAAgB;AAAA,IACnF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,gCAAgC,OAAe,aAA+B;AACpF,UAAM,UAAoB,CAAC;AAG3B,UAAM,aAAa,MAAM,YAAY,EAAE,MAAM,KAAK,EAAE,OAAO,UAAQ,KAAK,SAAS,CAAC;AAClF,QAAI,WAAW,SAAS,GAAG;AACzB,cAAQ,KAAK,WAAW,MAAM,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC;AAAA,IAC/C;AAGA,UAAM,SAAS,KAAK,sBAAsB,WAAW;AACrD,WAAO,MAAM,GAAG,CAAC,EAAE,QAAQ,WAAS;AAClC,UAAI,CAAC,QAAQ,SAAS,KAAK,GAAG;AAC5B,gBAAQ,KAAK,KAAK;AAAA,MACpB;AAAA,IACF,CAAC;AAGD,YAAQ,KAAK,oBAAoB,iBAAiB;AAElD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,gBAAqB,eAAyB,kBAAwC;AAClH,UAAM,cAAqB,CAAC;AAC5B,QAAI,YAAY;AAEhB,eAAW,SAAS,eAAe;AACjC,UAAI;AACF,cAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU;AAAA,UACnE,MAAM;AAAA,UACN,MAAM;AAAA,UACN,GAAG;AAAA,UACH,YAAY;AAAA,QACd,CAAC;AACD,qBAAa;AAEb,YAAI,eAAe,OAAO;AACxB,gBAAM,aAAa,eAAe,MAC/B,IAAI,CAAC,SAAc,KAAK,GAAG,SAAS,EACpC,OAAO,CAAC,OAAe,OAAO,gBAAgB,EAC9C,MAAM,GAAG,CAAC;AAEb,cAAI,WAAW,SAAS,GAAG;AACzB,kBAAM,mBAAmB,MAAM,eAAe,eAAe,YAAY;AAAA,cACvE,MAAM;AAAA,cACN,IAAI,WAAW,KAAK,GAAG;AAAA,YACzB,CAAC;AACD,yBAAa;AAEb,gBAAI,iBAAiB,OAAO;AAC1B,+BAAiB,MAAM,QAAQ,CAAC,YAAiB;AAC/C,4BAAY,KAAK;AAAA,kBACf,IAAI,QAAQ;AAAA,kBACZ,OAAO,QAAQ,QAAQ;AAAA,kBACvB,iBAAiB,SAAS,QAAQ,YAAY,mBAAmB,GAAG;AAAA,kBACpE,YAAY,SAAS,QAAQ,YAAY,cAAc,GAAG;AAAA,kBAC1D,WAAW,SAAS,QAAQ,YAAY,aAAa,GAAG;AAAA,gBAC1D,CAAC;AAAA,cACH,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AAEd;AAAA,MACF;AAAA,IACF;AAGA,UAAM,oBAAoB,YACvB,OAAO,CAAC,MAAM,OAAO,SAAS,KAAK,UAAU,OAAK,EAAE,OAAO,KAAK,EAAE,MAAM,KAAK,EAC7E,KAAK,CAAC,GAAG,MAAM,EAAE,kBAAkB,EAAE,eAAe,EACpD,MAAM,GAAG,CAAC;AAEb,WAAO;AAAA,MACL,aAAa;AAAA,MACb,UAAU,KAAK,mBAAmB,iBAAiB;AAAA,MACnD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,+BAA+B,iBAAsB,cAAqB,oBAAmC;AACnH,UAAM,kBAA4B,CAAC;AACnC,UAAM,WAAW,gBAAgB;AACjC,UAAM,SAAS,gBAAgB;AAG/B,QAAI,UAAU,OAAO,uBAAuB,IAAI;AAC9C,sBAAgB,KAAK,uGAAuG;AAAA,IAC9H;AAEA,QAAI,SAAS,SAAS,gBAAgB,GAAG;AACvC,sBAAgB,KAAK,yFAAyF;AAAA,IAChH;AAEA,QAAI,SAAS,SAAS,sBAAsB,GAAG;AAC7C,sBAAgB,KAAK,mFAAmF;AAAA,IAC1G;AAGA,UAAM,UAAU,gBAAgB;AAChC,QAAI,QAAQ,wBAAwB,IAAI;AACtC,sBAAgB,KAAK,uGAAuG;AAAA,IAC9H;AAEA,QAAI,QAAQ,kBAAkB,OAAQ,QAAQ,mBAAmB,QAAQ,kBAAkB,KAAK;AAC9F,sBAAgB,KAAK,6FAA6F;AAAA,IACpH;AAGA,QAAI,sBAAsB,mBAAmB,YAAY,SAAS,GAAG;AACnE,YAAM,oBAAoB,mBAAmB,YAAY,OAAO,CAAC,KAAa,SAAc,MAAM,KAAK,iBAAiB,CAAC,IAAI,mBAAmB,YAAY;AAE5J,UAAI,QAAQ,kBAAkB,oBAAoB,KAAK;AACrD,wBAAgB,KAAK,oGAAoG;AAAA,MAC3H;AAAA,IACF;AAGA,QAAI,aAAa,SAAS,GAAG;AAC3B,YAAM,cAAc,aAAa,OAAO,CAAC,KAAK,UAAU,MAAM,KAAK,uBAAuB,MAAM,gBAAgB,YAAY,MAAM,GAAG,CAAC,IAAI,aAAa;AAEvJ,UAAI,cAAc,KAAK;AACrB,wBAAgB,KAAK,yFAAyF;AAAA,MAChH,WAAW,cAAc,MAAM;AAC7B,wBAAgB,KAAK,8EAA8E;AAAA,MACrG;AAAA,IACF;AAEA,QAAI,gBAAgB,WAAW,GAAG;AAChC,sBAAgB,KAAK,yFAAyF;AAAA,IAChH;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,cAA6B;AAC5D,QAAI,aAAa,SAAS,EAAG,QAAO;AAEpC,UAAM,QAAQ,aACX,IAAI,WAAS,IAAI,KAAK,MAAM,QAAQ,WAAW,CAAC,EAChD,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,IAAI,EAAE,QAAQ,CAAC;AAE3C,QAAI,YAAY;AAChB,aAAS,IAAI,GAAG,IAAI,MAAM,SAAS,GAAG,KAAK;AACzC,oBAAc,MAAM,CAAC,EAAE,QAAQ,IAAI,MAAM,IAAI,CAAC,EAAE,QAAQ,MAAM,MAAO,KAAK,KAAK;AAAA,IACjF;AAEA,UAAM,iBAAiB,aAAa,MAAM,SAAS;AAEnD,QAAI,kBAAkB,IAAK,QAAO;AAClC,QAAI,kBAAkB,IAAK,QAAO;AAClC,QAAI,kBAAkB,IAAK,QAAO;AAClC,QAAI,kBAAkB,GAAI,QAAO;AACjC,QAAI,kBAAkB,GAAI,QAAO;AACjC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,wBAAwB,OAAY,mBAAwB,kBAAiC;AACnG,UAAM,WAAqB,CAAC;AAC5B,UAAM,kBAAkB,SAAS,OAAO,mBAAmB,GAAG;AAC9D,UAAM,aAAa,SAAS,OAAO,cAAc,GAAG;AAGpD,QAAI,kBAAkB,KAAM;AAC1B,eAAS,KAAK,0DAA0D;AAAA,IAC1E,WAAW,kBAAkB,KAAO;AAClC,eAAS,KAAK,8DAA8D;AAAA,IAC9E,WAAW,kBAAkB,KAAQ;AACnC,eAAS,KAAK,gEAAgE;AAAA,IAChF,OAAO;AACL,eAAS,KAAK,2DAA2D;AAAA,IAC3E;AAGA,QAAI,qBAAqB,kBAAkB,oBAAoB,GAAG;AAChE,eAAS,KAAK,gBAAgB;AAAA,IAChC,WAAW,qBAAqB,kBAAkB,oBAAoB,GAAG;AACvE,eAAS,KAAK,0BAA0B;AAAA,IAC1C;AAGA,QAAI,iBAAiB,qBAAqB,aAAa;AACrD,eAAS,KAAK,sBAAsB;AAAA,IACtC,WAAW,iBAAiB,qBAAqB,SAAS;AACxD,eAAS,KAAK,wBAAwB;AAAA,IACxC;AAGA,QAAI,iBAAiB,wBAAwB,IAAI;AAC/C,eAAS,KAAK,wBAAwB;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAmB,aAAyB;AAClD,QAAI,YAAY,WAAW,GAAG;AAC5B,aAAO,EAAE,SAAS,oCAAoC;AAAA,IACxD;AAEA,UAAM,YAAY,YAAY,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,iBAAiB,CAAC;AACjF,UAAM,UAAU,KAAK,MAAM,YAAY,YAAY,MAAM;AACzD,UAAM,gBAAgB,YAAY,CAAC;AAEnC,WAAO;AAAA,MACL,SAAS,SAAS,YAAY,MAAM;AAAA,MACpC,oBAAoB;AAAA,MACpB,eAAe;AAAA,QACb,OAAO,cAAc;AAAA,QACrB,aAAa,cAAc;AAAA,MAC7B;AAAA,MACA,kBAAkB,UAAU,MAAS,SAAS,UAAU,MAAQ,WAAW;AAAA,IAC7E;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,uBAAsC;AAElD,UAAM,eAA0B;AAAA,MAC9B;AAAA,QACE,MAAM;AAAA,QACN,aAAa;AAAA,QACb,aAAa;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACV,UAAU;AAAA,cACR,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,UAAU;AAAA,cACR,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,cACT,SAAS;AAAA,YACX;AAAA,UACF;AAAA,UACA,UAAU,CAAC,UAAU;AAAA,UACrB,sBAAsB;AAAA,QACxB;AAAA,QACA,SAAS,8BAAO,OAAgB,YAAkD;AAChF,cAAI;AAEF,kBAAM,EAAE,gBAAAC,gBAAe,IAAI,MAAM;AACjC,kBAAM,EAAE,sBAAAC,sBAAqB,IAAI,MAAM;AACvC,kBAAM,EAAE,YAAAC,YAAW,IAAI,MAAM;AAG7B,kBAAM,iBAAiB;AAGvB,kBAAM,MAAO,QAAgB;AAC7B,gBAAI,CAAC,KAAK;AACR,oBAAM,IAAI,MAAM,gDAAgD;AAAA,YAClE;AAGA,kBAAM,SAAS,IAAID,sBAAqB,GAAG;AAC3C,kBAAM,OAAO,WAAW;AAExB,kBAAMF,UAAS,IAAIG,YAAW,OAAO,iBAAiB,CAAC;AACvD,kBAAM,iBAAiB,IAAIF,gBAAe,QAAQD,SAAQ,GAAG;AAG7D,kBAAM,aAAa,MAAM,eAAe;AAAA,cACtC,eAAe;AAAA,cACf,eAAe,YAAY;AAAA,YAC7B;AAGA,kBAAM,WAAW;AAAA,cACf,SAAS,WAAW;AAAA,cACpB,OAAO,wBAAwB,WAAW,OAAO;AAAA,cACjD,UAAU,WAAW;AAAA,cACrB,iBAAiB,WAAW;AAAA,cAC5B,YAAY;AAAA,gBACV,UAAU,WAAW;AAAA,gBACrB,UAAU,WAAW;AAAA,gBACrB,WAAW,WAAW;AAAA,gBACtB,sBAAsB,WAAW;AAAA,cACnC;AAAA,YACF;AAEA,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,cACxC,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UAEF,SAAS,OAAO;AACd,kBAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAE1E,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,gCAAgC,YAAY;AAAA,cACpD,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF,GA9DS;AAAA,MA+DX;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,aAAa;AAAA,QACb,aAAa;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACV,KAAK;AAAA,cACH,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,gBAAgB;AAAA,cACd,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,YACA,mBAAmB;AAAA,cACjB,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,UACF;AAAA,UACA,UAAU,CAAC,KAAK;AAAA,UAChB,sBAAsB;AAAA,QACxB;AAAA,QACA,SAAS,8BAAO,OAAgB,YAAkD;AAChF,cAAI;AAEF,kBAAM,EAAE,gBAAAC,gBAAe,IAAI,MAAM;AACjC,kBAAM,EAAE,sBAAAC,sBAAqB,IAAI,MAAM;AACvC,kBAAM,EAAE,YAAAC,YAAW,IAAI,MAAM;AAG7B,kBAAM,iBAAiB;AAOvB,kBAAM,MAAO,QAAgB;AAC7B,gBAAI,CAAC,KAAK;AACR,oBAAM,IAAI,MAAM,gDAAgD;AAAA,YAClE;AAGA,kBAAM,SAAS,IAAID,sBAAqB,GAAG;AAC3C,kBAAM,OAAO,WAAW;AAExB,kBAAMF,UAAS,IAAIG,YAAW,OAAO,iBAAiB,CAAC;AACvD,kBAAM,iBAAiB,IAAIF,gBAAe,QAAQD,SAAQ,GAAG;AAG7D,kBAAM,UAAUC,gBAAe,eAAe,eAAe,GAAG;AAChE,gBAAI,CAAC,SAAS;AACZ,oBAAM,IAAI,MAAM,oCAAoC,eAAe,GAAG,EAAE;AAAA,YAC1E;AAGA,gBAAI,CAACA,gBAAe,eAAe,OAAO,GAAG;AAC3C,oBAAM,IAAI,MAAM,4BAA4B,OAAO,EAAE;AAAA,YACvD;AAGA,kBAAM,YAAY,MAAM,eAAe,aAAa,OAAO;AAG3D,kBAAM,UAAU,MAAM,eAAe,gBAAgB,OAAO;AAG5D,gBAAI,cAAmB;AACvB,gBAAI,eAAe,mBAAmB,OAAO;AAC3C,kBAAI;AAEF,sBAAM,kBAAkB,MAAM,eAAe,eAAe,YAAY;AAAA,kBACtE,MAAM;AAAA,kBACN,IAAI,UAAU;AAAA,gBAChB,CAAC;AAED,oBAAI,gBAAgB,SAAS,gBAAgB,MAAM,SAAS,GAAG;AAC7D,wBAAM,UAAU,gBAAgB,MAAM,CAAC;AACvC,gCAAc;AAAA,oBACZ,IAAI,QAAQ;AAAA,oBACZ,OAAO,QAAQ,QAAQ;AAAA,oBACvB,WAAW,QAAQ,QAAQ;AAAA,oBAC3B,aAAa,QAAQ,QAAQ;AAAA,oBAC7B,iBAAiB,SAAS,QAAQ,YAAY,mBAAmB,GAAG;AAAA,oBACpE,YAAY,SAAS,QAAQ,YAAY,cAAc,GAAG;AAAA,oBAC1D,WAAW,SAAS,QAAQ,YAAY,aAAa,GAAG;AAAA,kBAC1D;AAAA,gBACF;AAAA,cACF,SAAS,OAAO;AACd,gBAAAD,QAAO,KAAK,qCAAqC;AAAA,kBAC/C,WAAW,UAAU;AAAA,kBACrB,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,gBAC9D,CAAC;AAAA,cACH;AAAA,YACF;AAGA,gBAAI,YAAiB,CAAC;AACtB,gBAAI,eAAe,sBAAsB,OAAO;AAC9C,oBAAM,cAAc,IAAI,KAAK,QAAQ,WAAW;AAChD,oBAAM,MAAM,oBAAI,KAAK;AACrB,oBAAM,iBAAiB,KAAK,OAAO,IAAI,QAAQ,IAAI,YAAY,QAAQ,MAAM,MAAO,KAAK,KAAK,GAAG;AAGjG,oBAAM,iBAAiB,QAAQ,YAAY,KACvC,QAAQ,YAAY,QAAQ,gBAAgB,QAAQ,YAAa,MAAM;AAC3E,oBAAM,kBAAkB,QAAQ,YAAY,IACzC,QAAQ,YAAY,QAAQ,YAAa,MAAM;AAClD,oBAAM,qBAAqB,QAAQ,YAAY,IAC5C,QAAQ,eAAe,QAAQ,YAAa,MAAM;AACrD,oBAAM,qBAAqB,iBAAiB,IAC1C,QAAQ,YAAY,iBAAiB,QAAQ;AAG/C,kBAAI,sBAA4D;AAChE,kBAAI,iBAAiB,GAAI,uBAAsB;AAAA,uBACtC,iBAAiB,EAAG,uBAAsB;AAAA,uBAC1C,iBAAiB,EAAG,uBAAsB;AAEnD,0BAAY;AAAA,gBACV,gBAAgB,KAAK,MAAM,iBAAiB,GAAG,IAAI;AAAA,gBACnD,iBAAiB,KAAK,MAAM,kBAAkB,GAAG,IAAI;AAAA,gBACrD,oBAAoB,KAAK,MAAM,qBAAqB,GAAG,IAAI;AAAA,gBAC3D,oBAAoB,KAAK,MAAM,kBAAkB;AAAA,gBACjD;AAAA,gBACA;AAAA,cACF;AAAA,YACF;AAGA,kBAAM,gBAAgB,wBAAC,aAA6B;AAClD,oBAAM,QAAQ,SAAS,MAAM,qCAAqC;AAClE,kBAAI,CAAC,MAAO,QAAO;AAEnB,oBAAM,QAAQ,SAAS,MAAM,CAAC,KAAK,GAAG;AACtC,oBAAM,UAAU,SAAS,MAAM,CAAC,KAAK,GAAG;AACxC,oBAAM,UAAU,SAAS,MAAM,CAAC,KAAK,GAAG;AAExC,kBAAI,QAAQ,GAAG;AACb,uBAAO,GAAG,KAAK,IAAI,QAAQ,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC,IAAI,QAAQ,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,cAC/F;AACA,qBAAO,GAAG,OAAO,IAAI,QAAQ,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,YAC1D,GAZsB;AAetB,gBAAI,YAAY;AAChB,gBAAI,YAAa,cAAa;AAG9B,kBAAM,WAAW;AAAA,cACf,OAAO;AAAA,gBACL,IAAI,UAAU;AAAA,gBACd,OAAO,UAAU;AAAA,gBACjB,aAAa,UAAU,YAAY,UAAU,GAAG,GAAG,KAAK,UAAU,YAAY,SAAS,MAAM,QAAQ;AAAA,gBACrG,aAAa,QAAQ;AAAA,gBACrB,UAAU,cAAc,UAAU,eAAe,QAAQ;AAAA,gBACzD,YAAY,UAAU;AAAA,gBACtB,iBAAkB,UAAkB;AAAA,gBACpC,MAAM,UAAU,KAAK,MAAM,GAAG,EAAE;AAAA;AAAA,cAClC;AAAA,cACA,YAAY;AAAA,gBACV,WAAW,QAAQ;AAAA,gBACnB,WAAW,QAAQ;AAAA,gBACnB,cAAc,QAAQ;AAAA,gBACtB,eAAe,QAAQ;AAAA,gBACvB,GAAI,QAAQ,iBAAiB,UAAa,EAAE,cAAc,QAAQ,aAAa;AAAA,cACjF;AAAA,cACA,GAAI,eAAe;AAAA,gBACjB,SAAS;AAAA,cACX;AAAA,cACA,GAAI,OAAO,KAAK,SAAS,EAAE,SAAS,KAAK;AAAA,gBACvC;AAAA,cACF;AAAA,cACA,UAAU;AAAA,gBACR,cAAa,oBAAI,KAAK,GAAE,YAAY;AAAA,gBACpC,QAAQ;AAAA;AAAA,gBACR,YAAY;AAAA,cACd;AAAA,YACF;AAEA,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,cACxC,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UAEF,SAAS,OAAO;AACd,kBAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAE1E,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,kCAAkC,YAAY;AAAA,cACtD,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF,GAjLS;AAAA,MAkLX;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,aAAa;AAAA,QACb,aAAa;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACV,WAAW;AAAA,cACT,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,YACA,YAAY;AAAA,cACV,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,cACT,SAAS;AAAA,cACT,SAAS;AAAA,YACX;AAAA,YACA,kBAAkB;AAAA,cAChB,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,UACF;AAAA,UACA,UAAU,CAAC,WAAW;AAAA,UACtB,sBAAsB;AAAA,QACxB;AAAA,QACA,SAAS,8BAAO,OAAgB,YAAkD;AAChF,cAAI;AAEF,kBAAM,EAAE,gBAAAC,gBAAe,IAAI,MAAM;AACjC,kBAAM,EAAE,sBAAAC,sBAAqB,IAAI,MAAM;AACvC,kBAAM,EAAE,YAAAC,YAAW,IAAI,MAAM;AAG7B,kBAAM,iBAAiB;AAOvB,kBAAM,MAAO,QAAgB;AAC7B,gBAAI,CAAC,KAAK;AACR,oBAAM,IAAI,MAAM,gDAAgD;AAAA,YAClE;AAGA,kBAAM,SAAS,IAAID,sBAAqB,GAAG;AAC3C,kBAAM,OAAO,WAAW;AAExB,kBAAMF,UAAS,IAAIG,YAAW,OAAO,iBAAiB,CAAC;AACvD,kBAAM,iBAAiB,IAAIF,gBAAe,QAAQD,SAAQ,GAAG;AAE7D,kBAAM,YAAY,eAAe;AACjC,kBAAM,aAAa,eAAe,cAAc;AAChD,kBAAM,mBAAmB,eAAe,qBAAqB;AAG7D,kBAAM,kBAAkB,MAAM,eAAe,eAAe,YAAY;AAAA,cACtE,MAAM;AAAA,cACN,IAAI;AAAA,YACN,CAAC;AAED,gBAAI,CAAC,gBAAgB,SAAS,gBAAgB,MAAM,WAAW,GAAG;AAChE,oBAAM,IAAI,MAAM,sBAAsB,SAAS,EAAE;AAAA,YACnD;AAEA,kBAAM,cAAc,gBAAgB,MAAM,CAAC;AAC3C,kBAAM,cAAc;AAAA,cAClB,IAAI,YAAY;AAAA,cAChB,OAAO,YAAY,QAAQ;AAAA,cAC3B,aAAa,YAAY,QAAQ,YAAY,UAAU,GAAG,GAAG,KAAK,YAAY,QAAQ,YAAY,SAAS,MAAM,QAAQ;AAAA,cACzH,WAAW,YAAY,QAAQ;AAAA,cAC/B,aAAa,YAAY,QAAQ;AAAA,cACjC,SAAS,YAAY,QAAQ;AAAA,cAC7B,iBAAiB,SAAS,YAAY,YAAY,mBAAmB,GAAG;AAAA,cACxE,YAAY,SAAS,YAAY,YAAY,cAAc,GAAG;AAAA,cAC9D,WAAW,SAAS,YAAY,YAAY,aAAa,GAAG;AAAA,cAC5D,uBAAuB,YAAY,YAAY,yBAAyB;AAAA,YAC1E;AAGA,kBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU;AAAA,cACnE,MAAM;AAAA,cACN;AAAA,cACA,MAAM;AAAA,cACN,OAAO;AAAA,cACP,YAAY,WAAW,SAAS;AAAA,YAClC,CAAC;AAED,gBAAI,CAAC,eAAe,SAAS,eAAe,MAAM,WAAW,GAAG;AAC9D,oBAAM,IAAI,MAAM,gCAAgC,SAAS,EAAE;AAAA,YAC7D;AAGA,kBAAM,WAAW,eAAe,MAAM,IAAI,CAAC,SAAc,KAAK,GAAG,OAAO;AACxE,kBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU;AAAA,cACnE,MAAM;AAAA,cACN,IAAI,SAAS,KAAK,GAAG;AAAA,YACvB,CAAC;AAED,kBAAM,SAAS,CAAC;AAChB,gBAAI,aAAa;AACjB,gBAAI,aAAa;AACjB,gBAAI,gBAAgB;AACpB,gBAAI,mBAAmB,EAAE,OAAO,MAAa,OAAO,EAAE;AAEtD,uBAAW,SAAS,eAAe,SAAS,CAAC,GAAG;AAC9C,oBAAM,QAAQ,MAAM;AACpB,oBAAM,YAAY,SAAS,OAAO,aAAa,GAAG;AAClD,oBAAM,YAAY,SAAS,OAAO,aAAa,GAAG;AAClD,oBAAM,eAAe,SAAS,OAAO,gBAAgB,GAAG;AAGxD,oBAAM,kBAAkB,YAAY,KAChC,YAAY,gBAAgB,YAAa,MAAM;AAGnD,oBAAM,mBAAoB,YAAY,MAAQ,YAAY,OAAS,eAAe;AAElF,kBAAI,mBAAmB,iBAAiB,OAAO;AAC7C,mCAAmB,EAAE,OAAO,OAAO,iBAAiB;AAAA,cACtD;AAEA,4BAAc;AACd,4BAAc;AACd,+BAAiB;AAGjB,oBAAM,gBAAgB,wBAAC,aAA6B;AAClD,sBAAM,QAAQ,SAAS,MAAM,qCAAqC;AAClE,oBAAI,CAAC,MAAO,QAAO;AAEnB,sBAAM,QAAQ,SAAS,MAAM,CAAC,KAAK,GAAG;AACtC,sBAAM,UAAU,SAAS,MAAM,CAAC,KAAK,GAAG;AACxC,sBAAM,UAAU,SAAS,MAAM,CAAC,KAAK,GAAG;AAExC,oBAAI,QAAQ,GAAG;AACb,yBAAO,GAAG,KAAK,IAAI,QAAQ,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC,IAAI,QAAQ,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,gBAC/F;AACA,uBAAO,GAAG,OAAO,IAAI,QAAQ,SAAS,EAAE,SAAS,GAAG,GAAG,CAAC;AAAA,cAC1D,GAZsB;AActB,qBAAO,KAAK;AAAA,gBACV,IAAI,MAAM;AAAA,gBACV,OAAO,MAAM,QAAQ;AAAA,gBACrB,aAAa,MAAM,QAAQ;AAAA,gBAC3B,UAAU,cAAc,MAAM,gBAAgB,YAAY,MAAM;AAAA,gBAChE;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,eAAe,SAAS,OAAO,iBAAiB,GAAG;AAAA,gBACnD,iBAAiB,KAAK,MAAM,kBAAkB,GAAG,IAAI;AAAA,gBACrD,kBAAkB,KAAK,MAAM,gBAAgB;AAAA,cAC/C,CAAC;AAAA,YACH;AAGA,mBAAO,KAAK,CAAC,GAAG,MAAM,EAAE,mBAAmB,EAAE,gBAAgB;AAG7D,gBAAI,YAAiB,CAAC;AACtB,gBAAI,kBAAkB;AACpB,oBAAM,WAAW,OAAO,SAAS,IAAI,KAAK,MAAM,aAAa,OAAO,MAAM,IAAI;AAC9E,oBAAM,WAAW,OAAO,SAAS,IAAI,KAAK,MAAM,aAAa,OAAO,MAAM,IAAI;AAC9E,oBAAM,cAAc,OAAO,SAAS,IAAI,KAAK,MAAM,gBAAgB,OAAO,MAAM,IAAI;AACpF,oBAAM,gBAAgB,OAAO,SAAS,IACpC,OAAO,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,iBAAiB,CAAC,IAAI,OAAO,SAAS;AAG1E,oBAAM,wBAAwB,YAAY,kBAAkB,IAC1D,WAAW,YAAY,kBAAkB;AAG3C,kBAAI,sBAA8E;AAClF,kBAAI,gBAAgB,EAAG,uBAAsB;AAAA,uBACpC,gBAAgB,EAAG,uBAAsB;AAAA,uBACzC,gBAAgB,EAAG,uBAAsB;AAElD,0BAAY;AAAA,gBACV,gBAAgB;AAAA,kBACd,OAAO;AAAA,kBACP,OAAO;AAAA,kBACP,UAAU;AAAA,kBACV,gBAAgB,KAAK,MAAM,gBAAgB,GAAG,IAAI;AAAA,gBACpD;AAAA,gBACA,qBAAqB;AAAA,kBACnB,UAAU;AAAA,kBACV,uBAAuB,KAAK,MAAM,wBAAwB,GAAK,IAAI;AAAA,kBACnE,iBAAiB,aAAa;AAAA,kBAC9B,kBAAkB,KAAK,0BAA0B,MAAM;AAAA,gBACzD;AAAA,gBACA,oBAAoB,iBAAiB,QAAQ;AAAA,kBAC3C,IAAI,iBAAiB,MAAM;AAAA,kBAC3B,OAAO,iBAAiB,MAAM,QAAQ;AAAA,kBACtC,WAAW,SAAS,iBAAiB,MAAM,YAAY,aAAa,GAAG;AAAA,kBACvE,kBAAkB,KAAK,MAAM,iBAAiB,KAAK;AAAA,gBACrD,IAAI;AAAA,cACN;AAAA,YACF;AAGA,gBAAI,YAAY;AAChB,yBAAa;AACb,yBAAa;AAEb,kBAAM,WAAW;AAAA,cACf,SAAS;AAAA,cACT;AAAA,cACA,SAAS;AAAA,gBACP,oBAAoB,OAAO;AAAA,gBAC3B;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,sBAAsB,OAAO,SAAS,IAAI,KAAK,MAAM,aAAa,OAAO,MAAM,IAAI;AAAA,cACrF;AAAA,cACA,GAAI,OAAO,KAAK,SAAS,EAAE,SAAS,KAAK,EAAE,UAAU;AAAA,cACrD,UAAU;AAAA,gBACR,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,gBACnC;AAAA,gBACA,YAAY,QAAQ,OAAO,MAAM;AAAA,cACnC;AAAA,YACF;AAEA,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,cACxC,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UAEF,SAAS,OAAO;AACd,kBAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAE1E,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,wCAAwC,YAAY;AAAA,cAC5D,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF,GAzNS;AAAA,MA0NX;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,aAAa;AAAA,QACb,aAAa;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACV,UAAU;AAAA,cACR,MAAM;AAAA,cACN,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,SAAS;AAAA,cACX;AAAA,cACA,aAAa;AAAA,cACb,UAAU;AAAA,cACV,UAAU;AAAA,YACZ;AAAA,YACA,iBAAiB;AAAA,cACf,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,cACT,SAAS;AAAA,cACT,SAAS;AAAA,YACX;AAAA,YACA,2BAA2B;AAAA,cACzB,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,UACF;AAAA,UACA,UAAU,CAAC,UAAU;AAAA,UACrB,sBAAsB;AAAA,QACxB;AAAA,QACA,SAAS,8BAAO,OAAgB,YAAkD;AAChF,cAAI;AAEF,kBAAM,EAAE,gBAAAC,gBAAe,IAAI,MAAM;AACjC,kBAAM,EAAE,sBAAAC,sBAAqB,IAAI,MAAM;AACvC,kBAAM,EAAE,YAAAC,YAAW,IAAI,MAAM;AAG7B,kBAAM,iBAAiB;AAOvB,kBAAM,MAAO,QAAgB;AAC7B,gBAAI,CAAC,KAAK;AACR,oBAAM,IAAI,MAAM,gDAAgD;AAAA,YAClE;AAGA,kBAAM,SAAS,IAAID,sBAAqB,GAAG;AAC3C,kBAAM,OAAO,WAAW;AAExB,kBAAMF,UAAS,IAAIG,YAAW,OAAO,iBAAiB,CAAC;AACvD,kBAAM,iBAAiB,IAAIF,gBAAe,QAAQD,SAAQ,GAAG;AAE7D,kBAAM,aAAa,eAAe;AAClC,kBAAM,kBAAkB,eAAe,mBAAmB;AAC1D,kBAAM,oBAAoB,eAAe,8BAA8B;AAGvE,kBAAM,kBAAkB,CAAC;AACzB,gBAAI,iBAAiB;AAErB,uBAAW,aAAa,YAAY;AAClC,kBAAI;AAEF,sBAAM,kBAAkB,MAAM,eAAe,eAAe,YAAY;AAAA,kBACtE,MAAM;AAAA,kBACN,IAAI;AAAA,gBACN,CAAC;AAED,oBAAI,CAAC,gBAAgB,SAAS,gBAAgB,MAAM,WAAW,GAAG;AAChE,kBAAAA,QAAO,KAAK,sBAAsB,SAAS,EAAE;AAC7C;AAAA,gBACF;AAEA,sBAAM,cAAc,gBAAgB,MAAM,CAAC;AAC3C,kCAAkB;AAGlB,sBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU;AAAA,kBACnE,MAAM;AAAA,kBACN;AAAA,kBACA,MAAM;AAAA,kBACN,OAAO;AAAA,kBACP,YAAY,gBAAgB,SAAS;AAAA,gBACvC,CAAC;AAED,kCAAkB;AAElB,oBAAI,CAAC,eAAe,SAAS,eAAe,MAAM,WAAW,GAAG;AAC9D,kBAAAA,QAAO,KAAK,gCAAgC,SAAS,EAAE;AACvD;AAAA,gBACF;AAGA,sBAAM,WAAW,eAAe,MAAM,IAAI,CAAC,SAAc,KAAK,GAAG,OAAO;AACxE,sBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU;AAAA,kBACnE,MAAM;AAAA,kBACN,IAAI,SAAS,KAAK,GAAG;AAAA,gBACvB,CAAC;AAED,kCAAkB;AAGlB,oBAAI,aAAa;AACjB,oBAAI,aAAa;AACjB,oBAAI,gBAAgB;AACpB,oBAAI,gBAAgB;AACpB,sBAAM,eAAe,CAAC;AAEtB,2BAAW,SAAS,eAAe,SAAS,CAAC,GAAG;AAC9C,wBAAM,QAAQ,MAAM;AACpB,wBAAM,YAAY,SAAS,OAAO,aAAa,GAAG;AAClD,wBAAM,YAAY,SAAS,OAAO,aAAa,GAAG;AAClD,wBAAM,eAAe,SAAS,OAAO,gBAAgB,GAAG;AAGxD,wBAAM,WAAW,KAAK,uBAAuB,MAAM,gBAAgB,YAAY,MAAM;AAErF,gCAAc;AACd,gCAAc;AACd,mCAAiB;AACjB,mCAAiB;AAEjB,wBAAM,kBAAkB,YAAY,KAChC,YAAY,gBAAgB,YAAa,MAAM;AAEnD,+BAAa,KAAK;AAAA,oBAChB;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA,iBAAiB,KAAK,MAAM,kBAAkB,GAAK,IAAI;AAAA,kBACzD,CAAC;AAAA,gBACH;AAGA,sBAAM,aAAa,aAAa;AAChC,sBAAM,WAAW,aAAa,IAAI,aAAa,aAAa;AAC5D,sBAAM,WAAW,aAAa,IAAI,aAAa,aAAa;AAC5D,sBAAM,cAAc,aAAa,IAAI,gBAAgB,aAAa;AAClE,sBAAM,cAAc,aAAa,IAAI,gBAAgB,aAAa;AAClE,sBAAM,gBAAgB,aAAa,IACjC,aAAa,OAAO,CAAC,KAAK,MAAM,MAAM,EAAE,iBAAiB,CAAC,IAAI,aAAa;AAG7E,sBAAM,kBAAkB,SAAS,YAAY,YAAY,mBAAmB,GAAG;AAC/E,sBAAM,2BAA2B,kBAAkB,IAChD,WAAW,kBAAmB,MAAM;AAGvC,sBAAM,cAAc,eAAe,MAAM,eAAe,MAAM,SAAS,CAAC;AACxE,sBAAM,cAAc,eAAe,MAAM,CAAC;AAC1C,sBAAM,WAAW,IAAI,KAAK,YAAY,QAAQ,WAAW,EAAE,QAAQ,IACpD,IAAI,KAAK,YAAY,QAAQ,WAAW,EAAE,QAAQ;AACjE,sBAAM,YAAY,YAAY,MAAO,KAAK,KAAK,KAAK;AACpD,sBAAM,gBAAgB,YAAY,IAAI,aAAa,YAAY;AAE/D,gCAAgB,KAAK;AAAA,kBACnB,SAAS;AAAA,oBACP,IAAI,YAAY;AAAA,oBAChB,OAAO,YAAY,QAAQ;AAAA,oBAC3B,aAAa,YAAY,QAAQ,YAAY,UAAU,GAAG,GAAG,KACjD,YAAY,QAAQ,YAAY,SAAS,MAAM,QAAQ;AAAA,oBACnE,WAAW,YAAY,QAAQ;AAAA,oBAC/B;AAAA,oBACA,iBAAiB,SAAS,YAAY,YAAY,cAAc,GAAG;AAAA,oBACnE,gBAAgB,SAAS,YAAY,YAAY,aAAa,GAAG;AAAA,kBACnE;AAAA,kBACA,aAAa;AAAA,oBACX,gBAAgB;AAAA,oBAChB,cAAc,KAAK,MAAM,QAAQ;AAAA,oBACjC,cAAc,KAAK,MAAM,QAAQ;AAAA,oBACjC,iBAAiB,KAAK,MAAM,WAAW;AAAA,oBACvC,wBAAwB,KAAK,MAAM,WAAW;AAAA,oBAC9C,uBAAuB,KAAK,MAAM,gBAAgB,GAAK,IAAI;AAAA,oBAC3D,0BAA0B,KAAK,MAAM,2BAA2B,GAAG,IAAI;AAAA,oBACvE,eAAe,KAAK,MAAM,gBAAgB,GAAG,IAAI;AAAA,kBACnD;AAAA,kBACA,WAAW,KAAK,yBAAyB,UAAU,eAAe,0BAA0B,aAAa;AAAA,kBACzG,GAAI,qBAAqB;AAAA,oBACvB,oBAAoB;AAAA,sBAClB,aAAa,KAAK,0BAA0B,aAAa,IAAI,QAAM,EAAE,kBAAkB,EAAE,UAAU,EAAE,CAAC;AAAA,sBACtG,yBAAyB,KAAK,IAAI,GAAG,aAAa,IAAI,OAAK,EAAE,SAAS,CAAC;AAAA,sBACvE,wBAAwB,KAAK,8BAA8B,YAAY;AAAA,oBACzE;AAAA,kBACF;AAAA,gBACF,CAAC;AAAA,cAEH,SAAS,OAAO;AACd,gBAAAA,QAAO,MAAM,6BAA6B,SAAS,IAAI;AAAA,kBACrD,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,gBAC9D,CAAC;AAED,gCAAgB,KAAK;AAAA,kBACnB,SAAS,EAAE,IAAI,WAAW,OAAO,kBAAkB;AAAA,kBACnD,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,gBAC9D,CAAC;AAAA,cACH;AAAA,YACF;AAGA,kBAAM,aAAa,KAAK,6BAA6B,eAAe;AAEpE,kBAAM,WAAW;AAAA,cACf,YAAY;AAAA,gBACV,cAAc,gBAAgB;AAAA,gBAC9B,QAAQ,WAAW;AAAA,gBACnB,UAAU,WAAW;AAAA,gBACrB,UAAU,WAAW;AAAA,cACvB;AAAA,cACA,UAAU;AAAA,cACV,UAAU;AAAA,gBACR,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,gBACnC;AAAA,gBACA,2BAA2B;AAAA,gBAC3B,WAAW;AAAA,cACb;AAAA,YACF;AAEA,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,cACxC,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UAEF,SAAS,OAAO;AACd,kBAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAE1E,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,0CAA0C,YAAY;AAAA,cAC9D,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF,GApNS;AAAA,MAqNX;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,aAAa;AAAA,QACb,aAAa;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACV,UAAU;AAAA,cACR,MAAM;AAAA,cACN,OAAO,EAAE,MAAM,SAAS;AAAA,cACxB,aAAa;AAAA,cACb,UAAU;AAAA,cACV,UAAU;AAAA,YACZ;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,YACA,YAAY;AAAA,cACV,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,cACT,SAAS;AAAA,cACT,SAAS;AAAA,YACX;AAAA,YACA,gBAAgB;AAAA,cACd,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,YACA,OAAO;AAAA,cACL,MAAM;AAAA,cACN,aAAa;AAAA,cACb,MAAM,CAAC,aAAa,QAAQ,aAAa,QAAQ;AAAA,cACjD,SAAS;AAAA,YACX;AAAA,UACF;AAAA,UACA,UAAU,CAAC,UAAU;AAAA,UACrB,sBAAsB;AAAA,QACxB;AAAA,QACA,SAAS,8BAAO,OAAgB,YAAkD;AAChF,cAAI;AAEF,kBAAM,EAAE,gBAAAC,gBAAe,IAAI,MAAM;AACjC,kBAAM,EAAE,sBAAAC,sBAAqB,IAAI,MAAM;AACvC,kBAAM,EAAE,YAAAC,YAAW,IAAI,MAAM;AAG7B,kBAAM,iBAAiB;AASvB,kBAAM,MAAO,QAAgB;AAC7B,gBAAI,CAAC,KAAK;AACR,oBAAM,IAAI,MAAM,gDAAgD;AAAA,YAClE;AAGA,kBAAM,SAAS,IAAID,sBAAqB,GAAG;AAC3C,kBAAM,OAAO,WAAW;AAExB,kBAAMF,UAAS,IAAIG,YAAW,OAAO,iBAAiB,CAAC;AACvD,kBAAM,iBAAiB,IAAIF,gBAAe,QAAQD,SAAQ,GAAG;AAE7D,kBAAM,WAAW,eAAe;AAChC,kBAAM,YAAY,eAAe;AACjC,kBAAM,aAAa,eAAe,cAAc;AAChD,kBAAM,iBAAiB,eAAe;AACtC,kBAAM,QAAQ,eAAe,SAAS;AAGtC,kBAAM,cAAc,SAAS,IAAI,OAAK,IAAI,CAAC,GAAG,EAAE,KAAK,MAAM;AAG3D,kBAAM,eAAuC;AAAA,cAC3C,MAAM;AAAA,cACN,MAAM;AAAA,cACN,GAAG;AAAA,cACH,YAAY,WAAW,SAAS;AAAA,cAChC;AAAA,YACF;AAEA,gBAAI,WAAW;AACb,2BAAa,YAAY;AAAA,YAC3B;AAEA,gBAAI,gBAAgB;AAClB,2BAAa,iBAAiB;AAAA,YAChC;AAEA,gBAAI,YAAY;AAGhB,kBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU,YAAY;AAEjF,gBAAI,CAAC,eAAe,SAAS,eAAe,MAAM,WAAW,GAAG;AAC9D,qBAAO;AAAA,gBACL,SAAS,CAAC;AAAA,kBACR,MAAM;AAAA,kBACN,MAAM,KAAK,UAAU;AAAA,oBACnB,SAAS,CAAC;AAAA,oBACV,SAAS;AAAA,sBACP;AAAA,sBACA,cAAc;AAAA,sBACd;AAAA,sBACA,SAAS;AAAA,oBACX;AAAA,oBACA,UAAU;AAAA,sBACR,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,sBACnC;AAAA,oBACF;AAAA,kBACF,GAAG,MAAM,CAAC;AAAA,gBACZ,CAAC;AAAA,gBACD,SAAS;AAAA,cACX;AAAA,YACF;AAGA,kBAAM,WAAW,eAAe,MAAM,IAAI,CAAC,SAAc,KAAK,GAAG,OAAO;AACxE,kBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU;AAAA,cACnE,MAAM;AAAA,cACN,IAAI,SAAS,KAAK,GAAG;AAAA,YACvB,CAAC;AAED,yBAAa;AAGb,kBAAM,UAAU,CAAC;AACjB,kBAAM,eAAoE,CAAC;AAG3E,qBAAS,QAAQ,aAAW;AAC1B,2BAAa,QAAQ,YAAY,CAAC,IAAI,EAAE,OAAO,GAAG,QAAQ,CAAC,EAAE;AAAA,YAC/D,CAAC;AAED,uBAAW,SAAS,eAAe,SAAS,CAAC,GAAG;AAC9C,oBAAM,UAAU,MAAM;AACtB,oBAAM,QAAQ,MAAM;AAGpB,oBAAM,UAAU,KAAK;AAAA,gBACnB;AAAA,gBACA,QAAQ;AAAA,gBACR,QAAQ;AAAA,gBACR,QAAQ,QAAQ,CAAC;AAAA,cACnB;AAGA,sBAAQ,cAAc,QAAQ,aAAW;AACvC,6BAAa,QAAQ,YAAY,CAAC,EAAE;AACpC,6BAAa,QAAQ,YAAY,CAAC,EAAE,OAAO,KAAK,MAAM,EAAE;AAAA,cAC1D,CAAC;AAGD,oBAAM,WAAW,KAAK,uBAAuB,MAAM,gBAAgB,YAAY,MAAM;AAErF,sBAAQ,KAAK;AAAA,gBACX,OAAO;AAAA,kBACL,IAAI,MAAM;AAAA,kBACV,OAAO,QAAQ;AAAA,kBACf,aAAa,QAAQ,YAAY,UAAU,GAAG,GAAG,KACrC,QAAQ,YAAY,SAAS,MAAM,QAAQ;AAAA,kBACvD,aAAa,QAAQ;AAAA,kBACrB,WAAW,QAAQ;AAAA,kBACnB,cAAc,QAAQ;AAAA,kBACtB,UAAU,KAAK,oBAAoB,QAAQ;AAAA,kBAC3C,YAAY;AAAA,oBACV,SAAS,QAAQ,WAAW,SAAS;AAAA,oBACrC,QAAQ,QAAQ,WAAW,QAAQ;AAAA,oBACnC,MAAM,QAAQ,WAAW,MAAM;AAAA,kBACjC;AAAA,gBACF;AAAA,gBACA,YAAY;AAAA,kBACV,WAAW,SAAS,OAAO,aAAa,GAAG;AAAA,kBAC3C,WAAW,SAAS,OAAO,aAAa,GAAG;AAAA,kBAC3C,cAAc,SAAS,OAAO,gBAAgB,GAAG;AAAA,gBACnD;AAAA,gBACA,iBAAiB;AAAA,kBACf,eAAe,QAAQ;AAAA,kBACvB,cAAc,QAAQ;AAAA,kBACtB,oBAAoB,QAAQ;AAAA,kBAC5B,YAAY,QAAQ;AAAA,kBACpB,gBAAgB,QAAQ;AAAA,gBAC1B;AAAA,cACF,CAAC;AAAA,YACH;AAGA,oBAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,gBAAgB,iBAAiB,EAAE,gBAAgB,cAAc;AAG1F,kBAAM,WAAW,KAAK,8BAA8B,UAAU,cAAc,OAAO;AAEnF,kBAAM,WAAW;AAAA,cACf;AAAA,cACA,SAAS;AAAA,gBACP;AAAA,gBACA,cAAc,QAAQ;AAAA,gBACtB;AAAA,gBACA,YAAY,SAAS;AAAA,gBACrB,uBAAuB,SAAS;AAAA,cAClC;AAAA,cACA,mBAAmB;AAAA,cACnB,UAAU,SAAS;AAAA,cACnB,UAAU;AAAA,gBACR,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,gBACnC,kBAAkB;AAAA,kBAChB;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF;AAAA,gBACA;AAAA,cACF;AAAA,YACF;AAEA,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,cACxC,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UAEF,SAAS,OAAO;AACd,kBAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAE1E,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,iCAAiC,YAAY;AAAA,cACrD,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF,GAxMS;AAAA,MAyMX;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,aAAa;AAAA,QACb,aAAa;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACV,UAAU;AAAA,cACR,MAAM;AAAA,cACN,aAAa;AAAA,cACb,MAAM,CAAC,UAAU,SAAS,cAAc,iBAAiB,aAAa,MAAM;AAAA,YAC9E;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,aAAa;AAAA,cACb,MAAM,CAAC,OAAO,MAAM,KAAK;AAAA,cACzB,SAAS;AAAA,YACX;AAAA,YACA,QAAQ;AAAA,cACN,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,cACT,SAAS;AAAA,YACX;AAAA,UACF;AAAA,UACA,sBAAsB;AAAA,QACxB;AAAA,QACA,SAAS,8BAAO,OAAgB,YAAkD;AAChF,cAAI;AAEF,kBAAM,EAAE,gBAAAC,gBAAe,IAAI,MAAM;AACjC,kBAAM,EAAE,sBAAAC,sBAAqB,IAAI,MAAM;AACvC,kBAAM,EAAE,YAAAC,YAAW,IAAI,MAAM;AAG7B,kBAAM,iBAAiB;AAOvB,kBAAM,MAAO,QAAgB;AAC7B,gBAAI,CAAC,KAAK;AACR,oBAAM,IAAI,MAAM,gDAAgD;AAAA,YAClE;AAGA,kBAAM,SAAS,IAAID,sBAAqB,GAAG;AAC3C,kBAAM,OAAO,WAAW;AAExB,kBAAMF,UAAS,IAAIG,YAAW,OAAO,iBAAiB,CAAC;AACvD,kBAAM,iBAAiB,IAAIF,gBAAe,QAAQD,SAAQ,GAAG;AAE7D,kBAAM,WAAW,eAAe;AAChC,kBAAM,YAAY,eAAe,aAAa;AAC9C,kBAAM,SAAS,eAAe,UAAU;AAGxC,kBAAM,MAAM,oBAAI,KAAK;AACrB,kBAAM,iBAAiB,oBAAI,KAAK;AAChC,oBAAQ,WAAW;AAAA,cACjB,KAAK;AACH,+BAAe,QAAQ,IAAI,QAAQ,IAAI,CAAC;AACxC;AAAA,cACF,KAAK;AACH,+BAAe,QAAQ,IAAI,QAAQ,IAAI,CAAC;AACxC;AAAA,cACF,KAAK;AACH,+BAAe,QAAQ,IAAI,QAAQ,IAAI,EAAE;AACzC;AAAA,YACJ;AAGA,kBAAM,eAAe;AAAA,cACnB;AAAA,cACA;AAAA,cACA;AAAA,cACA,GAAI,WAAW,CAAC,GAAG,SAAS,YAAY,CAAC,EAAE,IAAI,CAAC;AAAA,YAClD;AAEA,gBAAI,YAAY;AAChB,kBAAM,YAAY,CAAC;AACnB,kBAAM,mBAAmB,oBAAI,IAAoB;AAGjD,uBAAW,SAAS,aAAa,MAAM,GAAG,CAAC,GAAG;AAC5C,kBAAI;AACF,sBAAM,eAAuC;AAAA,kBAC3C,MAAM;AAAA,kBACN,MAAM;AAAA,kBACN,GAAG;AAAA,kBACH,YAAY;AAAA,kBACZ,OAAO;AAAA,kBACP,gBAAgB,eAAe,YAAY;AAAA,kBAC3C,YAAY;AAAA,gBACd;AAEA,sBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU,YAAY;AACjF,6BAAa;AAEb,oBAAI,eAAe,SAAS,eAAe,MAAM,SAAS,GAAG;AAE3D,wBAAM,WAAW,eAAe,MAAM,IAAI,CAAC,SAAc,KAAK,GAAG,OAAO;AACxE,wBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU;AAAA,oBACnE,MAAM;AAAA,oBACN,IAAI,SAAS,KAAK,GAAG;AAAA,kBACvB,CAAC;AACD,+BAAa;AAGb,6BAAW,SAAS,eAAe,SAAS,CAAC,GAAG;AAC9C,0BAAM,UAAU,MAAM;AACtB,0BAAM,QAAQ,MAAM;AAGpB,0BAAM,OAAO,GAAG,QAAQ,KAAK,IAAI,QAAQ,WAAW,GAAG,YAAY;AACnE,0BAAM,WAAW,KAAK,sBAAsB,IAAI;AAGhD,6BAAS,QAAQ,aAAW;AAC1B,uCAAiB,IAAI,UAAU,iBAAiB,IAAI,OAAO,KAAK,KAAK,CAAC;AAAA,oBACxE,CAAC;AAGD,0BAAM,YAAY,SAAS,OAAO,aAAa,GAAG;AAClD,0BAAM,YAAY,SAAS,OAAO,aAAa,GAAG;AAClD,0BAAM,eAAe,SAAS,OAAO,gBAAgB,GAAG;AAExD,0BAAM,iBAAiB,YAAY,KAC/B,YAAY,gBAAgB,YAAa,MAAM;AAGnD,0BAAM,gBAAgB,IAAI,KAAK,QAAQ,WAAW;AAClD,0BAAM,qBAAqB,KAAK;AAAA,sBAAI;AAAA,uBACjC,IAAI,QAAQ,IAAI,cAAc,QAAQ,MAAM,MAAO,KAAK,KAAK;AAAA,oBAChE;AAGA,0BAAM,aAAc,YAAY,MAAQ,kBAAkB,KAAK;AAE/D,8BAAU,KAAK;AAAA,sBACb;AAAA,sBACA,OAAO;AAAA,wBACL,IAAI,MAAM;AAAA,wBACV,OAAO,QAAQ;AAAA,wBACf,cAAc,QAAQ;AAAA,wBACtB,aAAa,QAAQ;AAAA,wBACrB,YAAY,QAAQ;AAAA,sBACtB;AAAA,sBACA,SAAS;AAAA,wBACP;AAAA,wBACA;AAAA,wBACA;AAAA,wBACA,gBAAgB,KAAK,MAAM,iBAAiB,GAAK,IAAI;AAAA,wBACrD,oBAAoB,KAAK,MAAM,qBAAqB,EAAE,IAAI;AAAA,wBAC1D,YAAY,KAAK,MAAM,aAAa,GAAG,IAAI;AAAA,sBAC7C;AAAA,sBACA;AAAA,oBACF,CAAC;AAAA,kBACH;AAAA,gBACF;AAAA,cACF,SAAS,OAAO;AACd,gBAAAA,QAAO,KAAK,+BAA+B,KAAK,IAAI;AAAA,kBAClD,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,gBAC9D,CAAC;AAAA,cACH;AAAA,YACF;AAGA,kBAAM,eAAe,UAAU,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,aAAa,EAAE,QAAQ,UAAU;AAGzF,kBAAM,mBAAmB,MAAM,KAAK,iBAAiB,QAAQ,CAAC,EAC3D,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,IAAI,CAAC,EAC5B,MAAM,GAAG,EAAE,EACX,IAAI,CAAC,CAAC,SAAS,SAAS,OAAO,EAAE,SAAS,UAAU,EAAE;AAGzD,kBAAM,iBAAiB,iBACpB,OAAO,UAAQ,KAAK,aAAa,CAAC,EAClC,MAAM,GAAG,CAAC;AAGb,kBAAM,WAAW,KAAK;AAAA,cACpB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAEA,kBAAM,WAAW;AAAA,cACf,QAAQ;AAAA,gBACN,mBAAmB,aAAa,MAAM,GAAG,EAAE;AAAA,gBAC3C,kBAAkB,iBAAiB,MAAM,GAAG,EAAE;AAAA,gBAC9C,gBAAgB;AAAA,gBAChB;AAAA,cACF;AAAA,cACA,UAAU;AAAA,gBACR,qBAAqB,UAAU;AAAA,gBAC/B;AAAA,gBACA;AAAA,gBACA,UAAU,YAAY;AAAA,gBACtB,eAAe,aAAa,SAAS,IAAI,aAAa,CAAC,EAAE,QAAQ,aAAa;AAAA,gBAC9E,uBAAuB,UAAU,SAAS,IACxC,KAAK,MAAO,UAAU,OAAO,CAAC,KAAK,SAAS,MAAM,KAAK,QAAQ,gBAAgB,CAAC,IAAI,UAAU,SAAU,GAAK,IAAI,MAAQ;AAAA,cAC7H;AAAA,cACA,iBAAiB,KAAK,6BAA6B,kBAAkB,gBAAgB,SAAS;AAAA,cAC9F,UAAU;AAAA,gBACR,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,gBACnC,eAAe,aAAa,MAAM,GAAG,CAAC;AAAA,gBACtC;AAAA,cACF;AAAA,YACF;AAEA,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,cACxC,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UAEF,SAAS,OAAO;AACd,kBAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAE1E,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,2BAA2B,YAAY;AAAA,cAC/C,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF,GA/MS;AAAA,MAgNX;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,aAAa;AAAA,QACb,aAAa;AAAA,UACX,MAAM;AAAA,UACN,YAAY;AAAA,YACV,WAAW;AAAA,cACT,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,YACA,oBAAoB;AAAA,cAClB,MAAM;AAAA,cACN,aAAa;AAAA,cACb,SAAS;AAAA,YACX;AAAA,UACF;AAAA,UACA,UAAU,CAAC,WAAW;AAAA,UACtB,sBAAsB;AAAA,QACxB;AAAA,QACA,SAAS,8BAAO,OAAgB,YAAkD;AAChF,cAAI;AAEF,kBAAM,EAAE,gBAAAC,gBAAe,IAAI,MAAM;AACjC,kBAAM,EAAE,sBAAAC,sBAAqB,IAAI,MAAM;AACvC,kBAAM,EAAE,YAAAC,YAAW,IAAI,MAAM;AAG7B,kBAAM,iBAAiB;AAMvB,kBAAM,MAAO,QAAgB;AAC7B,gBAAI,CAAC,KAAK;AACR,oBAAM,IAAI,MAAM,gDAAgD;AAAA,YAClE;AAGA,kBAAM,SAAS,IAAID,sBAAqB,GAAG;AAC3C,kBAAM,OAAO,WAAW;AAExB,kBAAMF,UAAS,IAAIG,YAAW,OAAO,iBAAiB,CAAC;AACvD,kBAAM,iBAAiB,IAAIF,gBAAe,QAAQD,SAAQ,GAAG;AAE7D,kBAAM,YAAY,eAAe;AACjC,kBAAM,qBAAqB,eAAe,sBAAsB;AAEhE,gBAAI,YAAY;AAGhB,kBAAM,kBAAkB,MAAM,eAAe,eAAe,YAAY;AAAA,cACtE,MAAM;AAAA,cACN,IAAI;AAAA,YACN,CAAC;AACD,yBAAa;AAEb,gBAAI,CAAC,gBAAgB,SAAS,gBAAgB,MAAM,WAAW,GAAG;AAChE,qBAAO;AAAA,gBACL,SAAS,CAAC;AAAA,kBACR,MAAM;AAAA,kBACN,MAAM,KAAK,UAAU;AAAA,oBACnB,OAAO;AAAA,oBACP;AAAA,oBACA,aAAa;AAAA,sBACX;AAAA,sBACA;AAAA,sBACA;AAAA,oBACF;AAAA,kBACF,GAAG,MAAM,CAAC;AAAA,gBACZ,CAAC;AAAA,gBACD,SAAS;AAAA,cACX;AAAA,YACF;AAEA,kBAAM,UAAU,gBAAgB,MAAM,CAAC;AACvC,kBAAM,QAAQ,QAAQ;AACtB,kBAAM,UAAU,QAAQ;AAGxB,kBAAM,oBAAoB,QAAQ,gBAAgB,kBAAkB;AACpE,gBAAI,eAAsB,CAAC;AAE3B,gBAAI,mBAAmB;AACrB,kBAAI;AACF,sBAAM,mBAAmB,MAAM,eAAe,eAAe,iBAAiB;AAAA,kBAC5E,MAAM;AAAA,kBACN,YAAY;AAAA,kBACZ,YAAY;AAAA,gBACd,CAAC;AACD,6BAAa;AAEb,oBAAI,iBAAiB,SAAS,iBAAiB,MAAM,SAAS,GAAG;AAC/D,wBAAM,WAAW,iBAAiB,MAAM,IAAI,CAAC,SAAc,KAAK,QAAQ,WAAW,OAAO;AAC1F,wBAAM,iBAAiB,MAAM,eAAe,eAAe,UAAU;AAAA,oBACnE,MAAM;AAAA,oBACN,IAAI,SAAS,KAAK,GAAG;AAAA,kBACvB,CAAC;AACD,+BAAa;AAEb,iCAAe,eAAe,SAAS,CAAC;AAAA,gBAC1C;AAAA,cACF,SAAS,OAAO;AACd,gBAAAA,QAAO,KAAK,iCAAiC;AAAA,kBAC3C;AAAA,kBACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,gBAC9D,CAAC;AAAA,cACH;AAAA,YACF;AAGA,kBAAM,kBAAkB,KAAK,0BAA0B,SAAS,YAAY;AAG5E,gBAAI,qBAAqB;AACzB,gBAAI,oBAAoB;AACtB,kBAAI;AAEF,sBAAM,gBAAgB,KAAK,gCAAgC,QAAQ,OAAO,QAAQ,WAAW;AAC7F,qCAAqB,MAAM,KAAK,gBAAgB,gBAAgB,cAAc,MAAM,GAAG,CAAC,GAAG,SAAS;AACpG,6BAAa,mBAAmB;AAAA,cAClC,SAAS,OAAO;AACd,gBAAAA,QAAO,KAAK,iCAAiC;AAAA,kBAC3C;AAAA,kBACA,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,gBAC9D,CAAC;AAAA,cACH;AAAA,YACF;AAGA,kBAAM,kBAAkB,KAAK,+BAA+B,iBAAiB,cAAc,kBAAkB;AAE7G,kBAAM,WAAW;AAAA,cACf,SAAS;AAAA,gBACP,IAAI;AAAA,gBACJ,OAAO,QAAQ;AAAA,gBACf,aAAa,QAAQ,YAAY,UAAU,GAAG,GAAG,KAAK,QAAQ,YAAY,SAAS,MAAM,QAAQ;AAAA,gBACjG,WAAW,QAAQ;AAAA,gBACnB,aAAa,QAAQ;AAAA,gBACrB,SAAS,QAAQ;AAAA,gBACjB,YAAY;AAAA,kBACV,MAAM,QAAQ,WAAW,MAAM;AAAA,gBACjC;AAAA,gBACA,UAAU;AAAA,kBACR,gBAAgB,QAAQ,kBAAkB,OAAO;AAAA,kBACjD,UAAU,QAAQ,kBAAkB,SAAS;AAAA,gBAC/C;AAAA,cACF;AAAA,cACA,YAAY;AAAA,gBACV,iBAAiB,SAAS,OAAO,mBAAmB,GAAG;AAAA,gBACvD,WAAW,SAAS,OAAO,aAAa,GAAG;AAAA,gBAC3C,YAAY,SAAS,OAAO,cAAc,GAAG;AAAA,gBAC7C,uBAAuB,OAAO,0BAA0B;AAAA,cAC1D;AAAA,cACA,UAAU;AAAA,cACV,eAAe;AAAA,gBACb,QAAQ,aAAa,MAAM,GAAG,CAAC,EAAE,IAAI,YAAU;AAAA,kBAC7C,IAAI,MAAM;AAAA,kBACV,OAAO,MAAM,QAAQ;AAAA,kBACrB,aAAa,MAAM,QAAQ;AAAA,kBAC3B,WAAW,SAAS,MAAM,YAAY,aAAa,GAAG;AAAA,kBACtD,WAAW,SAAS,MAAM,YAAY,aAAa,GAAG;AAAA,kBACtD,cAAc,SAAS,MAAM,YAAY,gBAAgB,GAAG;AAAA,kBAC5D,UAAU,KAAK,oBAAoB,KAAK,uBAAuB,MAAM,gBAAgB,YAAY,MAAM,CAAC;AAAA,gBAC1G,EAAE;AAAA,gBACF,eAAe,aAAa;AAAA,cAC9B;AAAA,cACA,GAAI,sBAAsB,EAAE,mBAAmB;AAAA,cAC/C;AAAA,cACA,UAAU;AAAA,gBACR,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,gBACnC;AAAA,gBACA;AAAA,cACF;AAAA,YACF;AAEA,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,KAAK,UAAU,UAAU,MAAM,CAAC;AAAA,cACxC,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UAEF,SAAS,OAAO;AACd,kBAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAE1E,mBAAO;AAAA,cACL,SAAS,CAAC;AAAA,gBACR,MAAM;AAAA,gBACN,MAAM,qCAAqC,YAAY;AAAA,cACzD,CAAC;AAAA,cACD,SAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF,GAhLS;AAAA,MAiLX;AAAA,IACF;AAGA,eAAW,QAAQ,cAAc;AAC/B,WAAK,SAAS,IAAI;AAAA,IACpB;AAAA,EACF;AACF;AAKO,IAAM,oBAAN,cAAgC,MAAM;AAAA,EAvjF7C,OAujF6C;AAAA;AAAA;AAAA,EAC3C,YAAY,SAAiB;AAC3B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,kBAAN,cAA8B,MAAM;AAAA,EA9jF3C,OA8jF2C;AAAA;AAAA;AAAA,EACzC,YAAY,SAAiB;AAC3B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;AAEO,IAAM,eAAN,cAA2B,MAAM;AAAA,EArkFxC,OAqkFwC;AAAA;AAAA;AAAA,EACtB;AAAA,EAEhB,YAAY,MAAoB,SAAiB;AAC/C,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EACd;AACF;;;ANjjFO,IAAM,kBAAN,MAAsB;AAAA,EAc3B,YAAoB,KAA4B;AAA5B;AAElB,SAAK,gBAAgB,IAAI,qBAAqB,GAAG;AACjD,SAAK,SAAS,IAAI,WAAW,KAAK,cAAc,iBAAiB,CAAC;AAClE,SAAK,eAAe,IAAI,iBAAiB,KAAK,MAAM;AACpD,SAAK,eAAe,IAAI,iBAAiB,KAAK,eAAe,KAAK,MAAM;AAGxE,SAAK,iBAAiB,IAAI,eAAe,KAAK,eAAe,KAAK,QAAQ,GAAG;AAG7E,SAAK,cAAc,IAAI,sBAAsB,KAAK,KAAK,QAAQ,KAAK,YAAY;AAChF,SAAK,oBAAoB,IAAI,4BAA4B,KAAK,KAAK,QAAQ,KAAK,YAAY;AAC5F,SAAK,cAAc,IAAI;AAAA,MACrB;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA,EA9DF,OA4B6B;AAAA;AAAA;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAGA;AAAA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA,EA2BR,MAAM,aAA4B;AAChC,QAAI;AACF,WAAK,OAAO,KAAK,gCAAgC;AAGjD,YAAM,KAAK,yBAAyB;AAEpC,WAAK,OAAO,KAAK,8CAA8C;AAAA,QAC7D,iBAAiB,KAAK,aAAa,UAAU,EAAE;AAAA,QAC/C,oBAAoB,CAAC,aAAa,kBAAkB,aAAa,YAAY;AAAA,MAC/E,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,0CAA0C;AAAA,QAC1D,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AACD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,SAAsD;AACxE,UAAM,EAAE,SAAS,KAAK,IAAI,IAAI;AAC9B,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAE/B,QAAI;AAEF,UAAI,IAAI,aAAa,WAAW;AAC9B,eAAO,MAAM,KAAK,kBAAkB;AAAA,MACtC;AAGA,UAAI,IAAI,aAAa,SAAS,QAAQ,QAAQ,IAAI,SAAS,MAAM,aAAa;AAC5E,eAAO,MAAM,KAAK,YAAY,cAAc,OAAO;AAAA,MACrD;AAGA,UAAI,IAAI,SAAS,WAAW,OAAO,GAAG;AACpC,eAAO,MAAM,KAAK,iBAAiB,OAAO;AAAA,MAC5C;AAGA,UAAI,IAAI,aAAa,UAAU,QAAQ,WAAW,QAAQ;AACxD,eAAO,MAAM,KAAK,iBAAiB,OAAO;AAAA,MAC5C;AAGA,aAAO,IAAI,SAAS,2DAA2D;AAAA,QAC7E,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,aAAa;AAAA,MAC1C,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,2BAA2B;AAAA,QAC3C,QAAQ,QAAQ;AAAA,QAChB,KAAK,QAAQ;AAAA,QACb,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AAED,aAAO,KAAK,aAAa;AAAA,QACvB;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,oBAAuC;AACnD,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,gBAAgB;AAE1C,YAAM,aAAa,OAAO,WAAW,YAAY,MAC/B,OAAO,WAAW,aAAa,MAAM;AAEvD,aAAO,IAAI,SAAS,KAAK,UAAU,MAAM,GAAG;AAAA,QAC1C,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAChD,CAAC;AAAA,IAEH,SAAS,OAAO;AACd,aAAO,KAAK,aAAa;AAAA,QACvB;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAiB,SAAqC;AAClE,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,UAAM,YAAY,IAAI,SAAS,MAAM,GAAG,EAAE,OAAO,OAAO;AAGxD,QAAI,UAAU,CAAC,MAAM,SAAS;AAC5B,UAAI,QAAQ,WAAW,SAAS,UAAU,WAAW,GAAG;AAEtD,cAAM,QAAQ,KAAK,aAAa,UAAU;AAC1C,eAAO,IAAI,SAAS,KAAK,UAAU,EAAE,MAAM,CAAC,GAAG;AAAA,UAC7C,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD,CAAC;AAAA,MACH;AAEA,UAAI,QAAQ,WAAW,UAAU,UAAU,WAAW,GAAG;AAEvD,cAAM,WAAW,UAAU,CAAC;AAC5B,cAAM,QAAQ,MAAM,QAAQ,KAAK;AAGjC,cAAM,cAA0B;AAAA,UAC9B,aAAa;AAAA,UACb,WAAW,OAAO,WAAW;AAAA,QAC/B;AAEA,YAAI;AACF,gBAAM,SAAS,MAAM,KAAK,aAAa,YAAY,UAAU,OAAO,WAAW;AAC/E,iBAAO,IAAI,SAAS,KAAK,UAAU,MAAM,GAAG;AAAA,YAC1C,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,UAChD,CAAC;AAAA,QACH,SAAS,OAAO;AACd,iBAAO,KAAK,aAAa;AAAA,YACvB;AAAA,YACA,iBAAiB,QAAQ,MAAM,UAAU;AAAA,YACzC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,KAAK,aAAa,oBAAoB,KAAK,0BAA0B,eAAe;AAAA,EAC7F;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAiB,SAAqC;AAClE,QAAI;AACF,YAAM,aAAa,MAAM,QAAQ,KAAK;AAGtC,cAAQ,WAAW,QAAQ;AAAA,QACzB,KAAK;AACH,gBAAM,QAAQ,KAAK,aAAa,UAAU;AAC1C,iBAAO,IAAI,SAAS,KAAK,UAAU;AAAA,YACjC,SAAS;AAAA,YACT,IAAI,WAAW;AAAA,YACf,QAAQ,EAAE,MAAM;AAAA,UAClB,CAAC,GAAG;AAAA,YACF,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,UAChD,CAAC;AAAA,QAEH,KAAK;AACH,gBAAM,cAA0B;AAAA,YAC9B,aAAa;AAAA,YACb,WAAW,OAAO,WAAW;AAAA,UAC/B;AAEA,gBAAM,SAAS,MAAM,KAAK,aAAa;AAAA,YACrC,WAAW,OAAO;AAAA,YAClB,WAAW,OAAO;AAAA,YAClB;AAAA,UACF;AAEA,iBAAO,IAAI,SAAS,KAAK,UAAU;AAAA,YACjC,SAAS;AAAA,YACT,IAAI,WAAW;AAAA,YACf;AAAA,UACF,CAAC,GAAG;AAAA,YACF,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,UAChD,CAAC;AAAA,QAEH;AACE,iBAAO,KAAK,aAAa;AAAA,YACvB;AAAA,YACA,uBAAuB,WAAW,MAAM;AAAA,YACxC;AAAA,UACF;AAAA,MACJ;AAAA,IAEF,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,+BAA+B;AAAA,QAC/C,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AAED,aAAO,KAAK,aAAa;AAAA,QACvB;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,2BAA0C;AAGtD,UAAM,KAAK,aAAa,WAAW;AAEnC,UAAM,kBAAkB,KAAK,aAAa,UAAU;AAEpD,SAAK,OAAO,KAAK,0CAA0C;AAAA,MACzD,WAAW,gBAAgB;AAAA,MAC3B,WAAW,gBAAgB,IAAI,OAAK,EAAE,IAAI;AAAA,IAC5C,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBAAyC;AAC7C,QAAI;AAEF,YAAM,kBAAkB,KAAK,kBAAkB,mBAAmB;AAClE,YAAM,YAAY,KAAK,YAAY,aAAa;AAChD,YAAM,UAAU,KAAK,YAAY,mBAAmB;AAGpD,YAAM,WAAW;AAAA,QACf,SAAS;AAAA;AAAA,QACT,OAAO;AAAA;AAAA,QACP,UAAU;AAAA;AAAA,MACZ;AAGA,UAAI,SAA+C;AAEnD,UAAI,gBAAgB,oBAAoB,gBAAgB,mBAAmB,KAAK;AAC9E,iBAAS;AAAA,MACX;AAEA,aAAO;AAAA,QACL;AAAA,QACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QAClC,SAAS;AAAA,UACP,mBAAmB,gBAAgB;AAAA,UACnC,eAAe;AAAA;AAAA,UACf,qBAAqB;AAAA;AAAA,UACrB,WAAW;AAAA;AAAA,UACX,YAAY,UAAU;AAAA,QACxB;AAAA,QACA;AAAA,MACF;AAAA,IAEF,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,uBAAuB;AAAA,QACvC,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AAED,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QAClC,SAAS;AAAA,UACP,mBAAmB;AAAA,UACnB,eAAe;AAAA,UACf,qBAAqB;AAAA,UACrB,WAAW;AAAA,UACX,YAAY;AAAA,QACd;AAAA,QACA,UAAU;AAAA,UACR,SAAS;AAAA,UACT,OAAO;AAAA,UACP,UAAU;AAAA,QACZ;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAA0B;AAC9B,SAAK,OAAO,KAAK,iCAAiC;AAElD,QAAI;AAEF,YAAM,KAAK,YAAY,oBAAoB;AAG3C,YAAM,QAAQ,IAAI;AAAA,QAChB,KAAK,kBAAkB,QAAQ;AAAA,QAC/B,KAAK,YAAY,QAAQ;AAAA,MAC3B,CAAC;AAED,WAAK,OAAO,KAAK,sCAAsC;AAAA,IAEzD,SAAS,OAAO;AACd,WAAK,OAAO,MAAM,yBAAyB;AAAA,QACzC,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAClD,CAAC;AAAA,IACH;AAAA,EACF;AACF;;;ADzWA;AACA;AAQA,IAAI,gBAA6C;AACjD,IAAI,SAA4B;AAChC,IAAI,eAAwC;AAC5C,IAAI,eAAwC;AAC5C,IAAI,kBAA0C;AAiB9C,eAAe,mBAAmB,KAA2C;AAE3E,MAAI,iBAAiB,UAAU,gBAAgB,gBAAgB,iBAAiB;AAC9E;AAAA,EACF;AAEA,MAAI;AAEF,QAAI,CAAC,eAAe;AAClB,sBAAgB,IAAI,qBAAqB,GAAG;AAC5C,YAAM,cAAc,WAAW;AAAA,IACjC;AAGA,QAAI,CAAC,QAAQ;AACX,eAAS,IAAI,WAAW,cAAc,iBAAiB,CAAC;AAAA,IAC1D;AAGA,QAAI,CAAC,cAAc;AACjB,qBAAe,IAAI,iBAAiB,MAAM;AAAA,IAC5C;AAGA,QAAI,CAAC,cAAc;AACjB,qBAAe,IAAI,iBAAiB,eAAe,MAAM;AAAA,IAC3D;AAGA,QAAI,CAAC,iBAAiB;AACpB,wBAAkB,IAAI,gBAAgB,GAAG;AACzC,YAAM,gBAAgB,WAAW;AAAA,IACnC;AAEA,WAAO,KAAK,uCAAuC;AAAA,EAErD,SAAS,OAAO;AACd,YAAQ,MAAM,kCAAkC,KAAK;AACrD,UAAM;AAAA,EACR;AACF;AAxCe;AA6Cf,eAAeI,OAAM,SAAkB,KAA4B,KAA0C;AAC3G,MAAI;AAEF,UAAM,mBAAmB,GAAG;AAG5B,QAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,iBAAiB;AACnF,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACjD;AAGA,UAAM,UAAoC;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,WAAO,MAAM,gBAAgB,cAAc,OAAO;AAAA,EAEpD,SAAS,OAAO;AAEd,YAAQ,MAAM,iBAAiB,KAAK;AAEpC,WAAO,IAAI,SAAS,KAAK,UAAU;AAAA,MACjC,SAAS;AAAA,MACT,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,QACT,MAAM;AAAA,UACJ,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,UAChD,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,QACpC;AAAA,MACF;AAAA,MACA,IAAI;AAAA,IACN,CAAC,GAAG;AAAA,MACF,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,+BAA+B;AAAA,QAC/B,gCAAgC;AAAA,QAChC,gCAAgC;AAAA,MAClC;AAAA,IACF,CAAC;AAAA,EACH;AACF;AA7Ce,OAAAA,QAAA;AAkDf,eAAe,YACb,SACA,KACA,KACmB;AACnB,MAAI;AACF,UAAM,mBAAmB,GAAG;AAE5B,UAAM,SAAS;AAAA,MACb,QAAQ;AAAA,MACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,UAAU;AAAA,QACR,eAAe,eAAe,cAAc,KAAK;AAAA,QACjD,QAAQ,WAAW;AAAA,QACnB,cAAc,iBAAiB;AAAA,QAC/B,cAAc,iBAAiB;AAAA,QAC/B,iBAAiB,oBAAoB;AAAA,MACvC;AAAA,MACA,aAAa,IAAI;AAAA,MACjB,SAAS;AAAA,IACX;AAEA,WAAO,IAAI,SAAS,KAAK,UAAU,QAAQ,MAAM,CAAC,GAAG;AAAA,MACnD,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,iBAAiB;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EAEH,SAAS,OAAO;AACd,UAAM,cAAc;AAAA,MAClB,QAAQ;AAAA,MACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,MAClC,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MAChD,SAAS;AAAA,IACX;AAEA,WAAO,IAAI,SAAS,KAAK,UAAU,aAAa,MAAM,CAAC,GAAG;AAAA,MACxD,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,iBAAiB;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH;AACF;AA9Ce;AAmDf,IAAO,cAAQ;AAAA,EACb,OAAAA;AAAA,EACA;AACF;;;AQzLA;AAAA;AAEA,IAAM,YAAwB,8BAAO,SAAS,KAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAAS,GAAG;AAAA,EAC7C,UAAE;AACD,QAAI;AACH,UAAI,QAAQ,SAAS,QAAQ,CAAC,QAAQ,UAAU;AAC/C,cAAM,SAAS,QAAQ,KAAK,UAAU;AACtC,eAAO,EAAE,MAAM,OAAO,KAAK,GAAG,MAAM;AAAA,QAAC;AAAA,MACtC;AAAA,IACD,SAAS,GAAG;AACX,cAAQ,MAAM,4CAA4C,CAAC;AAAA,IAC5D;AAAA,EACD;AACD,GAb8B;AAe9B,IAAO,6CAAQ;;;ACjBf;AAAA;AASA,SAAS,YAAY,GAAmB;AACvC,SAAO;AAAA,IACN,MAAM,GAAG;AAAA,IACT,SAAS,GAAG,WAAW,OAAO,CAAC;AAAA,IAC/B,OAAO,GAAG;AAAA,IACV,OAAO,GAAG,UAAU,SAAY,SAAY,YAAY,EAAE,KAAK;AAAA,EAChE;AACD;AAPS;AAUT,IAAM,YAAwB,8BAAO,SAAS,KAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAAS,GAAG;AAAA,EAC7C,SAAS,GAAQ;AAChB,UAAM,QAAQ,YAAY,CAAC;AAC3B,WAAO,SAAS,KAAK,OAAO;AAAA,MAC3B,QAAQ;AAAA,MACR,SAAS,EAAE,+BAA+B,OAAO;AAAA,IAClD,CAAC;AAAA,EACF;AACD,GAV8B;AAY9B,IAAO,2CAAQ;;;AVzBJ,IAAM,mCAAmC;AAAA,EAE9B;AAAA,EAAyB;AAC3C;AACA,IAAO,sCAAQ;;;AWVnB;AAAA;AAwBA,IAAM,wBAAsC,CAAC;AAKtC,SAAS,uBAAuB,MAAqC;AAC3E,wBAAsB,KAAK,GAAG,KAAK,KAAK,CAAC;AAC1C;AAFgB;AAShB,SAAS,uBACR,SACA,KACA,KACA,UACA,iBACsB;AACtB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI;AACxB,QAAM,gBAAmC;AAAA,IACxC;AAAA,IACA,KAAK,YAAY,QAAQ;AACxB,aAAO,uBAAuB,YAAY,QAAQ,KAAK,UAAU,IAAI;AAAA,IACtE;AAAA,EACD;AACA,SAAO,KAAK,SAAS,KAAK,KAAK,aAAa;AAC7C;AAfS;AAiBF,SAAS,kBACf,SACA,KACA,KACA,UACA,iBACsB;AACtB,SAAO,uBAAuB,SAAS,KAAK,KAAK,UAAU;AAAA,IAC1D,GAAG;AAAA,IACH;AAAA,EACD,CAAC;AACF;AAXgB;;;AZ3ChB,IAAM,iCAAN,MAAM,gCAA8D;AAAA,EAGnE,YACU,eACA,MACT,SACC;AAHQ;AACA;AAGT,SAAK,WAAW;AAAA,EACjB;AAAA,EArBD,OAYoE;AAAA;AAAA;AAAA,EAC1D;AAAA,EAUT,UAAU;AACT,QAAI,EAAE,gBAAgB,kCAAiC;AACtD,YAAM,IAAI,UAAU,oBAAoB;AAAA,IACzC;AAEA,SAAK,SAAS;AAAA,EACf;AACD;AAEA,SAAS,oBAAoB,QAA0C;AAEtE,MACC,qCAAqC,UACrC,iCAAiC,WAAW,GAC3C;AACD,WAAO;AAAA,EACR;AAEA,aAAW,cAAc,kCAAkC;AAC1D,wBAAoB,UAAU;AAAA,EAC/B;AAEA,QAAM,kBAA+C,gCACpD,SACA,KACA,KACC;AACD,QAAI,OAAO,UAAU,QAAW;AAC/B,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC9D;AACA,WAAO,OAAO,MAAM,SAAS,KAAK,GAAG;AAAA,EACtC,GATqD;AAWrD,SAAO;AAAA,IACN,GAAG;AAAA,IACH,MAAM,SAAS,KAAK,KAAK;AACxB,YAAM,aAAyB,gCAAU,MAAM,MAAM;AACpD,YAAI,SAAS,eAAe,OAAO,cAAc,QAAW;AAC3D,gBAAM,aAAa,IAAI;AAAA,YACtB,KAAK,IAAI;AAAA,YACT,KAAK,QAAQ;AAAA,YACb,MAAM;AAAA,YAAC;AAAA,UACR;AACA,iBAAO,OAAO,UAAU,YAAY,KAAK,GAAG;AAAA,QAC7C;AAAA,MACD,GAT+B;AAU/B,aAAO,kBAAkB,SAAS,KAAK,KAAK,YAAY,eAAe;AAAA,IACxE;AAAA,EACD;AACD;AAxCS;AA0CT,SAAS,qBACR,OAC8B;AAE9B,MACC,qCAAqC,UACrC,iCAAiC,WAAW,GAC3C;AACD,WAAO;AAAA,EACR;AAEA,aAAW,cAAc,kCAAkC;AAC1D,wBAAoB,UAAU;AAAA,EAC/B;AAGA,SAAO,cAAc,MAAM;AAAA,IAC1B,mBAAyE,wBACxE,SACA,KACA,QACI;AACJ,WAAK,MAAM;AACX,WAAK,MAAM;AACX,UAAI,MAAM,UAAU,QAAW;AAC9B,cAAM,IAAI,MAAM,sDAAsD;AAAA,MACvE;AACA,aAAO,MAAM,MAAM,OAAO;AAAA,IAC3B,GAXyE;AAAA,IAazE,cAA0B,wBAAC,MAAM,SAAS;AACzC,UAAI,SAAS,eAAe,MAAM,cAAc,QAAW;AAC1D,cAAM,aAAa,IAAI;AAAA,UACtB,KAAK,IAAI;AAAA,UACT,KAAK,QAAQ;AAAA,UACb,MAAM;AAAA,UAAC;AAAA,QACR;AACA,eAAO,MAAM,UAAU,UAAU;AAAA,MAClC;AAAA,IACD,GAT0B;AAAA,IAW1B,MAAM,SAAwD;AAC7D,aAAO;AAAA,QACN;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,MACN;AAAA,IACD;AAAA,EACD;AACD;AAnDS;AAqDT,IAAI;AACJ,IAAI,OAAO,wCAAU,UAAU;AAC9B,kBAAgB,oBAAoB,mCAAK;AAC1C,WAAW,OAAO,wCAAU,YAAY;AACvC,kBAAgB,qBAAqB,mCAAK;AAC3C;AACA,IAAO,kCAAQ;",
  "names": ["logger", "track", "logger", "errorHandler", "logger", "errorHandler", "logger", "errorHandler", "logger", "logger", "YouTubeService", "ConfigurationService", "LoggerUtil", "fetch"]
}
